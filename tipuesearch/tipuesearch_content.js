var tipuesearch = {"pages":[{"text":"FLOw FLOw FLOw, Fortran fLuid Object A KISS pure Fortran Library providing a Fluid Object designed for building CFD codes: FLOw is a pure Fortran (KISS) library providing a Fluid Object designed for building CFD codes; FLOw is Fortran 2008+ standard compliant; FLOw is OOP designed; FLOw is TDD developed; FLOw is a Free, Open Source Project. A taste of FLOw use flow type ( fluid_object ) :: state call state % initialize ( pressure = 1 , density = 0.125 , cp = 1024 , cv = 712 ) ... To be completed. Issues Compiler Support What is FLOw? | Main features | Copyrights | Download | Compilation | Documentation | References What is FLOw? FLOw is a modern Fortran library providing a Fluid Object designed for building CFD codes. To be completed. How to use To be written. Go to Top Main features To be written. Any feature request is welcome. Go to Top Copyrights FLOw is a Free and Open Source Software (FOSS), it is distributed under a very permissive multi-licensing system: selectable licenses are GPLv3 , BSD2-Clause , BSD3-Clause and MIT , feel free to select the license that best matches your workflow. Anyone is interest to use, to develop or to contribute to FLOw is welcome. More details can be found on wiki . Go to Top Download To be written. Go to Top Compilation To be written. Documentation Besides this README file the FLOw documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . Go to Top Developer Info Stefano Zaghi","tags":"","loc":"index.html","title":" FLOw "},{"text":"FLOw, Fortran fLuid Object This File Depends On sourcefile~~flow.f90~~EfferentGraph sourcefile~flow.f90 flow.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_objects.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_objects.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_objects.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_field_objects.f90 var pansourcefileflowf90EfferentGraph = svgPanZoom('#sourcefileflowf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flow.f90~~AfferentGraph sourcefile~flow.f90 flow.f90 sourcefile~flow_test_primitive_eq.f90 flow_test_primitive_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_eq.f90 sourcefile~flow_test_primitive_pow.f90 flow_test_primitive_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_pow.f90 sourcefile~flow_test_primitive_mul.f90 flow_test_primitive_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_mul.f90 sourcefile~flow_test_primitive_not_eq.f90 flow_test_primitive_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_not_eq.f90 sourcefile~flow_test_primitive_div.f90 flow_test_primitive_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_div.f90 sourcefile~flow_test_primitive_add.f90 flow_test_primitive_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_add.f90 sourcefile~flow_test_primitive_assign.f90 flow_test_primitive_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_assign.f90 sourcefile~flow_test_primitive_sub.f90 flow_test_primitive_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_sub.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flow Source Code flow.f90 Source Code !< FLOw, Fortran fLuid Object module flow use flow_field_object use flow_field_objects use flow_primitive_object use penf implicit none private public :: field_object public :: field_object_scalar public :: field_object_vectorial public :: primitive_object ! expose PENF kinds public :: I_P , I1P , I2P , I4P , I8P , R_P , R4P , R8P , R16P endmodule flow","tags":"","loc":"sourcefile/flow.f90.html","title":"flow.f90 – FLOw"},{"text":"FLOw field (abstract) object. This File Depends On sourcefile~~flow_field_object.f90~~EfferentGraph sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflow_field_objectf90EfferentGraph = svgPanZoom('#sourcefileflow_field_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flow_field_object.f90~~AfferentGraph sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_objects.f90 sourcefile~flow_test_primitive_eq.f90 flow_test_primitive_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_eq.f90 sourcefile~flow_test_primitive_pow.f90 flow_test_primitive_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_pow.f90 sourcefile~flow_test_primitive_mul.f90 flow_test_primitive_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_mul.f90 sourcefile~flow_test_primitive_not_eq.f90 flow_test_primitive_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_not_eq.f90 sourcefile~flow_test_primitive_div.f90 flow_test_primitive_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_div.f90 sourcefile~flow_test_primitive_add.f90 flow_test_primitive_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_add.f90 sourcefile~flow_test_primitive_assign.f90 flow_test_primitive_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_assign.f90 sourcefile~flow_test_primitive_sub.f90 flow_test_primitive_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_sub.f90 sourcefile~flow_field_objects.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 var pansourcefileflow_field_objectf90AfferentGraph = svgPanZoom('#sourcefileflow_field_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flow_field_object Source Code flow_field_object.f90 Source Code !< FLOw **field** (abstract) object. module flow_field_object !< FLOw **field** (abstract) object. use penf implicit none private public :: field_object type , abstract :: field_object !< **field** (abstract) object. contains ! deferred operators methods procedure ( abstract_assign ), pass ( lhs ), deferred :: assign_field !< Assign fields. procedure ( abstract_assign_real ), pass ( lhs ), deferred :: assign_real !< Assign real to field. procedure ( abstract_simmetric_operator ), pass ( lhs ), deferred :: add !< Add fields. procedure ( abstract_simmetric_operator ), pass ( lhs ), deferred :: div !< Divide fields. procedure ( abstract_field_op_integer ), pass ( lhs ), deferred :: div_integer !< Divide field by integer. procedure ( abstract_field_op_real ), pass ( lhs ), deferred :: div_real !< Divide field by real. procedure ( abstract_simmetric_operator ), pass ( lhs ), deferred :: mul !< Multiply fields. procedure ( abstract_field_op_integer ), pass ( lhs ), deferred :: mul_integer !< Multiply field for integer. procedure ( abstract_integer_op_field ), pass ( rhs ), deferred :: integer_mul !< Multiply integer for field. procedure ( abstract_field_op_real ), pass ( lhs ), deferred :: mul_real !< Multiply field for real. procedure ( abstract_real_op_field ), pass ( rhs ), deferred :: real_mul !< Multiply real for field. procedure ( abstract_simmetric_operator ), pass ( lhs ), deferred :: sub !< Subtract fields. procedure ( abstract_field_op_integer ), pass ( lhs ), deferred :: pow_integer !< Power field by integer. procedure ( abstract_field_op_real ), pass ( lhs ), deferred :: pow_real !< Power field by real. procedure ( abstract_compare ), pass ( lhs ), deferred :: eq !< Compare (`==') fields. procedure ( abstract_compare ), pass ( lhs ), deferred :: not_eq !< Compare (`/=') fields. ! public operators generic :: assignment ( = ) => assign_field , assign_real !< Assignment overloading. generic :: operator ( + ) => add !< Operator `+` overloading. generic :: operator ( / ) => div , div_integer , div_real !< Operator `/` overloading. generic :: operator ( * ) => mul , mul_integer , integer_mul , real_mul , mul_real !< Operator `*` overloading. generic :: operator ( - ) => sub !< Operator `-` overloading. generic :: operator ( ** ) => pow_integer , pow_real !< Operator `**` overloading. generic :: operator ( == ) => eq !< Operator `/=` overloading. generic :: operator ( /= ) => not_eq !< Operator `/=` overloading. endtype field_object ! deferred public methods interfaces abstract interface !< Assignment overloading. pure subroutine abstract_assign ( lhs , rhs ) !< Assign fields. import :: field_object class ( field_object ), intent ( inout ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. endsubroutine abstract_assign pure subroutine abstract_assign_real ( lhs , rhs ) !< Assign real to field. import :: field_object , R_P class ( field_object ), intent ( inout ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. endsubroutine abstract_assign_real endinterface abstract interface !< Symmetric operator field.op.field. pure function abstract_simmetric_operator ( lhs , rhs ) result ( opr ) !< Symmetric operator field.op.field. import :: field_object class ( field_object ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. endfunction abstract_simmetric_operator endinterface abstract interface !< Non symmetric operator integer.op.field. pure function abstract_integer_op_field ( lhs , rhs ) result ( opr ) !< Non symmetric operator integer.op.field. import :: field_object , I_P integer ( I_P ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. endfunction abstract_integer_op_field endinterface abstract interface !< Non symmetric operator field.op.integer. pure function abstract_field_op_integer ( lhs , rhs ) result ( opr ) !< Non symmetric operator field.op.integer. import :: field_object , I_P class ( field_object ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. endfunction abstract_field_op_integer endinterface abstract interface !< Non symmetric operator field.op.real. pure function abstract_field_op_real ( lhs , rhs ) result ( opr ) !< Non symmetric operator field.op.real. import :: field_object , R_P class ( field_object ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. endfunction abstract_field_op_real endinterface abstract interface !< Non symmetric operator real.op.field. pure function abstract_real_op_field ( lhs , rhs ) result ( opr ) !< Non symmetric operator real.op.field. import :: field_object , R_P real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. endfunction abstract_real_op_field endinterface abstract interface !< Compare overloading. pure function abstract_compare ( lhs , rhs ) result ( opr ) !< Compare overloading. import :: field_object class ( field_object ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. endfunction abstract_compare endinterface endmodule flow_field_object","tags":"","loc":"sourcefile/flow_field_object.f90.html","title":"flow_field_object.f90 – FLOw"},{"text":"FLOw field concrete objects. This File Depends On sourcefile~~flow_field_objects.f90~~EfferentGraph sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_objects.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_field_objects.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_field_objects.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflow_field_objectsf90EfferentGraph = svgPanZoom('#sourcefileflow_field_objectsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flow_field_objects.f90~~AfferentGraph sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_field_objects.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_test_primitive_eq.f90 flow_test_primitive_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_eq.f90 sourcefile~flow_test_primitive_pow.f90 flow_test_primitive_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_pow.f90 sourcefile~flow_test_primitive_mul.f90 flow_test_primitive_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_mul.f90 sourcefile~flow_test_primitive_not_eq.f90 flow_test_primitive_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_not_eq.f90 sourcefile~flow_test_primitive_div.f90 flow_test_primitive_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_div.f90 sourcefile~flow_test_primitive_add.f90 flow_test_primitive_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_add.f90 sourcefile~flow_test_primitive_assign.f90 flow_test_primitive_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_assign.f90 sourcefile~flow_test_primitive_sub.f90 flow_test_primitive_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_sub.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flow_field_objects Source Code flow_field_objects.f90 Source Code !< FLOw **field** concrete objects. module flow_field_objects !< FLOw **scalar field** object. use flow_field_object use penf use vecfor implicit none private public :: field_object_scalar public :: field_object_vectorial type , extends ( field_object ) :: field_object_scalar !< **scalar field** object. real ( R_P ) :: field !< Scalar field. contains ! deferred methods procedure , pass ( lhs ) :: assign_field => assign_field_scalar !< Assign fields. procedure , pass ( lhs ) :: assign_real => assign_real_scalar !< Assign real to field. procedure , pass ( lhs ) :: add => scalar_add_scalar !< Add fields. procedure , pass ( lhs ) :: div => scalar_div_scalar !< Divide fields. procedure , pass ( lhs ) :: div_integer => scalar_div_integer !< Divide field by integer. procedure , pass ( lhs ) :: div_real => scalar_div_real !< Divide field by real. procedure , pass ( lhs ) :: mul => scalar_mul_object !< Multiply fields. procedure , pass ( lhs ) :: mul_integer => scalar_mul_integer !< Multiply field for integer. procedure , pass ( rhs ) :: integer_mul => integer_mul_scalar !< Multiply scalar or field. procedure , pass ( lhs ) :: mul_real => scalar_mul_real !< Multiply field for real. procedure , pass ( rhs ) :: real_mul => real_mul_scalar !< Multiply real for field. procedure , pass ( lhs ) :: sub => scalar_sub_scalar !< Subtract fields. procedure , pass ( lhs ) :: pow_integer => scalar_pow_integer !< Power field by integer. procedure , pass ( lhs ) :: pow_real => scalar_pow_real !< Power field by real. procedure , pass ( lhs ) :: eq => eq_scalar !< Compare (`==') fields. procedure , pass ( lhs ) :: not_eq => not_eq_scalar !< Compare (`/=') fields. endtype field_object_scalar type , extends ( field_object ) :: field_object_vectorial !< **vectorial field** object. type ( vector ) :: field !< Vectorial field. contains ! deferred methods procedure , pass ( lhs ) :: assign_field => assign_field_vectorial !< Assign fields. procedure , pass ( lhs ) :: assign_real => assign_real_vectorial !< Assign real to field. procedure , pass ( lhs ) :: add => vectorial_add_vectorial !< Add fields. procedure , pass ( lhs ) :: div => vectorial_div_object !< Divide fields. procedure , pass ( lhs ) :: div_integer => vectorial_div_integer !< Divide field by integer. procedure , pass ( lhs ) :: div_real => vectorial_div_real !< Divide field by real. procedure , pass ( lhs ) :: mul => vectorial_mul_object !< Multiply fields. procedure , pass ( lhs ) :: mul_integer => vectorial_mul_integer !< Multiply field for integer. procedure , pass ( rhs ) :: integer_mul => integer_mul_vectorial !< Multiply integer for field. procedure , pass ( lhs ) :: mul_real => vectorial_mul_real !< Multiply field for real. procedure , pass ( rhs ) :: real_mul => real_mul_vectorial !< Multiply real for field. procedure , pass ( lhs ) :: sub => vectorial_sub_vectorial !< Subtract fields. procedure , pass ( lhs ) :: pow_integer => vectorial_pow_integer !< Power field by integer. procedure , pass ( lhs ) :: pow_real => vectorial_pow_real !< Power field by real. procedure , pass ( lhs ) :: eq => eq_vectorial !< Compare (`==') fields. procedure , pass ( lhs ) :: not_eq => not_eq_vectorial !< Compare (`/=') fields. endtype field_object_vectorial contains ! deferred public methods ! scalar field pure subroutine assign_field_scalar ( lhs , rhs ) !< Assign fields. class ( field_object_scalar ), intent ( inout ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( field_object_scalar ) lhs % field = rhs % field endselect endsubroutine assign_field_scalar pure subroutine assign_real_scalar ( lhs , rhs ) !< Assign real to field. class ( field_object_scalar ), intent ( inout ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. lhs % field = rhs endsubroutine assign_real_scalar pure function scalar_add_scalar ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) select type ( rhs ) class is ( field_object_scalar ) opr % field = lhs % field + rhs % field endselect endselect endfunction scalar_add_scalar pure function scalar_div_scalar ( lhs , rhs ) result ( opr ) !< Divide fields. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) select type ( rhs ) class is ( field_object_scalar ) opr % field = lhs % field / rhs % field endselect endselect endfunction scalar_div_scalar pure function scalar_div_integer ( lhs , rhs ) result ( opr ) !< Divide field by integer. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs % field / rhs endselect endfunction scalar_div_integer pure function scalar_div_real ( lhs , rhs ) result ( opr ) !< Divide field by real. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs % field / rhs endselect endfunction scalar_div_real pure function scalar_mul_object ( lhs , rhs ) result ( opr ) !< Multiply fields. !< !< @note The combinations accepted are: !<+ `field_object_scalar * field_object_vectorial => field_object_vectorial` !<+ `field_object_scalar * field_object_scalar    => field_object_scalar` class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. select type ( rhs ) type is ( field_object_vectorial ) allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field = lhs % field * rhs % field endselect class is ( field_object_scalar ) allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs % field * rhs % field endselect endselect endfunction scalar_mul_object pure function scalar_mul_integer ( lhs , rhs ) result ( opr ) !< Multiply field for integer. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs % field * rhs endselect endfunction scalar_mul_integer pure function integer_mul_scalar ( lhs , rhs ) result ( opr ) !< Multiply integer for field. integer ( I_P ), intent ( in ) :: lhs !< Left hand side. class ( field_object_scalar ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs * rhs % field endselect endfunction integer_mul_scalar pure function scalar_mul_real ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs % field * rhs endselect endfunction scalar_mul_real pure function real_mul_scalar ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_object_scalar ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs * rhs % field endselect endfunction real_mul_scalar pure function scalar_sub_scalar ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) select type ( rhs ) class is ( field_object_scalar ) opr % field = lhs % field - rhs % field endselect endselect endfunction scalar_sub_scalar pure function scalar_pow_integer ( lhs , rhs ) result ( opr ) !< Power field by integer. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs % field ** rhs endselect endfunction scalar_pow_integer pure function scalar_pow_real ( lhs , rhs ) result ( opr ) !< Power field by real. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs % field ** rhs endselect endfunction scalar_pow_real pure function eq_scalar ( lhs , rhs ) result ( opr ) !< Compare (`==`) fields. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . false . select type ( rhs ) class is ( field_object_scalar ) opr = lhs % field == rhs % field endselect endfunction eq_scalar pure function not_eq_scalar ( lhs , rhs ) result ( opr ) !< Compare (`/=`) fields. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . false . select type ( rhs ) class is ( field_object_scalar ) opr = lhs % field /= rhs % field endselect endfunction not_eq_scalar ! vectorial field pure subroutine assign_field_vectorial ( lhs , rhs ) !< Assign fields. class ( field_object_vectorial ), intent ( inout ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( field_object_vectorial ) lhs % field = rhs % field endselect endsubroutine assign_field_vectorial pure subroutine assign_real_vectorial ( lhs , rhs ) !< Assign real to field. class ( field_object_vectorial ), intent ( inout ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. lhs % field = rhs endsubroutine assign_real_vectorial pure function vectorial_add_vectorial ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) select type ( rhs ) class is ( field_object_vectorial ) opr % field = lhs % field + rhs % field endselect endselect endfunction vectorial_add_vectorial pure function vectorial_div_object ( lhs , rhs ) result ( opr ) !< Divide fields. !< !< @note The combinations accepted are: !<+ `field_object_vectorial / field_object_vectorial => field_object_vectorial` !<+ `field_object_vectorial / field_object_scalar    => field_object_vectorial` class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) select type ( rhs ) class is ( field_object_vectorial ) opr % field = lhs % field / rhs % field class is ( field_object_scalar ) opr % field = lhs % field / rhs % field endselect endselect endfunction vectorial_div_object pure function vectorial_div_integer ( lhs , rhs ) result ( opr ) !< Divide field by integer. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field = lhs % field / rhs endselect endfunction vectorial_div_integer pure function vectorial_div_real ( lhs , rhs ) result ( opr ) !< Divide field by real. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field = lhs % field / rhs endselect endfunction vectorial_div_real pure function vectorial_mul_object ( lhs , rhs ) result ( opr ) !< Multiply fields. !< !< @note The combinations accepted are: !<+ `field_object_vectorial * field_object_vectorial => field_object_vectorial` !<+ `field_object_vectorial * field_object_scalar    => field_object_vectorial` class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) select type ( rhs ) class is ( field_object_vectorial ) opr % field = lhs % field * rhs % field class is ( field_object_scalar ) opr % field = lhs % field * rhs % field endselect endselect endfunction vectorial_mul_object pure function vectorial_mul_integer ( lhs , rhs ) result ( opr ) !< Multiply field for integer. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field = lhs % field * rhs endselect endfunction vectorial_mul_integer pure function integer_mul_vectorial ( lhs , rhs ) result ( opr ) !< Multiply integer for field. integer ( I_P ), intent ( in ) :: lhs !< Left hand side. class ( field_object_vectorial ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field = lhs * rhs % field endselect endfunction integer_mul_vectorial pure function vectorial_mul_real ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field = lhs % field * rhs endselect endfunction vectorial_mul_real pure function real_mul_vectorial ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_object_vectorial ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field = lhs * rhs % field endselect endfunction real_mul_vectorial pure function vectorial_sub_vectorial ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) select type ( rhs ) class is ( field_object_vectorial ) opr % field = lhs % field - rhs % field endselect endselect endfunction vectorial_sub_vectorial pure function vectorial_pow_integer ( lhs , rhs ) result ( opr ) !< Power field by integer. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field % x = lhs % field % x ** rhs opr % field % y = lhs % field % y ** rhs opr % field % z = lhs % field % z ** rhs endselect endfunction vectorial_pow_integer pure function vectorial_pow_real ( lhs , rhs ) result ( opr ) !< Power field by real. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field % x = lhs % field % x ** rhs opr % field % y = lhs % field % y ** rhs opr % field % z = lhs % field % z ** rhs endselect endfunction vectorial_pow_real pure function eq_vectorial ( lhs , rhs ) result ( opr ) !< Compare (`==`) fields. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . false . select type ( rhs ) class is ( field_object_vectorial ) opr = lhs % field == rhs % field endselect endfunction eq_vectorial pure function not_eq_vectorial ( lhs , rhs ) result ( opr ) !< Compare (`/=`) fields. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . false . select type ( rhs ) class is ( field_object_vectorial ) opr = lhs % field /= rhs % field endselect endfunction not_eq_vectorial endmodule flow_field_objects","tags":"","loc":"sourcefile/flow_field_objects.f90.html","title":"flow_field_objects.f90 – FLOw"},{"text":"FLOw primitive class definition. This File Depends On sourcefile~~flow_primitive_object.f90~~EfferentGraph sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_field_objects.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_objects.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_field_objects.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflow_primitive_objectf90EfferentGraph = svgPanZoom('#sourcefileflow_primitive_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flow_primitive_object.f90~~AfferentGraph sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_test_primitive_eq.f90 flow_test_primitive_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_eq.f90 sourcefile~flow_test_primitive_pow.f90 flow_test_primitive_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_pow.f90 sourcefile~flow_test_primitive_mul.f90 flow_test_primitive_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_mul.f90 sourcefile~flow_test_primitive_not_eq.f90 flow_test_primitive_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_not_eq.f90 sourcefile~flow_test_primitive_div.f90 flow_test_primitive_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_div.f90 sourcefile~flow_test_primitive_add.f90 flow_test_primitive_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_add.f90 sourcefile~flow_test_primitive_assign.f90 flow_test_primitive_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_assign.f90 sourcefile~flow_test_primitive_sub.f90 flow_test_primitive_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_sub.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flow_primitive_object Source Code flow_primitive_object.f90 Source Code !< FLOw **primitive** class definition. module flow_primitive_object !< FLOw **primitive** class definition. !< !< **primitive** is a class that handles primitive fluid dynamic variables. !< @note The operators of assignment (=), multiplication (*), division (/), sum (+) and subtraction (-) have been overloaded. !< Therefore this module provides a far-complete algebra. use flow_field_objects use penf implicit none private public :: primitive_object type :: primitive_object !< FLOw **primitive** class definition. type ( field_object_scalar ) :: density !< Density field. type ( field_object_vectorial ) :: velocity !< Velocity field. type ( field_object_scalar ) :: pressure !< Pressure field. type ( field_object_scalar ), allocatable :: partial_densities (:) !< Partial densities fields. contains ! public operators generic :: assignment ( = ) => assign_primitive , assign_real !< Assignment overloading. generic :: operator ( + ) => add !< Operator `+` overloading. generic :: operator ( / ) => div , div_integer , div_real !< Operator `/` overloading. generic :: operator ( * ) => mul , mul_integer , integer_mul , mul_real , real_mul !< Operator `*` overloading. generic :: operator ( - ) => sub !< Operator `-` overloading. generic :: operator ( == ) => eq !< Operator `==` overloading. generic :: operator ( /= ) => not_eq !< Operator `/=` overloading. generic :: operator (. compatible .) => compatible !< Operator `.compatible.` overloading. ! private methods procedure , pass ( lhs ), private :: assign_primitive !< Assign primitives. procedure , pass ( lhs ), private :: assign_real !< Assign real to primitive. procedure , pass ( lhs ), private :: add !< Add primitives. procedure , pass ( lhs ), private :: div !< Divide primitives. procedure , pass ( lhs ), private :: div_integer !< Divide primitive by integer. procedure , pass ( lhs ), private :: div_real !< Divide primitive by real. procedure , pass ( lhs ), private :: mul !< Multiply primitives. procedure , pass ( lhs ), private :: mul_integer !< Multiply primitive for integer. procedure , pass ( rhs ), private :: integer_mul !< Multiply integer for primitive. procedure , pass ( lhs ), private :: mul_real !< Multiply primitive for real. procedure , pass ( rhs ), private :: real_mul !< Multiply real for primitive. procedure , pass ( lhs ), private :: sub !< Subtract primitives. procedure , pass ( lhs ), private :: eq !< Compare (`==') primitives. procedure , pass ( lhs ), private :: not_eq !< Compare (`/=') primitives. procedure , pass ( lhs ), private :: compatible !< Compare (`.compatible.`) primitives. endtype primitive_object contains ! private methods pure subroutine assign_primitive ( lhs , rhs ) !< Assign primitives. class ( primitive_object ), intent ( inout ) :: lhs !< Left hand side. type ( primitive_object ), intent ( in ) :: rhs !< Right hand side. lhs % density = rhs % density lhs % velocity = rhs % velocity lhs % pressure = rhs % pressure if ( allocated ( rhs % partial_densities )) lhs % partial_densities = rhs % partial_densities endsubroutine assign_primitive pure subroutine assign_real ( lhs , rhs ) !< Assign real to primitive. class ( primitive_object ), intent ( inout ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. integer ( I_P ) :: d !< Counter. lhs % density = rhs lhs % velocity = rhs lhs % pressure = rhs if ( allocated ( lhs % partial_densities )) then do d = 1 , size ( lhs % partial_densities , dim = 1 ) lhs % partial_densities ( d ) = rhs enddo endif endsubroutine assign_real elemental function add ( lhs , rhs ) result ( opr ) !< Add primitives. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. type ( primitive_object ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs % density + rhs % density opr % velocity = lhs % velocity + rhs % velocity opr % pressure = lhs % pressure + rhs % pressure if ( lhs . compatible . rhs ) then allocate ( opr % partial_densities ( 1 : size ( lhs % partial_densities , dim = 1 ))) do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs % partial_densities ( d ) + rhs % partial_densities ( d ) enddo endif endfunction add elemental function div ( lhs , rhs ) result ( opr ) !< Divide primitives. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. type ( primitive_object ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs % density / rhs % density opr % velocity = lhs % velocity / rhs % velocity opr % pressure = lhs % pressure / rhs % pressure if ( lhs . compatible . rhs ) then allocate ( opr % partial_densities ( 1 : size ( lhs % partial_densities , dim = 1 ))) do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs % partial_densities ( d ) / rhs % partial_densities ( d ) enddo endif endfunction div elemental function div_integer ( lhs , rhs ) result ( opr ) !< Divide primitive by integer. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs % density / rhs opr % velocity = lhs % velocity / rhs opr % pressure = lhs % pressure / rhs if ( allocated ( lhs % partial_densities )) then allocate ( opr % partial_densities ( 1 : size ( lhs % partial_densities , dim = 1 ))) do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs % partial_densities ( d ) / rhs enddo endif endfunction div_integer elemental function div_real ( lhs , rhs ) result ( opr ) !< Divide primitive by real. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs % density / rhs opr % velocity = lhs % velocity / rhs opr % pressure = lhs % pressure / rhs if ( allocated ( lhs % partial_densities )) then allocate ( opr % partial_densities ( 1 : size ( lhs % partial_densities , dim = 1 ))) do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs % partial_densities ( d ) / rhs enddo endif endfunction div_real elemental function mul ( lhs , rhs ) result ( opr ) !< Multiply primitives. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. type ( primitive_object ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs % density * rhs % density opr % velocity = lhs % velocity * rhs % velocity opr % pressure = lhs % pressure * rhs % pressure if ( lhs . compatible . rhs ) then allocate ( opr % partial_densities ( 1 : size ( lhs % partial_densities , dim = 1 ))) do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs % partial_densities ( d ) * rhs % partial_densities ( d ) enddo endif endfunction mul elemental function mul_integer ( lhs , rhs ) result ( opr ) !< Multiply primitive for integer. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs % density * rhs opr % velocity = lhs % velocity * rhs opr % pressure = lhs % pressure * rhs if ( allocated ( lhs % partial_densities )) then allocate ( opr % partial_densities ( 1 : size ( lhs % partial_densities , dim = 1 ))) do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs % partial_densities ( d ) * rhs enddo endif endfunction mul_integer elemental function integer_mul ( lhs , rhs ) result ( opr ) !< Multiply integer for primitive. integer ( I_P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs * rhs % density opr % velocity = lhs * rhs % velocity opr % pressure = lhs * rhs % pressure if ( allocated ( rhs % partial_densities )) then allocate ( opr % partial_densities ( 1 : size ( rhs % partial_densities , dim = 1 ))) do d = 1 , size ( rhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs * rhs % partial_densities ( d ) enddo endif endfunction integer_mul elemental function mul_real ( lhs , rhs ) result ( opr ) !< Multiply primitive for real. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs % density * rhs opr % velocity = lhs % velocity * rhs opr % pressure = lhs % pressure * rhs if ( allocated ( lhs % partial_densities )) then allocate ( opr % partial_densities ( 1 : size ( lhs % partial_densities , dim = 1 ))) do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs % partial_densities ( d ) * rhs enddo endif endfunction mul_real elemental function real_mul ( lhs , rhs ) result ( opr ) !< Multiply real for primitive. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs * rhs % density opr % velocity = lhs * rhs % velocity opr % pressure = lhs * rhs % pressure if ( allocated ( rhs % partial_densities )) then allocate ( opr % partial_densities ( 1 : size ( rhs % partial_densities , dim = 1 ))) do d = 1 , size ( rhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs * rhs % partial_densities ( d ) enddo endif endfunction real_mul elemental function sub ( lhs , rhs ) result ( opr ) !< Subtract primitives. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. type ( primitive_object ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs % density - rhs % density opr % velocity = lhs % velocity - rhs % velocity opr % pressure = lhs % pressure - rhs % pressure if ( lhs . compatible . rhs ) then allocate ( opr % partial_densities ( 1 : size ( lhs % partial_densities , dim = 1 ))) do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs % partial_densities ( d ) - rhs % partial_densities ( d ) enddo endif endfunction sub pure function eq ( lhs , rhs ) result ( opr ) !< Compare (`==`) primitives. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. type ( primitive_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr = lhs % density == rhs % density if ( opr ) opr = lhs % velocity == rhs % velocity if ( opr ) opr = lhs % pressure == rhs % pressure if ( opr . and . allocated ( lhs % partial_densities ). and . allocated ( rhs % partial_densities )) then if ( opr ) opr = lhs . compatible . rhs if ( opr ) then do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr = lhs % partial_densities ( d ) == rhs % partial_densities ( d ) if (. not . opr ) exit enddo endif elseif ( opr . and . allocated ( lhs % partial_densities ). and .(. not . allocated ( rhs % partial_densities ))) then opr = . false . elseif ( opr . and .(. not . allocated ( lhs % partial_densities )). and . allocated ( rhs % partial_densities )) then opr = . false . endif endfunction eq pure function not_eq ( lhs , rhs ) result ( opr ) !< Compare (`/=`) primitives. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. type ( primitive_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . not .( lhs % eq ( rhs = rhs )) endfunction not_eq pure function compatible ( lhs , rhs ) result ( opr ) !< Check primitives compatibility (size of partial densities). class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. type ( primitive_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = allocated ( lhs % partial_densities ). and . allocated ( rhs % partial_densities ) if ( opr ) opr = size ( lhs % partial_densities , dim = 1 ) == size ( rhs % partial_densities , dim = 1 ) endfunction compatible endmodule flow_primitive_object","tags":"","loc":"sourcefile/flow_primitive_object.f90.html","title":"flow_primitive_object.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_add.f90~~EfferentGraph sourcefile~flow_test_primitive_add.f90 flow_test_primitive_add.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_add.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_objects.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_objects.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_objects.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_field_objects.f90 var pansourcefileflow_test_primitive_addf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_addf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_add Source Code flow_test_primitive_add.f90 Source Code !< FLOw test. program flow_test_primitive_add !< FLOw test. use flow implicit none type ( primitive_object ) :: primitive1 !< A primitive object. type ( primitive_object ) :: primitive2 !< A primitive object. type ( primitive_object ) :: primitive3 !< A primitive object. type ( field_object_scalar ) :: partial_densities ( 2 ) !< A scalar field object. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P partial_densities ( 1 ) = 0.125_R_P / 2 partial_densities ( 2 ) = 0.125_R_P / 2 primitive1 % partial_densities = partial_densities primitive2 % density = 1._R_P primitive2 % velocity = 2._R_P primitive2 % pressure = 1._R_P partial_densities ( 1 ) = 1._R_P / 2 partial_densities ( 2 ) = 1._R_P / 2 primitive2 % partial_densities = partial_densities primitive3 = primitive1 + primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 + primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  + 1   = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 1      + 2   = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 1      + 1   = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 + 0.5 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_add","tags":"","loc":"sourcefile/flow_test_primitive_add.f90.html","title":"flow_test_primitive_add.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_assign.f90~~EfferentGraph sourcefile~flow_test_primitive_assign.f90 flow_test_primitive_assign.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_assign.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_objects.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_objects.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_objects.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_field_objects.f90 var pansourcefileflow_test_primitive_assignf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_assignf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_assign Source Code flow_test_primitive_assign.f90 Source Code !< FLOw test. program flow_test_primitive_assign !< FLOw test. use flow implicit none type ( primitive_object ) :: primitive1 !< A primitive object. type ( primitive_object ) :: primitive2 !< A primitive object. type ( field_object_scalar ) :: partial_densities ( 2 ) !< A scalar field object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . primitive1 = 0.125_R_P test_passed ( 1 ) = ( primitive1 % density % field == 0.125_R_P ). and . & ( primitive1 % velocity % field % x == 0.125_R_P ). and . & ( primitive1 % velocity % field % y == 0.125_R_P ). and . & ( primitive1 % velocity % field % z == 0.125_R_P ). and . & ( primitive1 % pressure % field == 0.125_R_P ) print \"(A,F6.3)\" , 'density   = ' , primitive1 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  = ' , primitive1 % velocity % field print \"(A,F6.3)\" , 'pressure  = ' , primitive1 % pressure % field partial_densities ( 1 ) = 0.125_R_P / 2 partial_densities ( 2 ) = 0.125_R_P / 2 primitive1 % partial_densities = partial_densities primitive2 = primitive1 test_passed ( 2 ) = primitive1 == primitive2 print \"(A)\" , '' print \"(A,F6.3)\" , 'density   = ' , primitive2 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  = ' , primitive2 % velocity % field print \"(A,F6.3)\" , 'pressure  = ' , primitive2 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities = ' , primitive2 % partial_densities ( 1 )% field , primitive2 % partial_densities ( 2 )% field print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_assign","tags":"","loc":"sourcefile/flow_test_primitive_assign.f90.html","title":"flow_test_primitive_assign.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_div.f90~~EfferentGraph sourcefile~flow_test_primitive_div.f90 flow_test_primitive_div.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_div.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_objects.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_objects.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_objects.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_field_objects.f90 var pansourcefileflow_test_primitive_divf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_divf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_div Source Code flow_test_primitive_div.f90 Source Code !< FLOw test. program flow_test_primitive_div !< FLOw test. use flow implicit none type ( primitive_object ) :: primitive1 !< A primitive object. type ( primitive_object ) :: primitive2 !< A primitive object. type ( primitive_object ) :: primitive3 !< A primitive object. type ( field_object_scalar ) :: partial_densities ( 2 ) !< A scalar field object. logical :: test_passed ( 4 ) !< List of passed tests. test_passed = . false . primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P partial_densities ( 1 ) = 0.125_R_P / 2 partial_densities ( 2 ) = 0.125_R_P / 2 primitive1 % partial_densities = partial_densities primitive2 % density = 1._R_P primitive2 % velocity = 2._R_P primitive2 % pressure = 1._R_P partial_densities ( 1 ) = 1._R_P / 2 partial_densities ( 2 ) = 1._R_P / 2 primitive2 % partial_densities = partial_densities primitive3 = primitive1 / primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 / primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  / 1   = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2   = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 1      / 1   = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 / 0.5 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field call print_error ( test = 'primitive3 = primitive1 / primitive2' , is_test_passed = test_passed ( 1 )) primitive3 = primitive1 / 2._R_P test_passed ( 2 ) = primitive3 == ( primitive1 / 2._R_P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  / 2.0 = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2.0 = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 1      / 2.0 = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 / 2.0 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field call print_error ( test = 'primitive3 = primitive1 / 2.0' , is_test_passed = test_passed ( 2 )) primitive3 % velocity = primitive2 % velocity / primitive1 % density test_passed ( 3 ) = primitive3 % velocity == ( primitive2 % velocity / 0.125_R_P ) print \"(A)\" , '' print \"(A,3(F6.3,1X))\" , 'velocity / density => 2 / 0.125 = ' , primitive3 % velocity % field call print_error ( test = 'primitive3%velocity = primitive2%velocity / primitive1%density' , is_test_passed = test_passed ( 3 )) primitive3 = primitive1 / 2_I_P test_passed ( 4 ) = primitive3 == ( primitive1 / 2_I_P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  / 2 = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2 = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 1      / 2 = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 / 2 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field call print_error ( test = 'primitive3 = primitive1 / 2' , is_test_passed = test_passed ( 4 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) contains subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive1 % partial_densities ( 1 )% field , primitive1 % partial_densities ( 2 )% field print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive2 % partial_densities ( 1 )% field , primitive2 % partial_densities ( 2 )% field print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field endif endsubroutine print_error endprogram flow_test_primitive_div","tags":"","loc":"sourcefile/flow_test_primitive_div.f90.html","title":"flow_test_primitive_div.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_eq.f90~~EfferentGraph sourcefile~flow_test_primitive_eq.f90 flow_test_primitive_eq.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_eq.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_objects.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_objects.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_objects.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_field_objects.f90 var pansourcefileflow_test_primitive_eqf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_eqf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_eq Source Code flow_test_primitive_eq.f90 Source Code !< FLOw test. program flow_test_primitive_eq !< FLOw test. use flow implicit none type ( primitive_object ) :: primitive1 !< A primitive object. type ( primitive_object ) :: primitive2 !< A primitive object. type ( field_object_scalar ) :: partial_densities ( 2 ) !< A scalar field object. logical :: test_passed ( 8 ) !< List of passed tests. test_passed = . false . primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P test_passed ( 1 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 1 ) primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 0.125_R_P primitive2 % velocity = 2._R_P primitive2 % pressure = 1._R_P test_passed ( 2 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'velocity => 1 /= 2     = ' , test_passed ( 2 ) primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 0.125_R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 2._R_P test_passed ( 3 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'pressure => 1 /= 2     = ' , test_passed ( 3 ) primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 1._R_P primitive2 % velocity = 2._R_P primitive2 % pressure = 2._R_P test_passed ( 4 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'velocity => 1 /= 2     = ' , test_passed ( 4 ) print \"(A,L1)\" , 'pressure => 1 /= 2     = ' , test_passed ( 4 ) primitive1 % density = 1._R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P test_passed ( 5 ) = ( primitive1 == primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true' print \"(A,L1)\" , 'density  => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'velocity => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'pressure => 1 == 1 = ' , test_passed ( 5 ) primitive1 % density = 1._R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P partial_densities ( 1 ) = 0.5_R_P partial_densities ( 2 ) = 0.5_R_P primitive1 % partial_densities = partial_densities primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P test_passed ( 6 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'velocity  => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'pressure  => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'densities => 0.5 /= null = ' , test_passed ( 6 ) primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P partial_densities ( 1 ) = 0.1_R_P partial_densities ( 2 ) = 0.5_R_P primitive2 % partial_densities = partial_densities test_passed ( 7 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'velocity  => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'pressure  => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'densities => 0.5 /= 0.1 = ' , test_passed ( 7 ) primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P partial_densities ( 1 ) = 0.5_R_P partial_densities ( 2 ) = 0.5_R_P primitive2 % partial_densities = partial_densities test_passed ( 8 ) = ( primitive1 == primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'velocity  => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'pressure  => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'densities => 0.5 == 0.5 = ' , test_passed ( 8 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_eq","tags":"","loc":"sourcefile/flow_test_primitive_eq.f90.html","title":"flow_test_primitive_eq.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_mul.f90~~EfferentGraph sourcefile~flow_test_primitive_mul.f90 flow_test_primitive_mul.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_mul.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_objects.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_objects.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_objects.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_field_objects.f90 var pansourcefileflow_test_primitive_mulf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_mulf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_mul Source Code flow_test_primitive_mul.f90 Source Code !< FLOw test. program flow_test_primitive_mul !< FLOw test. use flow implicit none type ( primitive_object ) :: primitive1 !< A primitive object. type ( primitive_object ) :: primitive2 !< A primitive object. type ( primitive_object ) :: primitive3 !< A primitive object. type ( field_object_scalar ) :: partial_densities ( 2 ) !< A scalar field object. logical :: test_passed ( 7 ) !< List of passed tests. test_passed = . false . primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P partial_densities ( 1 ) = 0.125_R_P / 2 partial_densities ( 2 ) = 0.125_R_P / 2 primitive1 % partial_densities = partial_densities primitive2 % density = 1._R_P primitive2 % velocity = 2._R_P primitive2 % pressure = 1._R_P partial_densities ( 1 ) = 1._R_P / 2 partial_densities ( 2 ) = 1._R_P / 2 primitive2 % partial_densities = partial_densities primitive3 = primitive1 * primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 * primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  * 1 = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2 = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 1      * 1 = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 * 0.5 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field call print_error ( test = 'primitive3 = primitive1 * primitive2' , is_test_passed = test_passed ( 1 )) primitive3 = 2._R_P * primitive1 test_passed ( 2 ) = primitive3 == ( 2._R_P * primitive1 ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 2.0 * 0.125  = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 2.0 * 1      = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 2.0 * 1      = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 2.0 * 0.0625 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field call print_error ( test = 'primitive3 = 2.0 * primitive1' , is_test_passed = test_passed ( 2 )) primitive3 = primitive1 * 2._R_P test_passed ( 3 ) = primitive3 == ( primitive1 * 2._R_P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  * 2.0 = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2.0 = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 1      * 2.0 = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 * 2.0 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field call print_error ( test = 'primitive3 = primitive1 * 2.0' , is_test_passed = test_passed ( 3 )) primitive3 % velocity = primitive1 % density * primitive2 % velocity test_passed ( 4 ) = primitive3 % velocity == ( primitive2 % velocity * 0.125_R_P ) print \"(A)\" , '' print \"(A,3(F6.3,1X))\" , 'density * velocity => 0.125 * 2 = ' , primitive3 % velocity % field call print_error ( test = 'primitive3%velocity = primitive1%density * primitive2%velocity' , is_test_passed = test_passed ( 4 )) primitive3 % velocity = primitive2 % velocity * primitive1 % density test_passed ( 5 ) = primitive3 % velocity == ( primitive2 % velocity * 0.125_R_P ) print \"(A)\" , '' print \"(A,3(F6.3,1X))\" , 'velocity * density => 2 * 0.125 = ' , primitive3 % velocity % field call print_error ( test = 'primitive3%velocity = primitive2%velocity * primitive1%density' , is_test_passed = test_passed ( 5 )) primitive3 = 2_I_P * primitive1 test_passed ( 6 ) = primitive3 == ( 2_I_P * primitive1 ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 2 * 0.125  = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 2 * 1      = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 2 * 1      = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 2 * 0.0625 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field call print_error ( test = 'primitive3 = 2 * primitive1' , is_test_passed = test_passed ( 6 )) primitive3 = primitive1 * 2_I_P test_passed ( 7 ) = primitive3 == ( primitive1 * 2_I_P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  * 2 = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2 = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 1      * 2 = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 * 2 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field call print_error ( test = 'primitive3 = primitive1 * 2' , is_test_passed = test_passed ( 7 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) contains subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive1 % partial_densities ( 1 )% field , primitive1 % partial_densities ( 2 )% field print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive2 % partial_densities ( 1 )% field , primitive2 % partial_densities ( 2 )% field print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field endif endsubroutine print_error endprogram flow_test_primitive_mul","tags":"","loc":"sourcefile/flow_test_primitive_mul.f90.html","title":"flow_test_primitive_mul.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_not_eq.f90~~EfferentGraph sourcefile~flow_test_primitive_not_eq.f90 flow_test_primitive_not_eq.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_not_eq.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_objects.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_objects.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_objects.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_field_objects.f90 var pansourcefileflow_test_primitive_not_eqf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_not_eqf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_not_eq Source Code flow_test_primitive_not_eq.f90 Source Code !< FLOw test. program flow_test_primitive_not_eq !< FLOw test. use flow implicit none type ( primitive_object ) :: primitive1 !< A primitive object. type ( primitive_object ) :: primitive2 !< A primitive object. type ( field_object_scalar ) :: partial_densities ( 2 ) !< A scalar field object. logical :: test_passed ( 8 ) !< List of passed tests. test_passed = . false . primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P test_passed ( 1 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 1 ) primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 0.125_R_P primitive2 % velocity = 2._R_P primitive2 % pressure = 1._R_P test_passed ( 2 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'velocity => 1 /= 2     = ' , test_passed ( 2 ) primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 0.125_R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 2._R_P test_passed ( 3 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'pressure => 1 /= 2     = ' , test_passed ( 3 ) primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 1._R_P primitive2 % velocity = 2._R_P primitive2 % pressure = 2._R_P test_passed ( 4 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'velocity => 1 /= 2     = ' , test_passed ( 4 ) print \"(A,L1)\" , 'pressure => 1 /= 2     = ' , test_passed ( 4 ) primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 0.125_R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P test_passed ( 5 ) = ( primitive1 /= primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'velocity => 1 /= 2     = ' , test_passed ( 5 ) print \"(A,L1)\" , 'pressure => 1 /= 2     = ' , test_passed ( 5 ) primitive1 % density = 1._R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P partial_densities ( 1 ) = 0.5_R_P partial_densities ( 2 ) = 0.5_R_P primitive1 % partial_densities = partial_densities primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P test_passed ( 6 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'velocity  => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'pressure  => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'densities => 0.5 /= null = ' , test_passed ( 6 ) primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P partial_densities ( 1 ) = 0.1_R_P partial_densities ( 2 ) = 0.5_R_P primitive2 % partial_densities = partial_densities test_passed ( 7 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'velocity  => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'pressure  => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'densities => 0.5 /= 0.1 = ' , test_passed ( 7 ) primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P partial_densities ( 1 ) = 0.5_R_P partial_densities ( 2 ) = 0.5_R_P primitive2 % partial_densities = partial_densities test_passed ( 8 ) = ( primitive1 /= primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'velocity  => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'pressure  => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'densities => 0.5 == 0.5 = ' , test_passed ( 8 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_not_eq","tags":"","loc":"sourcefile/flow_test_primitive_not_eq.f90.html","title":"flow_test_primitive_not_eq.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_pow.f90~~EfferentGraph sourcefile~flow_test_primitive_pow.f90 flow_test_primitive_pow.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_pow.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_objects.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_objects.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_objects.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_field_objects.f90 var pansourcefileflow_test_primitive_powf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_powf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_add Source Code flow_test_primitive_pow.f90 Source Code !< FLOw test. program flow_test_primitive_add !< FLOw test. use flow implicit none type ( primitive_object ) :: primitive1 !< A primitive object. type ( primitive_object ) :: primitive2 !< A primitive object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . primitive1 % density = 0.125_R_P ; primitive1 % velocity = 1._R_P ; primitive1 % pressure = 1._R_P primitive2 % density = primitive1 % density ** 2_I_P primitive2 % velocity = primitive1 % velocity ** 2_I_P primitive2 % pressure = primitive1 % pressure ** 2_I_P print \"(A,F6.3)\" , 'density  => 0.125 ** 2 = ' , primitive2 % density % field print \"(A,3(F6.3,1X))\" , 'velocity => 1     ** 2 = ' , primitive2 % velocity % field print \"(A,F6.3)\" , 'pressure => 1     ** 2 = ' , primitive2 % pressure % field test_passed ( 1 ) = primitive2 % density % field == ( 0.125_R_P ** 2_I_P ) primitive2 % density = primitive1 % density ** 2._R_P primitive2 % velocity = primitive1 % velocity ** 2._R_P primitive2 % pressure = primitive1 % pressure ** 2._R_P print \"(A)\" , '' print \"(A,F6.3)\" , 'density  => 0.125 ** 2.0 = ' , primitive2 % density % field print \"(A,3(F6.3,1X))\" , 'velocity => 1     ** 2.0 = ' , primitive2 % velocity % field print \"(A,F6.3)\" , 'pressure => 1     ** 2.0 = ' , primitive2 % pressure % field test_passed ( 2 ) = primitive2 % density % field == ( 0.125_R_P ** 2._R_P ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_add","tags":"","loc":"sourcefile/flow_test_primitive_pow.f90.html","title":"flow_test_primitive_pow.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_sub.f90~~EfferentGraph sourcefile~flow_test_primitive_sub.f90 flow_test_primitive_sub.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_sub.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_objects.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_objects.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_objects.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_field_objects.f90 var pansourcefileflow_test_primitive_subf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_subf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_sub Source Code flow_test_primitive_sub.f90 Source Code !< FLOw test. program flow_test_primitive_sub !< FLOw test. use flow implicit none type ( primitive_object ) :: primitive1 !< A primitive object. type ( primitive_object ) :: primitive2 !< A primitive object. type ( primitive_object ) :: primitive3 !< A primitive object. type ( field_object_scalar ) :: partial_densities ( 2 ) !< A scalar field object. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P partial_densities ( 1 ) = 0.125_R_P / 2 partial_densities ( 2 ) = 0.125_R_P / 2 primitive1 % partial_densities = partial_densities primitive2 % density = 1._R_P primitive2 % velocity = 2._R_P primitive2 % pressure = 1._R_P partial_densities ( 1 ) = 1._R_P / 2 partial_densities ( 2 ) = 1._R_P / 2 primitive2 % partial_densities = partial_densities primitive3 = primitive1 - primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 - primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  - 1   = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 1      - 2   = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 1      - 1   = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 - 0.5 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_sub","tags":"","loc":"sourcefile/flow_test_primitive_sub.f90.html","title":"flow_test_primitive_sub.f90 – FLOw"},{"text":"Portability Environment for Fortran poor people. This File Depends On sourcefile~~penf.f90~~EfferentGraph sourcefile~penf.f90 penf.F90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~penf.f90~~AfferentGraph sourcefile~penf.f90 penf.F90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow.f90 flow.f90 sourcefile~penf.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~penf.f90->sourcefile~flow_field_objects.f90 sourcefile~compact_real.f90 compact_real.f90 sourcefile~penf.f90->sourcefile~compact_real.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~test_all.f90 test_all.F90 sourcefile~penf.f90->sourcefile~test_all.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_test_primitive_eq.f90 flow_test_primitive_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_eq.f90 sourcefile~flow_test_primitive_pow.f90 flow_test_primitive_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_pow.f90 sourcefile~flow_test_primitive_mul.f90 flow_test_primitive_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_mul.f90 sourcefile~flow_test_primitive_not_eq.f90 flow_test_primitive_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_not_eq.f90 sourcefile~flow_test_primitive_div.f90 flow_test_primitive_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_div.f90 sourcefile~flow_test_primitive_add.f90 flow_test_primitive_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_add.f90 sourcefile~flow_test_primitive_assign.f90 flow_test_primitive_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_assign.f90 sourcefile~flow_test_primitive_sub.f90 flow_test_primitive_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_sub.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_objects.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_objects.f90 var pansourcefilepenff90AfferentGraph = svgPanZoom('#sourcefilepenff90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf Source Code penf.F90 Source Code !< Portability Environment for Fortran poor people. module penf !----------------------------------------------------------------------------------------------------------------------------------- !< Portability Environment for Fortran poor people. !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables #ifdef __GFORTRAN__ use penf_b_size , only : bit_size , byte_size #else use penf_b_size #endif use penf_stringify , only : str , strz , cton , bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save ! Global parameters and variables public :: endianL , endianB , endian , is_initialized public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , BIR16P , BYR16P , smallR16P , ZeroR16 public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , BIR8P , BYR8P , smallR8P , ZeroR8 public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , BIR4P , BYR4P , smallR4P , ZeroR4 public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , BIR_P , BYR_P , smallR_P , Zero public :: I8P , FI8P , DI8P , MinI8P , MaxI8P , BII8P , BYI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P , BII4P , BYI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P , BII2P , BYI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P , BII1P , BYI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P , BII_P , BYI_P public :: REAL_KINDS_LIST , REAL_FORMATS_LIST public :: INTEGER_KINDS_LIST , INTEGER_FORMATS_LIST ! Bit/byte size functions public :: bit_size , byte_size ! Stringify facility public :: str , strz , cton public :: bstr , bcton ! Miscellanea facility public :: check_endian public :: digit public :: penf_Init public :: penf_print !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef __GFORTRAN__ ! work-around for strange gfortran bug... interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. endinterface #endif !----------------------------------------------------------------------------------------------------------------------------------- interface digit !< Compute the number of digits in decimal base of the input integer. module procedure digit_I8 , digit_I4 , digit_I2 , digit_I1 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8 elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4 elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2 elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1 subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print endmodule penf","tags":"","loc":"sourcefile/penf.f90.html","title":"penf.F90 – FLOw"},{"text":"This File Depends On sourcefile~~penf_b_size.f90~~EfferentGraph sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~penf_b_size.f90~~AfferentGraph sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow.f90 flow.f90 sourcefile~penf.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~penf.f90->sourcefile~flow_field_objects.f90 sourcefile~compact_real.f90 compact_real.f90 sourcefile~penf.f90->sourcefile~compact_real.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~test_all.f90 test_all.F90 sourcefile~penf.f90->sourcefile~test_all.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_test_primitive_eq.f90 flow_test_primitive_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_eq.f90 sourcefile~flow_test_primitive_pow.f90 flow_test_primitive_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_pow.f90 sourcefile~flow_test_primitive_mul.f90 flow_test_primitive_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_mul.f90 sourcefile~flow_test_primitive_not_eq.f90 flow_test_primitive_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_not_eq.f90 sourcefile~flow_test_primitive_div.f90 flow_test_primitive_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_div.f90 sourcefile~flow_test_primitive_add.f90 flow_test_primitive_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_add.f90 sourcefile~flow_test_primitive_assign.f90 flow_test_primitive_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_assign.f90 sourcefile~flow_test_primitive_sub.f90 flow_test_primitive_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_sub.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_objects.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_objects.f90 var pansourcefilepenf_b_sizef90AfferentGraph = svgPanZoom('#sourcefilepenf_b_sizef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf_b_size Source Code penf_b_size.F90 Source Code module penf_b_size !----------------------------------------------------------------------------------------------------------------------------------- !< PENF bit/byte size functions. !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: bit_size , byte_size !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. module procedure & #ifdef r16p bit_size_R16P , & #endif bit_size_R8P , & bit_size_R4P , & bit_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface byte_size !< Compute the number of bytes of a variable. module procedure & byte_size_I8P , & byte_size_I4P , & byte_size_I2P , & byte_size_I1P , & #ifdef r16p byte_size_R16p , & #endif byte_size_R8P , & byte_size_R4P , & byte_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr endmodule penf_b_size","tags":"","loc":"sourcefile/penf_b_size.f90.html","title":"penf_b_size.F90 – FLOw"},{"text":"Files Dependent On This One sourcefile~~penf_global_parameters_variables.f90~~AfferentGraph sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow.f90 flow.f90 sourcefile~penf.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~penf.f90->sourcefile~flow_field_objects.f90 sourcefile~compact_real.f90 compact_real.f90 sourcefile~penf.f90->sourcefile~compact_real.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~test_all.f90 test_all.F90 sourcefile~penf.f90->sourcefile~test_all.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_test_primitive_eq.f90 flow_test_primitive_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_eq.f90 sourcefile~flow_test_primitive_pow.f90 flow_test_primitive_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_pow.f90 sourcefile~flow_test_primitive_mul.f90 flow_test_primitive_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_mul.f90 sourcefile~flow_test_primitive_not_eq.f90 flow_test_primitive_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_not_eq.f90 sourcefile~flow_test_primitive_div.f90 flow_test_primitive_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_div.f90 sourcefile~flow_test_primitive_add.f90 flow_test_primitive_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_add.f90 sourcefile~flow_test_primitive_assign.f90 flow_test_primitive_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_assign.f90 sourcefile~flow_test_primitive_sub.f90 flow_test_primitive_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_sub.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_objects.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_objects.f90 var pansourcefilepenf_global_parameters_variablesf90AfferentGraph = svgPanZoom('#sourcefilepenf_global_parameters_variablesf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf_global_parameters_variables Source Code penf_global_parameters_variables.F90 Source Code module penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !< PENF global (exposed) parameters and variables. !< !< @note All module defined entities are public. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none public save !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: is_initialized = . false . !< Check the initialization of some variables that must be initialized. integer , parameter :: endianL = 1 !< Little endian parameter. integer , parameter :: endianB = 0 !< Big endian parameter. integer :: endian = endianL !< Bit ordering: Little endian (endianL), or Big endian (endianB). !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Portable kind parameters #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33 digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Format parameters #ifdef r16p character ( * ), parameter :: FR16P = '(E42.33E4)' !< Output format for kind=R16P real. #else character ( * ), parameter :: FR16P = '(E23.15E3)' !< Output format for kind=R16P real. #endif character ( * ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P real. character ( * ), parameter :: FR4P = '(E13.6E2)' !< Output format for kind=R4P real. character ( * ), parameter :: FR_P = FR8P !< Output format for kind=R_P real. character ( * ), parameter :: FI8P = '(I20)' !< Output format for kind=I8P integer. character ( * ), parameter :: FI8PZP = '(I20.19)' !< Output format for kind=I8P integer with zero prefixing. character ( * ), parameter :: FI4P = '(I11)' !< Output format for kind=I4P integer. character ( * ), parameter :: FI4PZP = '(I11.10)' !< Output format for kind=I4P integer with zero prefixing. character ( * ), parameter :: FI2P = '(I6)' !< Output format for kind=I2P integer. character ( * ), parameter :: FI2PZP = '(I6.5)' !< Output format for kind=I2P integer with zero prefixing. character ( * ), parameter :: FI1P = '(I4)' !< Output format for kind=I1P integer. character ( * ), parameter :: FI1PZP = '(I4.3)' !< Output format for kind=I1P integer with zero prefixing. character ( * ), parameter :: FI_P = FI4P !< Output format for kind=I_P integer. character ( * ), parameter :: FI_PZP = FI4PZP !< Output format for kind=I_P integer with zero prefixing. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Length (number of digits) of formatted numbers #ifdef r16p integer , parameter :: DR16P = 42 !< Number of digits of output format FR16P. #else integer , parameter :: DR16P = 23 !< Number of digits of output format FR16P. #endif integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. integer , parameter :: DR4P = 13 !< Number of digits of output format FR4P. integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. integer , parameter :: DI8P = 20 !< Number of digits of output format I8P. integer , parameter :: DI4P = 11 !< Number of digits of output format I4P. integer , parameter :: DI2P = 6 !< Number of digits of output format I2P. integer , parameter :: DI1P = 4 !< Number of digits of output format I1P. integer , parameter :: DI_P = DI4P !< Number of digits of output format I_P. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! List of kinds integer , parameter :: REAL_KINDS_LIST ( 1 : 4 ) = [ R16P , R8P , R4P , R_P ] !< List of real kinds. character ( * ), parameter :: REAL_FORMATS_LIST ( 1 : 4 ) = [ FR16P , FR8P , FR4P // ' ' , FR_P ] !< List of real formats. integer , parameter :: INTEGER_KINDS_LIST ( 1 : 5 ) = [ I8P , I4P , I2P , I1P , I_P ] !< List of integer kinds. character ( * ), parameter :: INTEGER_FORMATS_LIST ( 1 : 5 ) = [ FI8P , FI4P , FI2P // ' ' , FI1P // ' ' , FI_P ] !< List of integer formats. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Minimum and maximum (representable) values real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ) !< Minimum value of kind=R16P real. real ( R16P ), parameter :: MaxR16P = huge ( 1._R16P ) !< Maximum value of kind=R16P real. real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ) !< Minimum value of kind=R8P real. real ( R8P ), parameter :: MaxR8P = huge ( 1._R8P ) !< Maximum value of kind=R8P real. real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ) !< Minimum value of kind=R4P real. real ( R4P ), parameter :: MaxR4P = huge ( 1._R4P ) !< Maximum value of kind=R4P real. real ( R_P ), parameter :: MinR_P = MinR8P !< Minimum value of kind=R_P real. real ( R_P ), parameter :: MaxR_P = MaxR8P !< Maximum value of kind=R_P real. integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) !< Minimum value of kind=I8P integer. integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) !< Minimum value of kind=I4P integer. integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) !< Minimum value of kind=I2P integer. integer ( I1P ), parameter :: MinI1P = - huge ( 1_I1P ) !< Minimum value of kind=I1P integer. integer ( I_P ), parameter :: MinI_P = MinI4P !< Minimum value of kind=I_P integer. integer ( I8P ), parameter :: MaxI8P = huge ( 1_I8P ) !< Maximum value of kind=I8P integer. integer ( I4P ), parameter :: MaxI4P = huge ( 1_I4P ) !< Maximum value of kind=I4P integer. integer ( I2P ), parameter :: MaxI2P = huge ( 1_I2P ) !< Maximum value of kind=I2P integer. integer ( I1P ), parameter :: MaxI1P = huge ( 1_I1P ) !< Maximum value of kind=I1P integer. integer ( I_P ), parameter :: MaxI_P = MaxI4P !< Maximum value of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Real smallest (representable) values real ( R16P ), parameter :: smallR16P = tiny ( 1._R16P ) !< Smallest representable value of kind=R16P real. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest representable value of kind=R8P real. real ( R4P ), parameter :: smallR4P = tiny ( 1._R4P ) !< Smallest representable value of kind=R4P real. real ( R_P ), parameter :: smallR_P = smallR8P !< Smallest representable value of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Smallest real representable difference by the running calculator real ( R16P ), parameter :: ZeroR16 = nearest ( 1._R16P , 1._R16P ) - & nearest ( 1._R16P , - 1._R16P ) !< Smallest representable difference of kind=R16P real. real ( R8P ), parameter :: ZeroR8 = nearest ( 1._R8P , 1._R8P ) - & nearest ( 1._R8P , - 1._R8P ) !< Smallest representable difference of kind=R8P real. real ( R4P ), parameter :: ZeroR4 = nearest ( 1._R4P , 1._R4P ) - & nearest ( 1._R4P , - 1._R4P ) !< Smallest representable difference of kind=R4P real. real ( R_P ), parameter :: Zero = ZeroR8 !< Smallest representable difference of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Bits/bytes memory requirements (real variables must be computed at runtime) integer ( I2P ) :: BIR16P !< Number of bits of kind=R16P real. integer ( I1P ) :: BIR8P !< Number of bits of kind=R8P real. integer ( I1P ) :: BIR4P !< Number of bits of kind=R4P real. integer ( I1P ) :: BIR_P !< Number of bits of kind=R_P real. integer ( I2P ) :: BYR16P !< Number of bytes of kind=R16P real. integer ( I1P ) :: BYR8P !< Number of bytes of kind=R8P real. integer ( I1P ) :: BYR4P !< Number of bytes of kind=R4P real. integer ( I1P ) :: BYR_P !< Number of bytes of kind=R_P real. integer ( I8P ), parameter :: BII8P = bit_size ( MaxI8P ) !< Number of bits of kind=I8P integer. integer ( I4P ), parameter :: BII4P = bit_size ( MaxI4P ) !< Number of bits of kind=I4P integer. integer ( I2P ), parameter :: BII2P = bit_size ( MaxI2P ) !< Number of bits of kind=I2P integer. integer ( I1P ), parameter :: BII1P = bit_size ( MaxI1P ) !< Number of bits of kind=I1P integer. integer ( I_P ), parameter :: BII_P = bit_size ( MaxI_P ) !< Number of bits of kind=I_P integer. integer ( I8P ), parameter :: BYI8P = bit_size ( MaxI8P ) / 8_I8P !< Number of bytes of kind=I8P integer. integer ( I4P ), parameter :: BYI4P = bit_size ( MaxI4P ) / 8_I4P !< Number of bytes of kind=I4P integer. integer ( I2P ), parameter :: BYI2P = bit_size ( MaxI2P ) / 8_I2P !< Number of bytes of kind=I2P integer. integer ( I1P ), parameter :: BYI1P = bit_size ( MaxI1P ) / 8_I1P !< Number of bytes of kind=I1P integer. integer ( I_P ), parameter :: BYI_P = bit_size ( MaxI_P ) / 8_I_P !< Number of bytes of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- endmodule penf_global_parameters_variables","tags":"","loc":"sourcefile/penf_global_parameters_variables.f90.html","title":"penf_global_parameters_variables.F90 – FLOw"},{"text":"This File Depends On sourcefile~~penf_stringify.f90~~EfferentGraph sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~penf_stringify.f90~~AfferentGraph sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow.f90 flow.f90 sourcefile~penf.f90->sourcefile~flow.f90 sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~penf.f90->sourcefile~flow_field_objects.f90 sourcefile~compact_real.f90 compact_real.f90 sourcefile~penf.f90->sourcefile~compact_real.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~test_all.f90 test_all.F90 sourcefile~penf.f90->sourcefile~test_all.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_test_primitive_eq.f90 flow_test_primitive_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_eq.f90 sourcefile~flow_test_primitive_pow.f90 flow_test_primitive_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_pow.f90 sourcefile~flow_test_primitive_mul.f90 flow_test_primitive_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_mul.f90 sourcefile~flow_test_primitive_not_eq.f90 flow_test_primitive_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_not_eq.f90 sourcefile~flow_test_primitive_div.f90 flow_test_primitive_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_div.f90 sourcefile~flow_test_primitive_add.f90 flow_test_primitive_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_add.f90 sourcefile~flow_test_primitive_assign.f90 flow_test_primitive_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_assign.f90 sourcefile~flow_test_primitive_sub.f90 flow_test_primitive_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_sub.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_objects.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_objects.f90 var pansourcefilepenf_stringifyf90AfferentGraph = svgPanZoom('#sourcefilepenf_stringifyf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf_stringify Source Code penf_stringify.F90 Source Code module penf_stringify !----------------------------------------------------------------------------------------------------------------------------------- !< PENF string-to-number (and viceversa) facility. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: ISO_FORTRAN_ENV , only : stderr => ERROR_UNIT use penf_b_size use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: str , strz , cton public :: bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface str !< Convert number (real and integer) to string (number to string type casting). module procedure & #ifdef r16p strf_R16P , str_R16P , & #endif strf_R8P , str_R8P , & strf_R4P , str_R4P , & strf_I8P , str_I8P , & strf_I4P , str_I4P , & strf_I2P , str_I2P , & strf_I1P , str_I1P , & str_bol , & #ifdef r16p str_a_R16P , & #endif str_a_R8P , & str_a_R4P , & str_a_I8P , & str_a_I4P , & str_a_I2P , & str_a_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface strz !< Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). module procedure strz_I8P , strz_I4P , strz_I2P , strz_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface cton !< Convert string to number (real and integer, string to number type casting). module procedure & #ifdef r16p ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bstr !< Convert number (real and integer) to bit-string (number to bit-string type casting). module procedure & #ifdef r16p bstr_R16P , & #endif bstr_R8P , & bstr_R4P , & bstr_I8P , & bstr_I4P , & bstr_I2P , & bstr_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bcton !< Convert bit-string to number (real and integer, bit-string to number type casting). module procedure & #ifdef r16p bctor_R16P , & #endif bctor_R8P , & bctor_R4P , & bctoi_I8P , & bctoi_I4P , & bctoi_I2P , & bctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P elemental function str_R16P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P elemental function str_R8P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P elemental function str_R4P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol pure function str_a_R16P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator ( 1 ) !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator ( 1 ) do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P pure function str_a_R8P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P pure function str_a_R4P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P pure function str_a_I8P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P pure function str_a_I4P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P pure function str_a_I2P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P pure function str_a_I1P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P pure subroutine compact_real_string ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< author: Izaak Beekman !< date: 02/24/2015 !< !< Compact a string representing a real number, so that the same value is displayed with fewer characters. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( inout ) :: string !< string representation of a real number. character ( len = len ( string )) :: significand !< Significand characters. character ( len = len ( string )) :: expnt !< Exponent characters. character ( len = 2 ) :: separator !< Separator characters. integer ( I4P ) :: exp_start !< Start position of exponent. integer ( I4P ) :: decimal_pos !< Decimal positions. integer ( I4P ) :: sig_trim !< Signature trim. integer ( I4P ) :: exp_trim !< Exponent trim. integer ( I4P ) :: i !< counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- string = adjustl ( string ) exp_start = scan ( string , 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( string , '-+' , back = . true .) decimal_pos = scan ( string , '.' ) if ( exp_start /= 0 ) separator = string ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then ! possibly signed, exponent-less float significand = string sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s, but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo string = trim ( significand ( 1 : sig_trim )) elseif ( exp_start > decimal_pos ) then ! float has exponent significand = string ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo expnt = adjustl ( string ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( string ( exp_start + 1 :)) endif exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) ! look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit endif enddo string = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable endif !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine compact_real_string elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P endmodule penf_stringify","tags":"","loc":"sourcefile/penf_stringify.f90.html","title":"penf_stringify.F90 – FLOw"},{"text":"PENF's testing program. This File Depends On sourcefile~~compact_real.f90~~EfferentGraph sourcefile~compact_real.f90 compact_real.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~compact_real.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefilecompact_realf90EfferentGraph = svgPanZoom('#sourcefilecompact_realf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs compact_real Source Code compact_real.f90 Source Code !< PENF's testing program. program compact_real !----------------------------------------------------------------------------------------------------------------------------------- !< PENF's testing program. !----------------------------------------------------------------------------------------------------------------------------------- use penf use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call penf_init test_passed = . false . test_passed ( 1 ) = trim ( str ( n = 1._R8P , compact = . true .)) == '+0.1E+1' print \"(A,L1)\" , 'Compact 1.0: ' // trim ( str ( n = 1._R8P , compact = . true .)) // ', is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = trim ( str ( n = 1._R4P / 3._R4P , compact = . true .)) == '+0.333333E+0' print \"(A,L1)\" , 'Compact 1.0/3.0: ' // trim ( str ( n = 1._R4P / 3._R4P , compact = . true .)) // ', is correct? ' , test_passed ( 2 ) test_passed ( 3 ) = trim ( str ( n = 1._R16P / 4._R16P , compact = . true .)) == '+0.25E+0' print \"(A,L1)\" , 'Compact 1.0/4.0: ' // trim ( str ( n = 1._R16P / 4._R16P , compact = . true .)) // ', is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram compact_real","tags":"","loc":"sourcefile/compact_real.f90.html","title":"compact_real.f90 – FLOw"},{"text":"PENF's testing program. This File Depends On sourcefile~~test_all.f90~~EfferentGraph sourcefile~test_all.f90 test_all.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~test_all.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefiletest_allf90EfferentGraph = svgPanZoom('#sourcefiletest_allf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_all Source Code test_all.F90 Source Code !< PENF's testing program. program test_all !----------------------------------------------------------------------------------------------------------------------------------- !< PENF's testing program. !< !<### Usage !<```bash !< ./test_all !<``` !----------------------------------------------------------------------------------------------------------------------------------- use penf use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call penf_init call penf_print ( unit = stdout ) print \"(A)\" , '' print \"(A)\" , 'Testing IR_Precision tools' print \"(A)\" , 'Casting real-to-string: ' // str ( n = 1._R8P ) print \"(A)\" , 'Casting integer-to-string: ' // str ( n = 11_I8P ) print \"(A,\" // FR8P // \")\" , 'Casting string-to-real: ' , cton ( str = '2.2d0' , knd = 1._R8P ) print \"(A,\" // FI4P // \")\" , 'Casting integer-to-string: ' , cton ( str = '43' , knd = 1_I4P ) print \"(A)\" , 'Casting integer-to-string with zero padding: ' // trim ( strz ( nz_pad = 3 , n = 34_I8P )) #ifndef __GFORTRAN__ print \"(A)\" , 'Casting real-to-bit_string: ' // bstr ( n = 1._R4P ) #endif print \"(A)\" , 'Casting integer-to-bit_string: ' // bstr ( n = 1_I4P ) #ifndef __GFORTRAN__ print \"(A,\" // FR4P // \")\" , 'Casting bit_string-to-real: ' , bcton ( bstr = '00111111100000000000000000000000' , knd = 1._R4P ) #endif print \"(A,\" // FI4P // \")\" , 'Casting bit_string-to-integer: ' , bcton ( bstr = '00000000000000000000000000000001' , knd = 1_I4P ) print \"(A)\" , 'Number of digit of 1023: ' // str ( n = digit ( 1023_I4P )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_all","tags":"","loc":"sourcefile/test_all.f90.html","title":"test_all.F90 – FLOw"},{"text":"Module definition of class Vector. Files Dependent On This One sourcefile~~vecfor.f90~~AfferentGraph sourcefile~vecfor.f90 vecfor.F90 sourcefile~kinds.f90 kinds.f90 sourcefile~vecfor.f90->sourcefile~kinds.f90 sourcefile~flow_field_objects.f90 flow_field_objects.f90 sourcefile~vecfor.f90->sourcefile~flow_field_objects.f90 sourcefile~simple.f90 simple.f90 sourcefile~vecfor.f90->sourcefile~simple.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_field_objects.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~flow_field_objects.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_test_primitive_eq.f90 flow_test_primitive_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_eq.f90 sourcefile~flow_test_primitive_pow.f90 flow_test_primitive_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_pow.f90 sourcefile~flow_test_primitive_mul.f90 flow_test_primitive_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_mul.f90 sourcefile~flow_test_primitive_not_eq.f90 flow_test_primitive_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_not_eq.f90 sourcefile~flow_test_primitive_div.f90 flow_test_primitive_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_div.f90 sourcefile~flow_test_primitive_add.f90 flow_test_primitive_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_add.f90 sourcefile~flow_test_primitive_assign.f90 flow_test_primitive_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_assign.f90 sourcefile~flow_test_primitive_sub.f90 flow_test_primitive_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_sub.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 var pansourcefilevecforf90AfferentGraph = svgPanZoom('#sourcefilevecforf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules VecFor Source Code vecfor.F90 Source Code !< Module definition of class Vector. module VecFor !< Module definition of class Vector. !< !< This derived type is useful for manipulating vectors in 3D space. The components of the vectors are reals with !< parametrized kind as defined by the library module. The components are defined in a three-dimensional cartesian frame of !< reference. !< All the vectorial math procedures (cross, dot products, parallel...) assume a three-dimensional cartesian frame of reference. !< The operators of assignment (`=`), multiplication (`*`), division (`/`), sum (`+`) and subtraction (`-`) have been overloaded. !< Furthermore the *dot* and *cross* products have been defined. !< Therefore this module provides a far-complete algebra based on Vector derived type. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: ex , ey , ez public :: sq_norm public :: normL2 public :: normalize public :: face_normal3 , face_normal4 !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33  digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest (module) representable value of kind=R8P variable. integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. character ( 10 ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P variable. type , public :: Vector !< Vector class. real ( R8P ) :: x = 0._R8P !< Cartesian component in x direction. real ( R8P ) :: y = 0._R8P !< Cartesian component in y direction. real ( R8P ) :: z = 0._R8P !< Cartesian component in z direction. contains procedure :: init => init_vector_self ! Procedure for initializing vector components. procedure :: set => set_vector_self ! Procedure for setting vector components. procedure :: iolen => iolen_vector_self ! Procedure for computing IO length. procedure :: load => load_vector_self ! Procedure for loading Vector data. procedure :: save => save_vector_self ! Procedure for saving Vector data. procedure :: print => print_vector_self ! Procedure for printing vector components with a \"pretty\" format. procedure :: sq_norm => sq_norm_self ! Procedure for computing the square of the norm of a vector. procedure :: normL2 => normL2_self ! Procedure for computing the norm L2 of a vector. procedure :: normalize => normalize_self ! Procedure for normalizing a vector. procedure :: normalized => normalized_self ! Procedure for obtaining a normalized copy of a vector. procedure :: face_normal4 => face_normal4_self ! Procedure for calculating the normal of the face defined by 4 points vector. procedure :: face_normal3 => face_normal3_self ! Procedure for calculating the normal of the face defined by 3 points vector. generic :: operator (. cross .) => crossproduct ! Procedure for computing the cross product of 2 vectors. generic :: operator (. dot .) => dotproduct ! Procedure for computing the scalar (dot) product of 2 vectors. generic :: operator (. paral .) => parallel ! Procedure for computing the component of vec1 parallel to vec2. generic :: operator (. ortho .) => orthogonal ! Procedure for computign the component of vec1 orthogonal to vec2. procedure , pass ( vec1 ), private :: crossproduct procedure , pass ( vec1 ), private :: dotproduct procedure , pass ( vec1 ), private :: parallel procedure , pass ( vec1 ), private :: orthogonal ! operators overloading generic :: assignment ( = ) => assign_self , & #ifdef r16p assign_ScalR16P ,& #endif assign_ScalR8P , assign_ScalR4P , assign_ScalI8P , assign_ScalI4P , assign_ScalI2P , assign_ScalI1P #ifdef r16p procedure , pass ( self ), private :: assign_ScalR16P #endif procedure , pass ( self1 ), private :: assign_self procedure , pass ( self ), private :: assign_ScalR8P procedure , pass ( self ), private :: assign_ScalR4P procedure , pass ( self ), private :: assign_ScalI8P procedure , pass ( self ), private :: assign_ScalI4P procedure , pass ( self ), private :: assign_ScalI2P procedure , pass ( self ), private :: assign_ScalI1P generic :: operator ( * ) => self_mul_self , & #ifdef r16p ScalR16P_mul_self , self_mul_ScalR16P , & #endif ScalR8P_mul_self , self_mul_ScalR8P , ScalR4P_mul_self , self_mul_ScalR4P , ScalI8P_mul_self , self_mul_ScalI8P ,& ScalI4P_mul_self , self_mul_ScalI4P , ScalI2P_mul_self , self_mul_ScalI2P , ScalI1P_mul_self , self_mul_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_mul_self procedure , pass ( self ), private :: self_mul_ScalR16P #endif procedure , pass ( self1 ), private :: self_mul_self procedure , pass ( self ), private :: ScalR8P_mul_self procedure , pass ( self ), private :: ScalR4P_mul_self procedure , pass ( self ), private :: ScalI8P_mul_self procedure , pass ( self ), private :: ScalI4P_mul_self procedure , pass ( self ), private :: ScalI2P_mul_self procedure , pass ( self ), private :: ScalI1P_mul_self procedure , pass ( self ), private :: self_mul_ScalR8P procedure , pass ( self ), private :: self_mul_ScalR4P procedure , pass ( self ), private :: self_mul_ScalI8P procedure , pass ( self ), private :: self_mul_ScalI4P procedure , pass ( self ), private :: self_mul_ScalI2P procedure , pass ( self ), private :: self_mul_ScalI1P generic :: operator ( / ) => self_div_self , & #ifdef r16p self_div_ScalR16P ,& #endif self_div_ScalR8P , self_div_ScalR4P , self_div_ScalI8P , self_div_ScalI4P , self_div_ScalI2P , self_div_ScalI1P #ifdef r16p procedure , pass ( self ), private :: self_div_ScalR16P #endif procedure , pass ( self1 ), private :: self_div_self procedure , pass ( self ), private :: self_div_ScalR8P procedure , pass ( self ), private :: self_div_ScalR4P procedure , pass ( self ), private :: self_div_ScalI8P procedure , pass ( self ), private :: self_div_ScalI4P procedure , pass ( self ), private :: self_div_ScalI2P procedure , pass ( self ), private :: self_div_ScalI1P generic :: operator ( + ) => positive_self , self_sum_self , & #ifdef r16p ScalR16P_sum_self , self_sum_ScalR16P , & #endif ScalR8P_sum_self , self_sum_ScalR8P , ScalR4P_sum_self , self_sum_ScalR4P , ScalI8P_sum_self , self_sum_ScalI8P ,& ScalI4P_sum_self , self_sum_ScalI4P , ScalI2P_sum_self , self_sum_ScalI2P , ScalI1P_sum_self , self_sum_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_sum_self procedure , pass ( self ), private :: self_sum_ScalR16P #endif procedure , pass ( self ), private :: positive_self procedure , pass ( self1 ), private :: self_sum_self procedure , pass ( self ), private :: ScalR8P_sum_self procedure , pass ( self ), private :: ScalR4P_sum_self procedure , pass ( self ), private :: ScalI8P_sum_self procedure , pass ( self ), private :: ScalI4P_sum_self procedure , pass ( self ), private :: ScalI2P_sum_self procedure , pass ( self ), private :: ScalI1P_sum_self procedure , pass ( self ), private :: self_sum_ScalR8P procedure , pass ( self ), private :: self_sum_ScalR4P procedure , pass ( self ), private :: self_sum_ScalI8P procedure , pass ( self ), private :: self_sum_ScalI4P procedure , pass ( self ), private :: self_sum_ScalI2P procedure , pass ( self ), private :: self_sum_ScalI1P generic :: operator ( - ) => negative_self , self_sub_self , & #ifdef r16p ScalR16P_sub_self , self_sub_ScalR16P , & #endif ScalR8P_sub_self , self_sub_ScalR8P , ScalR4P_sub_self , self_sub_ScalR4P , ScalI8P_sub_self , self_sub_ScalI8P ,& ScalI4P_sub_self , self_sub_ScalI4P , ScalI2P_sub_self , self_sub_ScalI2P , ScalI1P_sub_self , self_sub_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_sub_self procedure , pass ( self ), private :: self_sub_ScalR16P #endif procedure , pass ( self ), private :: negative_self procedure , pass ( self1 ), private :: self_sub_self procedure , pass ( self ), private :: ScalR8P_sub_self procedure , pass ( self ), private :: ScalR4P_sub_self procedure , pass ( self ), private :: ScalI8P_sub_self procedure , pass ( self ), private :: ScalI4P_sub_self procedure , pass ( self ), private :: ScalI2P_sub_self procedure , pass ( self ), private :: ScalI1P_sub_self procedure , pass ( self ), private :: self_sub_ScalR8P procedure , pass ( self ), private :: self_sub_ScalR4P procedure , pass ( self ), private :: self_sub_ScalI8P procedure , pass ( self ), private :: self_sub_ScalI4P procedure , pass ( self ), private :: self_sub_ScalI2P procedure , pass ( self ), private :: self_sub_ScalI1P generic :: operator ( /= ) => self_not_eq_self , & #ifdef r16p R16P_not_eq_self , self_not_eq_R16P , & #endif R8P_not_eq_self , self_not_eq_R8P , R4P_not_eq_self , self_not_eq_R4P , I8P_not_eq_self , self_not_eq_I8P ,& I4P_not_eq_self , self_not_eq_I4P , I2P_not_eq_self , self_not_eq_I2P , I1P_not_eq_self , self_not_eq_I1P generic :: operator ( < ) => self_low_self , & #ifdef r16p R16P_low_self , self_low_R16P , & #endif R8P_low_self , self_low_R8P , R4P_low_self , self_low_R4P , I8P_low_self , self_low_I8P ,& I4P_low_self , self_low_I4P , I2P_low_self , self_low_I2P , I1P_low_self , self_low_I1P generic :: operator ( <= ) => self_low_eq_self , & #ifdef r16p R16P_low_eq_self , self_low_eq_R16P , & #endif R8P_low_eq_self , self_low_eq_R8P , R4P_low_eq_self , self_low_eq_R4P , I8P_low_eq_self , self_low_eq_I8P ,& I4P_low_eq_self , self_low_eq_I4P , I2P_low_eq_self , self_low_eq_I2P , I1P_low_eq_self , self_low_eq_I1P generic :: operator ( == ) => self_eq_self , & #ifdef r16p R16P_eq_self , self_eq_R16P , & #endif R8P_eq_self , self_eq_R8P , R4P_eq_self , self_eq_R4P , I8P_eq_self , self_eq_I8P ,& I4P_eq_self , self_eq_I4P , I2P_eq_self , self_eq_I2P , I1P_eq_self , self_eq_I1P generic :: operator ( >= ) => self_great_eq_self , & #ifdef r16p R16P_great_eq_self , self_great_eq_R16P , & #endif R8P_great_eq_self , self_great_eq_R8P , R4P_great_eq_self , self_great_eq_R4P , I8P_great_eq_self ,& self_great_eq_I8P , I4P_great_eq_self , self_great_eq_I4P , I2P_great_eq_self , self_great_eq_I2P ,& I1P_great_eq_self , self_great_eq_I1P generic :: operator ( > ) => self_great_self , & #ifdef r16p R16P_great_self , self_great_R16P , & #endif R8P_great_self , self_great_R8P , R4P_great_self , self_great_R4P , I8P_great_self , self_great_I8P ,& I4P_great_self , self_great_I4P , I2P_great_self , self_great_I2P , I1P_great_self , self_great_I1P #ifdef r16p procedure , pass ( self ), private :: R16P_not_eq_self procedure , pass ( self ), private :: self_not_eq_R16P procedure , pass ( self ), private :: R16P_low_self procedure , pass ( self ), private :: self_low_R16P procedure , pass ( self ), private :: R16P_low_eq_self procedure , pass ( self ), private :: self_low_eq_R16P procedure , pass ( self ), private :: R16P_eq_self procedure , pass ( self ), private :: self_eq_R16P procedure , pass ( self ), private :: R16P_great_eq_self procedure , pass ( self ), private :: self_great_eq_R16P procedure , pass ( self ), private :: R16P_great_self procedure , pass ( self ), private :: self_great_R16P #endif procedure , pass ( self1 ), private :: self_not_eq_self procedure , pass ( self ), private :: R8P_not_eq_self procedure , pass ( self ), private :: R4P_not_eq_self procedure , pass ( self ), private :: I8P_not_eq_self procedure , pass ( self ), private :: I4P_not_eq_self procedure , pass ( self ), private :: I2P_not_eq_self procedure , pass ( self ), private :: I1P_not_eq_self procedure , pass ( self ), private :: self_not_eq_R8P procedure , pass ( self ), private :: self_not_eq_R4P procedure , pass ( self ), private :: self_not_eq_I8P procedure , pass ( self ), private :: self_not_eq_I4P procedure , pass ( self ), private :: self_not_eq_I2P procedure , pass ( self ), private :: self_not_eq_I1P procedure , pass ( self1 ), private :: self_low_self procedure , pass ( self ), private :: R8P_low_self procedure , pass ( self ), private :: R4P_low_self procedure , pass ( self ), private :: I8P_low_self procedure , pass ( self ), private :: I4P_low_self procedure , pass ( self ), private :: I2P_low_self procedure , pass ( self ), private :: I1P_low_self procedure , pass ( self ), private :: self_low_R8P procedure , pass ( self ), private :: self_low_R4P procedure , pass ( self ), private :: self_low_I8P procedure , pass ( self ), private :: self_low_I4P procedure , pass ( self ), private :: self_low_I2P procedure , pass ( self ), private :: self_low_I1P procedure , pass ( self1 ), private :: self_low_eq_self procedure , pass ( self ), private :: R8P_low_eq_self procedure , pass ( self ), private :: R4P_low_eq_self procedure , pass ( self ), private :: I8P_low_eq_self procedure , pass ( self ), private :: I4P_low_eq_self procedure , pass ( self ), private :: I2P_low_eq_self procedure , pass ( self ), private :: I1P_low_eq_self procedure , pass ( self ), private :: self_low_eq_R8P procedure , pass ( self ), private :: self_low_eq_R4P procedure , pass ( self ), private :: self_low_eq_I8P procedure , pass ( self ), private :: self_low_eq_I4P procedure , pass ( self ), private :: self_low_eq_I2P procedure , pass ( self ), private :: self_low_eq_I1P procedure , pass ( self1 ), private :: self_eq_self procedure , pass ( self ), private :: R8P_eq_self procedure , pass ( self ), private :: R4P_eq_self procedure , pass ( self ), private :: I8P_eq_self procedure , pass ( self ), private :: I4P_eq_self procedure , pass ( self ), private :: I2P_eq_self procedure , pass ( self ), private :: I1P_eq_self procedure , pass ( self ), private :: self_eq_R8P procedure , pass ( self ), private :: self_eq_R4P procedure , pass ( self ), private :: self_eq_I8P procedure , pass ( self ), private :: self_eq_I4P procedure , pass ( self ), private :: self_eq_I2P procedure , pass ( self ), private :: self_eq_I1P procedure , pass ( self1 ), private :: self_great_eq_self procedure , pass ( self ), private :: R8P_great_eq_self procedure , pass ( self ), private :: R4P_great_eq_self procedure , pass ( self ), private :: I8P_great_eq_self procedure , pass ( self ), private :: I4P_great_eq_self procedure , pass ( self ), private :: I2P_great_eq_self procedure , pass ( self ), private :: I1P_great_eq_self procedure , pass ( self ), private :: self_great_eq_R8P procedure , pass ( self ), private :: self_great_eq_R4P procedure , pass ( self ), private :: self_great_eq_I8P procedure , pass ( self ), private :: self_great_eq_I4P procedure , pass ( self ), private :: self_great_eq_I2P procedure , pass ( self ), private :: self_great_eq_I1P procedure , pass ( self1 ), private :: self_great_self procedure , pass ( self ), private :: R8P_great_self procedure , pass ( self ), private :: R4P_great_self procedure , pass ( self ), private :: I8P_great_self procedure , pass ( self ), private :: I4P_great_self procedure , pass ( self ), private :: I2P_great_self procedure , pass ( self ), private :: I1P_great_self procedure , pass ( self ), private :: self_great_R8P procedure , pass ( self ), private :: self_great_R4P procedure , pass ( self ), private :: self_great_I8P procedure , pass ( self ), private :: self_great_I4P procedure , pass ( self ), private :: self_great_I2P procedure , pass ( self ), private :: self_great_I1P endtype Vector type , public :: Vector_Ptr !< Pointer of Vector for creating array of pointers of Vector. type ( Vector ), pointer :: p => null () endtype Vector_Ptr type ( Vector ), parameter :: ex = Vector ( 1._R8P , 0._R8P , 0._R8P ) !< X direction versor. type ( Vector ), parameter :: ey = Vector ( 0._R8P , 1._R8P , 0._R8P ) !< Y direction versor. type ( Vector ), parameter :: ez = Vector ( 0._R8P , 0._R8P , 1._R8P ) !< Z direction versor. !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function sq_norm ( vec ) result ( sq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the square of the norm of a vector. !< !< The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: vec !< Vector. real ( R8P ) :: sq !< Square of the Norm. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sq = ( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sq_norm elemental function normL2 ( vec ) result ( norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the norm L2 of a vector. !< !< The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: vec !< Vector. real ( R8P ) :: norm !< Norm L2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- norm = sqrt (( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction normL2 elemental function normalize ( vec ) result ( norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Normalize a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the !< normalization value is set to normL2(vec)+smallR8P. !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: vec !< Vector to be normalized. type ( Vector ) :: norm !< Vector normalized. real ( R8P ) :: nm !< Norm L2 of vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- nm = normL2 ( vec ) if ( nm < smallR8P ) then nm = nm + smallR8P endif norm % x = vec % x / nm norm % y = vec % y / nm norm % z = vec % z / nm return !--------------------------------------------------------------------------------------------------------------------------------- endfunction normalize elemental function face_normal4 ( pt1 , pt2 , pt3 , pt4 , norm ) result ( fnormal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. !< !< The convention for the points numeration is the following: !<``` !< 1.----------.2 !<  |          | !<  |          | !<  |          | !<  |          | !< 4.----------.3 !<``` !< The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24. !< The normal is normalized if the variable *norm* is passed (with any value). !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: pt1 !< First face point. type ( Vector ), intent ( IN ) :: pt2 !< Second face point. type ( Vector ), intent ( IN ) :: pt3 !< Third face point. type ( Vector ), intent ( IN ) :: pt4 !< Fourth face point. character ( 1 ), intent ( IN ), optional :: norm !< If 'norm' is passed as argument the normal is normalized. type ( Vector ) :: fnormal !< Face normal. type ( Vector ) :: d13 !< Face 1-3 diagonal. type ( Vector ) :: d24 !< Face 2-4 diagonal. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- d13 = pt3 - pt1 d24 = pt4 - pt2 if ( present ( norm )) then fnormal = normalize ( d13 . cross . d24 ) else fnormal = 0.5_R8P * ( d13 . cross . d24 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction face_normal4 elemental function face_normal3 ( pt1 , pt2 , pt3 , norm ) result ( fnormal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. !< !< The convention for the points numeration is the following: !<``` !< 1.----.2 !<   \\   | !<    \\  | !<     \\ | !<      \\| !<       .3 !<``` !< The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13. !< The normal is normalized if the variable 'norm' is passed (with any value). !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: pt1 !< First face point. type ( Vector ), intent ( IN ) :: pt2 !< Second face point. type ( Vector ), intent ( IN ) :: pt3 !< Third face point. character ( 1 ), intent ( IN ), optional :: norm !< If 'norm' is passed as argument the normal is normalized. type ( Vector ) :: fnormal !< Face normal. type ( Vector ) :: s12 !< Face 1-2 diagonals. type ( Vector ) :: s13 !< Face 1-3 diagonals. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- s12 = pt2 - pt1 s13 = pt3 - pt1 if ( present ( norm )) then fnormal = normalize ( s12 . cross . s13 ) else fnormal = 0.5_R8P * ( s12 . cross . s13 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction face_normal3 elemental subroutine init_vector_self ( vec ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize components of Vector variable. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: vec !< Vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- vec % x = 0._R8P vec % y = 0._R8P vec % z = 0._R8P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init_vector_self elemental subroutine set_vector_self ( vec , x , y , z ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set components of Vector variable. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: vec !< Vector. real ( R8P ), intent ( IN ), optional :: x !< Cartesian component in x direction. real ( R8P ), intent ( IN ), optional :: y !< Cartesian component in y direction. real ( R8P ), intent ( IN ), optional :: z !< Cartesian component in z direction. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( x )) vec % x = x if ( present ( y )) vec % y = y if ( present ( z )) vec % z = z return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_vector_self function iolen_vector_self ( vec ) result ( iolen ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute IO length. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector. integer ( I4P ) :: iolen !< IO length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- inquire ( iolength = iolen ) vec % x , vec % y , vec % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction iolen_vector_self subroutine load_vector_self ( vec , unit , pos , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Load Vector data. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: vec !< Vector data. integer ( I4P ), intent ( IN ) :: unit !< Logic unit. integer ( I8P ), optional , intent ( IN ) :: pos !< Position specifier. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( pos )) then read ( unit = unit , pos = pos , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z else read ( unit = unit , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine load_vector_self subroutine save_vector_self ( vec , unit , pos , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save Vector data. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector data. integer ( I4P ), intent ( IN ) :: unit !< Logic unit. integer ( I8P ), optional , intent ( IN ) :: pos !< Position specifier. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( pos )) then write ( unit = unit , pos = pos , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z else write ( unit = unit , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_vector_self subroutine print_vector_self ( vec , unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print in a pretty ascii format the components of type Vector. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector. integer ( I4P ), optional , intent ( IN ) :: unit !< Logic unit. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string for outputs. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: unitd !< Logic unit. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- unitd = stdout ; if ( present ( unit )) unitd = unit prefd = '' ; if ( present ( pref )) prefd = pref write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component x ' // str ( n = vec % x ) write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component y ' // str ( n = vec % y ) write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component z ' // str ( n = vec % z ) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) return !--------------------------------------------------------------------------------------------------------------------------------- contains elemental function str ( n ) result ( str_ ) !------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( DR8P ) :: str_ !< Returned string containing input number. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- write ( str_ , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str_ ( 1 : 1 ) = '+' ! Prefixing plus if n>0. return !------------------------------------------------------------------------------------------------------------------------------- endfunction str endsubroutine print_vector_self elemental subroutine normalize_self ( vec ) !--------------------------------------------------------------------------------------------------------------------------------- !< Normalize a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the !< normalization value is set to normL2(vec)+smallR8P. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: vec !< Vector to be normalized. real ( R8P ) :: nm !< Norm L2 of vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- nm = normL2 ( vec ) if ( nm < smallR8P ) then nm = nm + smallR8P endif vec % x = vec % x / nm vec % y = vec % y / nm vec % z = vec % z / nm return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine normalize_self elemental function normalized_self ( vec ) result ( norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get a normalized copy of a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the !< normalization value is set to normL2(vec)+smallR8P. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector to be normalized. type ( Vector ) :: norm !< Normalized copy. real ( R8P ) :: nm !< Norm L2 of vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- nm = normL2 ( vec ) if ( nm < smallR8P ) then nm = nm + smallR8P endif norm % x = vec % x / nm norm % y = vec % y / nm norm % z = vec % z / nm return !--------------------------------------------------------------------------------------------------------------------------------- endfunction normalized_self elemental function sq_norm_self ( vec ) result ( sq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the square of the norm of a vector. !< !< The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector. real ( R8P ) :: sq !< Square of the Norm. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sq = ( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sq_norm_self elemental function normL2_self ( vec ) result ( norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the norm L2 of a vector. !< !< The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector. real ( R8P ) :: norm !< Norm L2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- norm = sqrt (( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction normL2_self elemental subroutine face_normal4_self ( fnormal , pt1 , pt2 , pt3 , pt4 , norm ) !< Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. !< !< The convention for the points numeration is the following: !<``` !< 1.----------.2 !<  |          | !<  |          | !<  |          | !<  |          | !< 4.----------.3 !<``` !< The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24. !< The normal is normalized if the variable *norm* is passed (with any value). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: fnormal !< Face normal. type ( Vector ), intent ( IN ) :: pt1 !< First face point. type ( Vector ), intent ( IN ) :: pt2 !< Second face point. type ( Vector ), intent ( IN ) :: pt3 !< Third face point. type ( Vector ), intent ( IN ) :: pt4 !< Fourth face point. character ( 1 ), optional , intent ( IN ) :: norm !< If 'norm' is passed as argument the normal is normalized. type ( Vector ) :: d13 !< Face 1-3 diagonals. type ( Vector ) :: d24 !< Face 2-4 diagonals. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- d13 = pt3 - pt1 d24 = pt4 - pt2 if ( present ( norm )) then fnormal = normalize ( d13 . cross . d24 ) else fnormal = 0.5_R8P * ( d13 . cross . d24 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine face_normal4_self elemental subroutine face_normal3_self ( fnormal , pt1 , pt2 , pt3 , norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. !< !< The convention for the points numeration is the following: !<``` !< 1.----.2 !<   \\   | !<    \\  | !<     \\ | !<      \\| !<       .3 !<``` !< The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13. !< The normal is normalized if the variable *norm* is passed (with any value). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: fnormal !< Face normal. type ( Vector ), intent ( IN ) :: pt1 !< First face point. type ( Vector ), intent ( IN ) :: pt2 !< Second face point. type ( Vector ), intent ( IN ) :: pt3 !< Third face point. character ( 1 ), optional , intent ( IN ) :: norm !< If 'norm' is passed as argument the normal is normalized. type ( Vector ) :: s12 !< Face 1-2 diagonals. type ( Vector ) :: s13 !< Face 1-3 diagonals. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- s12 = pt2 - pt1 s13 = pt3 - pt1 if ( present ( norm )) then fnormal = normalize ( s12 . cross . s13 ) else fnormal = 0.5_R8P * ( s12 . cross . s13 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine face_normal3_self elemental function crossproduct ( vec1 , vec2 ) result ( cross ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the cross product of 2 vectors. !< !<  \\vec V=\\left({y_1 z_2 - z_1 y_2}\\right)\\vec i + !<           \\left({z_1 x_2 - x_1 z_2}\\right)\\vec j + !<           \\left({x_1 y_2 - y_1 x_2}\\right)\\vec k  !< where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec1 !< First vector. type ( Vector ), intent ( IN ) :: vec2 !< Second vector. type ( Vector ) :: cross !< Cross product vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- cross % x = ( vec1 % y * vec2 % z ) - ( vec1 % z * vec2 % y ) cross % y = ( vec1 % z * vec2 % x ) - ( vec1 % x * vec2 % z ) cross % z = ( vec1 % x * vec2 % y ) - ( vec1 % y * vec2 % x ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction crossproduct elemental function dotproduct ( vec1 , vec2 ) result ( dot ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the scalar (dot) product of 2 vectors. !< !<  {\\rm D}= x_1 \\cdot x_2 + y_1 \\cdot y_2 + z_1 \\cdot z_2  !< where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec1 !< First vector. type ( Vector ), intent ( IN ) :: vec2 !< Second vector. real ( R8P ) :: dot !< Dot product. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dot = ( vec1 % x * vec2 % x ) + ( vec1 % y * vec2 % y ) + ( vec1 % z * vec2 % z ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dotproduct elemental function parallel ( vec1 , vec2 ) result ( paral ) !--------------------------------------------------------------------------------------------------------------------------------- !> Compute the component of vec1 parallel to vec2. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec1 !< First vector. type ( Vector ), intent ( IN ) :: vec2 !< Second vector. type ( Vector ) :: paral !< Component of of vec1 parallel to vec2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- paral = ( vec1 . dot . vec2 ) * normalize ( vec2 ) / normL2 ( vec2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction parallel elemental function orthogonal ( vec1 , vec2 ) result ( ortho ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the component of vec1 orthogonal to vec2. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec1 !< First vector. type ( Vector ), intent ( IN ) :: vec2 !< Second vector. type ( Vector ) :: ortho !< Component of of vec1 orthogonal to vec2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ortho = vec1 - ( vec1 . paral . vec2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction orthogonal ! Operators overloading. ! Operator (=) pure subroutine assign_self ( self1 , self2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between two selfs. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self1 class ( Vector ), intent ( IN ) :: self2 !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self1 % x = self2 % x self1 % y = self2 % y self1 % z = self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_self elemental subroutine assign_ScalR16P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (real R16P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self real ( R16P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalR16P elemental subroutine assign_ScalR8P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (real R8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( Vector ), intent ( INOUT ) :: self real ( R8P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalR8P elemental subroutine assign_ScalR4P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (real R4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self real ( R4P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalR4P elemental subroutine assign_ScalI8P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (integer I8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self integer ( I8P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalI8P elemental subroutine assign_ScalI4P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (integer I4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self integer ( I4P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalI4P elemental subroutine assign_ScalI2P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !> Assignment between a scalar (integer I2P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self integer ( I2P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalI2P elemental subroutine assign_ScalI1P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (integer I1P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self integer ( I1P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalI1P ! Operator (*) elemental function self_mul_self ( self1 , self2 ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply (by components) two selfs. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = self1 % x * self2 % x mul % y = self1 % y * self2 % y mul % z = self1 % z * self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_self elemental function ScalR16P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (real R16P) for self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR16P_mul_self elemental function self_mul_ScalR16P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (real R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalR16P elemental function ScalR8P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (real R8P) for self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR8P_mul_self elemental function self_mul_ScalR8P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (real R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalR8P elemental function ScalR4P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (real R4P) for self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR4P_mul_self elemental function self_mul_ScalR4P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (real R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalR4P elemental function ScalI8P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (integer I8P) for self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI8P_mul_self elemental function self_mul_ScalI8P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (integer I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalI8P elemental function ScalI4P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (integer I4P) for self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI4P_mul_self elemental function self_mul_ScalI4P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (integer I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalI4P elemental function ScalI2P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (integer I2P) for self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI2P_mul_self elemental function self_mul_ScalI2P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (integer I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalI2P elemental function ScalI1P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (integer I1P) for self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI1P_mul_self elemental function self_mul_ScalI1P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (integer I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalI1P ! Operator (/) elemental function self_div_self ( self1 , self2 ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self1 % x / self2 % x div % y = self1 % y / self2 % y div % z = self1 % z / self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_self elemental function self_div_ScalR16P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (real R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalR16P elemental function self_div_ScalR8P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (real R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalR8P elemental function self_div_ScalR4P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (real R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalR4P elemental function self_div_ScalI8P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (integer I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalI8P elemental function self_div_ScalI4P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (integer I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalI4P elemental function self_div_ScalI2P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (integer I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalI2P elemental function self_div_ScalI1P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (integer I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalI1P ! Operator (+) elemental function positive_self ( self ) result ( pos ) !--------------------------------------------------------------------------------------------------------------------------------- !< Applay unary + to a self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self type ( Vector ) :: pos !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pos % x = + self % x pos % y = + self % y pos % z = + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction positive_self elemental function self_sum_self ( self1 , self2 ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = self1 % x + self2 % x summ % y = self1 % y + self2 % y summ % z = self1 % z + self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_self elemental function ScalR16P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (real R16P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR16P_sum_self elemental function self_sum_ScalR16P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (real R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalR16P elemental function ScalR8P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (real R8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR8P_sum_self elemental function self_sum_ScalR8P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (real R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalR8P elemental function ScalR4P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (real R4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR4P_sum_self elemental function self_sum_ScalR4P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (real R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalR4P elemental function ScalI8P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (integer I8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI8P_sum_self elemental function self_sum_ScalI8P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (integer I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalI8P elemental function ScalI4P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (integer I4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI4P_sum_self elemental function self_sum_ScalI4P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (integer I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalI4P elemental function ScalI2P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (integer I2P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI2P_sum_self elemental function self_sum_ScalI2P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (integer I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalI2P elemental function ScalI1P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (integer I1P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI1P_sum_self elemental function self_sum_ScalI1P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (integer I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalI1P ! Operator (-) elemental function negative_self ( self ) result ( neg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Applay unary - to a self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self type ( Vector ) :: neg !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- neg % x = - self % x neg % y = - self % y neg % z = - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction negative_self elemental function self_sub_self ( self1 , self2 ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self1 % x - self2 % x sub % y = self1 % y - self2 % y sub % z = self1 % z - self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_self elemental function ScalR16P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (real R16P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR16P_sub_self elemental function self_sub_ScalR16P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (real R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalR16P elemental function ScalR8P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (real R8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR8P_sub_self elemental function self_sub_ScalR8P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (real R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalR8P elemental function ScalR4P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (real R4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR4P_sub_self elemental function self_sub_ScalR4P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (real R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalR4P elemental function ScalI8P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (integer I8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI8P_sub_self elemental function self_sub_ScalI8P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (integer I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalI8P elemental function ScalI4P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (integer I4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI4P_sub_self elemental function self_sub_ScalI4P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (integer I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalI4P elemental function ScalI2P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (integer I2P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI2P_sub_self elemental function self_sub_ScalI2P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (integer I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalI2P elemental function ScalI1P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (integer I1P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI1P_sub_self elemental function self_sub_ScalI1P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (integer I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalI1P ! Conditional operators ! Oprator /= elemental function self_not_eq_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1 !< and self2 are different, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 !< First selftor. type ( Vector ), intent ( IN ) :: self2 !< Second selftor. logical :: compare !< The result of the comparison. type ( Vector ) :: n1 !< Normalizations of self1. type ( Vector ) :: n2 !< Normalizations of self2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) /= normL2 ( self2 )) if (. not . compare ) then ! the normL2 are the same, checking the directions n1 = normalize ( self1 ) n2 = normalize ( self2 ) compare = (( n1 % x /= n2 % x ). OR .( n1 % y /= n2 % y ). OR .( n1 % z /= n2 % z )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_self elemental function R16P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_not_eq_self elemental function self_not_eq_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_R16P elemental function R8P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_not_eq_self elemental function self_not_eq_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_R8P elemental function R4P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_not_eq_self elemental function self_not_eq_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_R4P elemental function I8P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_not_eq_self elemental function self_not_eq_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_I8P elemental function I4P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_not_eq_self elemental function self_not_eq_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_I4P elemental function I2P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_not_eq_self elemental function self_not_eq_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_I2P elemental function I1P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_not_eq_self elemental function self_not_eq_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_I1P ! Oprator < elemental function self_low_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) < normL2 ( self2 )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_self elemental function R16P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_low_self elemental function self_low_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_R16P elemental function R8P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_low_self elemental function self_low_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_R8P elemental function R4P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_low_self elemental function self_low_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_R4P elemental function I8P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_low_self elemental function self_low_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_I8P elemental function I4P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_low_self elemental function self_low_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_I4P elemental function I2P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_low_self elemental function self_low_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_I2P elemental function I1P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_low_self elemental function self_low_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_I1P ! Oprator <= elemental function self_low_eq_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 ! First selftor. type ( Vector ), intent ( IN ) :: self2 ! Second selftor. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) <= normL2 ( self2 )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_self elemental function R16P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_low_eq_self elemental function self_low_eq_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R16P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_R16P elemental function R8P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_low_eq_self elemental function self_low_eq_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_R8P elemental function R4P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_low_eq_self elemental function self_low_eq_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_R4P elemental function I8P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_low_eq_self elemental function self_low_eq_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_I8P elemental function I4P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_low_eq_self elemental function self_low_eq_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_I4P elemental function I2P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_low_eq_self elemental function self_low_eq_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I2P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_I2P elemental function I1P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_low_eq_self elemental function self_low_eq_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I1P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_I1P ! Oprator == elemental function self_eq_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !> Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of !> self1 and self2 are the same, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 ! First selftor. type ( Vector ), intent ( IN ) :: self2 ! Second selftor. logical :: compare ! The result of the comparison. type ( Vector ) :: n1 ! Normalizations of self1. type ( Vector ) :: n2 ! Normalizations of self2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) == normL2 ( self2 )) if ( compare ) then ! the normL2 are the same, checking the directions n1 = normalize ( self1 ) n2 = normalize ( self2 ) compare = (( n1 % x == n2 % x ). AND .( n1 % y == n2 % y ). AND .( n1 % z == n2 % z )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_self elemental function R16P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_eq_self elemental function self_eq_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R16P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_R16P elemental function R8P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_eq_self elemental function self_eq_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_R8P elemental function R4P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_eq_self elemental function self_eq_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_R4P elemental function I8P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_eq_self elemental function self_eq_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_I8P elemental function I4P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_eq_self elemental function self_eq_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_I4P elemental function I2P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_eq_self elemental function self_eq_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I2P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_I2P elemental function I1P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_eq_self elemental function self_eq_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I1P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_I1P ! Oprator >= elemental function self_great_eq_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 ! First selftor. type ( Vector ), intent ( IN ) :: self2 ! Second selftor. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) >= normL2 ( self2 )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_self elemental function R16P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_great_eq_self elemental function self_great_eq_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R16P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_R16P elemental function R8P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_great_eq_self elemental function self_great_eq_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_R8P elemental function R4P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_great_eq_self elemental function self_great_eq_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_R4P elemental function I8P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_great_eq_self elemental function self_great_eq_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_I8P elemental function I4P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_great_eq_self elemental function self_great_eq_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_I4P elemental function I2P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_great_eq_self elemental function self_great_eq_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I2P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_I2P elemental function I1P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_great_eq_self elemental function self_great_eq_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I1P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_I1P ! Oprator > elemental function self_great_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 ! First selftor. type ( Vector ), intent ( IN ) :: self2 ! Second selftor. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) > normL2 ( self2 )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_self elemental function R16P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_great_self elemental function self_great_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R16P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_R16P elemental function R8P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_great_self elemental function self_great_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_R8P elemental function R4P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_great_self elemental function self_great_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_R4P elemental function I8P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_great_self elemental function self_great_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_I8P elemental function I4P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_great_self elemental function self_great_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_I4P elemental function I2P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_great_self elemental function self_great_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I2P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_I2P elemental function I1P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_great_self elemental function self_great_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I1P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_I1P endmodule VecFor","tags":"","loc":"sourcefile/vecfor.f90.html","title":"vecfor.F90 – FLOw"},{"text":"Kinds regression test for VecFor library. This File Depends On sourcefile~~kinds.f90~~EfferentGraph sourcefile~kinds.f90 kinds.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs kinds Source Code kinds.f90 Source Code !< Kinds regression test for VecFor library. program kinds !< Kinds regression test for VecFor library. !< !< Try to test the algebra of mixed vector/numbers for all supported kinds. use vecfor implicit none #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33  digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. type ( vector ) :: vector1 !< Vector dummy variable. type ( vector ) :: vector2 !< Vector dummy variable. type ( vector ) :: vector3 !< Vector dummy variable. call vector1 % set ( x =- 1._R8P , y =- 1._R8P , z =- 1._R8P ) call vector1 % init () print \"(A)\" , ' Assign vector1 = [1, 2, 3]' vector1 = 1 * ex + 2 * ey + 3 * ez print \"(A)\" , ' Assign vector2 = [1, 1, 1] testing assignments by scalar' vector2 = 1._R16P vector2 = 1._R8P vector2 = 1._R4P vector2 = 1_I8P vector2 = 1_I4P vector2 = 1_I2P vector2 = 1_I1P print \"(A)\" , ' Verify * operator, multiply by 1 defined in any supported number formats' vector1 = 1._R16P * vector1 vector1 = 1._R8P * vector1 vector1 = 1._R4P * vector1 vector1 = 1_I8P * vector1 vector1 = 1_I4P * vector1 vector1 = 1_I2P * vector1 vector1 = 1_I1P * vector1 vector1 = vector1 * 1._R16P vector1 = vector1 * 1._R8P vector1 = vector1 * 1._R4P vector1 = vector1 * 1_I8P vector1 = vector1 * 1_I4P vector1 = vector1 * 1_I2P vector1 = vector1 * 1_I1P call vector1 % print print \"(A)\" , ' Verify * operator between vectors, vector1 * vector2' vector1 = vector1 * vector2 call vector1 % print print \"(A)\" , ' Verify / operator, diveded by 1 defined in any supported number formats' vector1 = vector1 / 1._R16P vector1 = vector1 / 1._R8P vector1 = vector1 / 1._R4P vector1 = vector1 / 1_I8P vector1 = vector1 / 1_I4P vector1 = vector1 / 1_I2P vector1 = vector1 / 1_I1P call vector1 % print print \"(A)\" , ' Verify / operator between vectors, vector1 / vector2' vector1 = vector1 / vector2 call vector1 % print print \"(A)\" , ' Verify + operator, add 1 (14 times) defined in any supported number formats' vector1 = 1._R16P + vector1 vector1 = 1._R8P + vector1 vector1 = 1._R4P + vector1 vector1 = 1_I8P + vector1 vector1 = 1_I4P + vector1 vector1 = 1_I2P + vector1 vector1 = 1_I1P + vector1 vector1 = + vector1 vector1 = vector1 + 1._R16P vector1 = vector1 + 1._R8P vector1 = vector1 + 1._R4P vector1 = vector1 + 1_I8P vector1 = vector1 + 1_I4P vector1 = vector1 + 1_I2P vector1 = vector1 + 1_I1P call vector1 % print print \"(A)\" , ' Verify + operator between vectors, vector1 + vector2' vector1 = vector1 + vector2 call vector1 % print print \"(A)\" , ' Verify - operator, subtract 1 (14 times) defined in any supported number formats' vector1 = 1._R16P - vector1 vector1 =- 1._R8P - vector1 vector1 = 1._R4P - vector1 vector1 =- 1_I8P - vector1 vector1 = 1_I4P - vector1 vector1 =- 1_I2P - vector1 vector1 = 1_I1P - vector1 vector1 = - vector1 vector1 = vector1 - 1._R16P vector1 = vector1 - 1._R8P vector1 = vector1 - 1._R4P vector1 = vector1 - 1_I8P vector1 = vector1 - 1_I4P vector1 = vector1 - 1_I2P vector1 = vector1 - 1_I1P call vector1 % print print \"(A)\" , ' Verify - operator between vectors, vector1 - vector2' vector1 = vector1 - vector2 call vector1 % print print \"(A)\" , ' Verify save/load methods' open ( unit = 2 , form = 'UNFORMATTED' , status = 'SCRATCH' ) call vector1 % save ( unit = 2 ) rewind ( unit = 2 ) call vector3 % load ( unit = 2 ) close ( unit = 2 ) call vector3 % print vector3 = 0 print \"(A)\" , ' Verify save/load methods with stream-accessed file' open ( unit = 2 , form = 'UNFORMATTED' , status = 'SCRATCH' , access = 'STREAM' ) call vector1 % save ( unit = 2 , pos = 1_I8P ) rewind ( unit = 2 ) call vector3 % load ( unit = 2 , pos = 1_I8P ) close ( unit = 2 ) call vector3 % print print \"(A)\" , ' Verify < operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1<1._R16P => ' , ( vector1 < 1._R16P ) print \"(A,L1)\" , 'vector1<1._R8P  => ' , ( vector1 < 1._R8P ) print \"(A,L1)\" , 'vector1<1._R4P  => ' , ( vector1 < 1._R4P ) print \"(A,L1)\" , 'vector1<1_I8P   => ' , ( vector1 < 1_I8P ) print \"(A,L1)\" , 'vector1<1_I4P   => ' , ( vector1 < 1_I4P ) print \"(A,L1)\" , 'vector1<1_I2P   => ' , ( vector1 < 1_I2P ) print \"(A,L1)\" , 'vector1<1_I1P   => ' , ( vector1 < 1_I1P ) print \"(A,L1)\" , '1._R16P<vector1 => ' , ( 1._R16P < vector1 ) print \"(A,L1)\" , '1._R8P <vector1 => ' , ( 1._R8P < vector1 ) print \"(A,L1)\" , '1._R4P <vector1 => ' , ( 1._R4P < vector1 ) print \"(A,L1)\" , '1_I8P  <vector1 => ' , ( 1_I8P < vector1 ) print \"(A,L1)\" , '1_I4P  <vector1 => ' , ( 1_I4P < vector1 ) print \"(A,L1)\" , '1_I2P  <vector1 => ' , ( 1_I2P < vector1 ) print \"(A,L1)\" , '1_I1P  <vector1 => ' , ( 1_I1P < vector1 ) print \"(A,L1)\" , 'vector1<vector2 => ' , ( vector1 < vector2 ) print \"(A)\" , ' Verify <= operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1<=1._R16P => ' , ( vector1 <= 1._R16P ) print \"(A,L1)\" , 'vector1<=1._R8P  => ' , ( vector1 <= 1._R8P ) print \"(A,L1)\" , 'vector1<=1._R4P  => ' , ( vector1 <= 1._R4P ) print \"(A,L1)\" , 'vector1<=1_I8P   => ' , ( vector1 <= 1_I8P ) print \"(A,L1)\" , 'vector1<=1_I4P   => ' , ( vector1 <= 1_I4P ) print \"(A,L1)\" , 'vector1<=1_I2P   => ' , ( vector1 <= 1_I2P ) print \"(A,L1)\" , 'vector1<=1_I1P   => ' , ( vector1 <= 1_I1P ) print \"(A,L1)\" , '1._R16P<=vector1 => ' , ( 1._R16P <= vector1 ) print \"(A,L1)\" , '1._R8P <=vector1 => ' , ( 1._R8P <= vector1 ) print \"(A,L1)\" , '1._R4P <=vector1 => ' , ( 1._R4P <= vector1 ) print \"(A,L1)\" , '1_I8P  <=vector1 => ' , ( 1_I8P <= vector1 ) print \"(A,L1)\" , '1_I4P  <=vector1 => ' , ( 1_I4P <= vector1 ) print \"(A,L1)\" , '1_I2P  <=vector1 => ' , ( 1_I2P <= vector1 ) print \"(A,L1)\" , '1_I1P  <=vector1 => ' , ( 1_I1P <= vector1 ) print \"(A,L1)\" , 'vector1<=vector2 => ' , ( vector1 <= vector2 ) print \"(A)\" , ' Verify == operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1==1._R16P => ' , ( vector1 == 1._R16P ) print \"(A,L1)\" , 'vector1==1._R8P  => ' , ( vector1 == 1._R8P ) print \"(A,L1)\" , 'vector1==1._R4P  => ' , ( vector1 == 1._R4P ) print \"(A,L1)\" , 'vector1==1_I8P   => ' , ( vector1 == 1_I8P ) print \"(A,L1)\" , 'vector1==1_I4P   => ' , ( vector1 == 1_I4P ) print \"(A,L1)\" , 'vector1==1_I2P   => ' , ( vector1 == 1_I2P ) print \"(A,L1)\" , 'vector1==1_I1P   => ' , ( vector1 == 1_I1P ) print \"(A,L1)\" , '1._R16P==vector1 => ' , ( 1._R16P == vector1 ) print \"(A,L1)\" , '1._R8P ==vector1 => ' , ( 1._R8P == vector1 ) print \"(A,L1)\" , '1._R4P ==vector1 => ' , ( 1._R4P == vector1 ) print \"(A,L1)\" , '1_I8P  ==vector1 => ' , ( 1_I8P == vector1 ) print \"(A,L1)\" , '1_I4P  ==vector1 => ' , ( 1_I4P == vector1 ) print \"(A,L1)\" , '1_I2P  ==vector1 => ' , ( 1_I2P == vector1 ) print \"(A,L1)\" , '1_I1P  ==vector1 => ' , ( 1_I1P == vector1 ) print \"(A,L1)\" , 'vector1==vector2 => ' , ( vector1 == vector2 ) print \"(A,L1)\" , 'vector1==-vector1 => ' , ( vector1 ==- vector1 ) print \"(A)\" , ' Verify /= operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1/=1._R16P => ' , ( vector1 /= 1._R16P ) print \"(A,L1)\" , 'vector1/=1._R8P  => ' , ( vector1 /= 1._R8P ) print \"(A,L1)\" , 'vector1/=1._R4P  => ' , ( vector1 /= 1._R4P ) print \"(A,L1)\" , 'vector1/=1_I8P   => ' , ( vector1 /= 1_I8P ) print \"(A,L1)\" , 'vector1/=1_I4P   => ' , ( vector1 /= 1_I4P ) print \"(A,L1)\" , 'vector1/=1_I2P   => ' , ( vector1 /= 1_I2P ) print \"(A,L1)\" , 'vector1/=1_I1P   => ' , ( vector1 /= 1_I1P ) print \"(A,L1)\" , '1._R16P/=vector1 => ' , ( 1._R16P /= vector1 ) print \"(A,L1)\" , '1._R8P /=vector1 => ' , ( 1._R8P /= vector1 ) print \"(A,L1)\" , '1._R4P /=vector1 => ' , ( 1._R4P /= vector1 ) print \"(A,L1)\" , '1_I8P  /=vector1 => ' , ( 1_I8P /= vector1 ) print \"(A,L1)\" , '1_I4P  /=vector1 => ' , ( 1_I4P /= vector1 ) print \"(A,L1)\" , '1_I2P  /=vector1 => ' , ( 1_I2P /= vector1 ) print \"(A,L1)\" , '1_I1P  /=vector1 => ' , ( 1_I1P /= vector1 ) print \"(A,L1)\" , 'vector1/=vector2 => ' , ( vector1 /= vector2 ) print \"(A,L1)\" , 'vector1/=-vector1 => ' , ( vector1 /=- vector1 ) print \"(A)\" , ' Verify >= operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1>=1._R16P => ' , ( vector1 >= 1._R16P ) print \"(A,L1)\" , 'vector1>=1._R8P  => ' , ( vector1 >= 1._R8P ) print \"(A,L1)\" , 'vector1>=1._R4P  => ' , ( vector1 >= 1._R4P ) print \"(A,L1)\" , 'vector1>=1_I8P   => ' , ( vector1 >= 1_I8P ) print \"(A,L1)\" , 'vector1>=1_I4P   => ' , ( vector1 >= 1_I4P ) print \"(A,L1)\" , 'vector1>=1_I2P   => ' , ( vector1 >= 1_I2P ) print \"(A,L1)\" , 'vector1>=1_I1P   => ' , ( vector1 >= 1_I1P ) print \"(A,L1)\" , '1._R16P>=vector1 => ' , ( 1._R16P >= vector1 ) print \"(A,L1)\" , '1._R8P >=vector1 => ' , ( 1._R8P >= vector1 ) print \"(A,L1)\" , '1._R4P >=vector1 => ' , ( 1._R4P >= vector1 ) print \"(A,L1)\" , '1_I8P  >=vector1 => ' , ( 1_I8P >= vector1 ) print \"(A,L1)\" , '1_I4P  >=vector1 => ' , ( 1_I4P >= vector1 ) print \"(A,L1)\" , '1_I2P  >=vector1 => ' , ( 1_I2P >= vector1 ) print \"(A,L1)\" , '1_I1P  >=vector1 => ' , ( 1_I1P >= vector1 ) print \"(A,L1)\" , 'vector1>=vector2 => ' , ( vector1 >= vector2 ) print \"(A)\" , ' Verify > operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1>1._R16P => ' , ( vector1 > 1._R16P ) print \"(A,L1)\" , 'vector1>1._R8P  => ' , ( vector1 > 1._R8P ) print \"(A,L1)\" , 'vector1>1._R4P  => ' , ( vector1 > 1._R4P ) print \"(A,L1)\" , 'vector1>1_I8P   => ' , ( vector1 > 1_I8P ) print \"(A,L1)\" , 'vector1>1_I4P   => ' , ( vector1 > 1_I4P ) print \"(A,L1)\" , 'vector1>1_I2P   => ' , ( vector1 > 1_I2P ) print \"(A,L1)\" , 'vector1>1_I1P   => ' , ( vector1 > 1_I1P ) print \"(A,L1)\" , '1._R16P>vector1 => ' , ( 1._R16P > vector1 ) print \"(A,L1)\" , '1._R8P >vector1 => ' , ( 1._R8P > vector1 ) print \"(A,L1)\" , '1._R4P >vector1 => ' , ( 1._R4P > vector1 ) print \"(A,L1)\" , '1_I8P  >vector1 => ' , ( 1_I8P > vector1 ) print \"(A,L1)\" , '1_I4P  >vector1 => ' , ( 1_I4P > vector1 ) print \"(A,L1)\" , '1_I2P  >vector1 => ' , ( 1_I2P > vector1 ) print \"(A,L1)\" , '1_I1P  >vector1 => ' , ( 1_I1P > vector1 ) print \"(A,L1)\" , 'vector1>vector2 => ' , ( vector1 > vector2 ) stop endprogram kinds","tags":"","loc":"sourcefile/kinds.f90.html","title":"kinds.f90 – FLOw"},{"text":"Simple regression test for VecFor library. This File Depends On sourcefile~~simple.f90~~EfferentGraph sourcefile~simple.f90 simple.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~simple.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs simple Source Code simple.f90 Source Code !< Simple regression test for VecFor library. program simple !< Simple regression test for VecFor library. use vecfor implicit none type ( vector ) :: vector1 !< Vector dummy variable. type ( vector ) :: vector2 !< Vector dummy variable. type ( vector ) :: vector3 !< Vector dummy variable. type ( vector ) :: vector4 !< Vector dummy variable. type ( vector ) :: vector5 !< Vector dummy variable. print \"(A)\" , ' Assign vector1 = [1, 2, 3]' vector1 = 1 * ex + 2 * ey + 3 * ez print \"(A)\" , ' Assign vector2 = [-1, -2, -3]' vector2 = - 1 * ex - 2 * ey - 3 * ez print \"(A)\" , ' Verify auxiliary methods' print \"(A,F5.1)\" , ' vector1%sq_norm() = ' , vector1 % sq_norm () print \"(A,F5.1)\" , ' sq_norm(vector1) = ' , sq_norm ( vector1 ) print \"(A,F5.1)\" , ' vector1%normL2() = ' , vector1 % normL2 () print \"(A,F5.1)\" , ' normL2(vector1) = ' , normL2 ( vector1 ) print \"(A)\" , ' normalized(vector1):' vector3 = vector1 % normalized () call vector3 % print print \"(A)\" , 'call vector1%normalize():' vector3 = vector1 call vector3 % normalize () call vector3 % print print \"(A)\" , ' Verify normalization fall-back for null vector' vector3 = 0 call vector3 % normalize () print \"(A)\" , 'call 0%normalize():' call vector3 % print vector3 = 0 vector3 = vector3 % normalized () print \"(A)\" , 'vector1 = 0%normalized():' call vector3 % print print \"(A)\" , ' Verify dot product' print \"(A,F5.1)\" , ' vector1.dot.ex = ' , vector1 . dot . ex print \"(A,F5.1)\" , ' vector1.dot.ey = ' , vector1 . dot . ey print \"(A,F5.1)\" , ' vector1.dot.ez = ' , vector1 . dot . ez print \"(A,F5.1)\" , ' vector1.dot.vector2 = ' , vector1 . dot . vector2 print \"(A)\" , ' Verify cross product' print \"(A)\" , ' vector1.cross.vector2:' vector3 = vector1 . cross . vector2 call vector3 % print print \"(A)\" , ' Verify special operators' print \"(A)\" , ' vector1.ortho.vector2:' vector3 = vector1 . ortho . vector2 call vector3 % print print \"(A)\" , ' vector1.paral.vector2:' vector3 = vector1 . paral . vector2 call vector3 % print print \"(A)\" , ' Verify * / + - operators' print \"(A)\" , ' vector1 * vector2:' vector3 = vector1 * vector2 call vector3 % print print \"(A)\" , ' vector1 / vector2:' vector3 = vector1 / vector2 call vector3 % print print \"(A)\" , ' vector1 + vector2:' vector3 = vector1 + vector2 call vector3 % print print \"(A)\" , ' vector1 - vector2:' vector3 = vector1 - vector2 call vector3 % print print \"(A)\" , ' Assign vector1 = [-1, 1, 0]' vector1 = - ex + ey print \"(A)\" , ' Assign vector2 = [0, 1, 0]' vector2 = ey print \"(A)\" , ' Assign vector3 = [0, -1, 0]' vector3 = - ey print \"(A)\" , ' Assign vector4 = [-1, -1, 0]' vector4 = - ex - ey print \"(A)\" , ' Face 1-2-3 normal (stand alone procedure):' vector5 = face_normal3 ( pt1 = vector1 , pt2 = vector2 , pt3 = vector3 ) call vector5 % print print \"(A)\" , ' Face 1-2-3 normal (stand alone procedure, normalized):' vector5 = face_normal3 ( norm = 'y' , pt1 = vector1 , pt2 = vector2 , pt3 = vector3 ) call vector5 % print print \"(A)\" , ' Face 1-2-3 normal (type bound method):' call vector5 % face_normal3 ( pt1 = vector1 , pt2 = vector2 , pt3 = vector3 ) call vector5 % print print \"(A)\" , ' Face 1-2-3 normal (type bound method, normalized):' call vector5 % face_normal3 ( norm = 'y' , pt1 = vector1 , pt2 = vector2 , pt3 = vector3 ) call vector5 % print print \"(A)\" , ' Face 1-2-3-4 normal (stand alone procedure): ' vector5 = face_normal4 ( pt1 = vector1 , pt2 = vector2 , pt3 = vector3 , pt4 = vector4 ) call vector5 % print print \"(A)\" , ' Face 1-2-3-4 normal (stand alone procedure, normalized): ' vector5 = face_normal4 ( norm = 'y' , pt1 = vector1 , pt2 = vector2 , pt3 = vector3 , pt4 = vector4 ) call vector5 % print print \"(A)\" , ' Face 1-2-3-4 normal (type bound method):' call vector5 % face_normal4 ( pt1 = vector1 , pt2 = vector2 , pt3 = vector3 , pt4 = vector4 ) call vector5 % print print \"(A)\" , ' Face 1-2-3-4 normal (type bound method, normalized):' call vector5 % face_normal4 ( norm = 'y' , pt1 = vector1 , pt2 = vector2 , pt3 = vector3 , pt4 = vector4 ) call vector5 % print print \"(A,I3)\" , ' IO length of vector1 = ' , vector1 % iolen () stop endprogram simple","tags":"","loc":"sourcefile/simple.f90.html","title":"simple.f90 – FLOw"},{"text":"type, public, abstract :: field_object field (abstract) object. Inherited By type~~field_object~~InheritedByGraph type~field_object field_object type~field_object_scalar field_object_scalar type~field_object->type~field_object_scalar type~field_object_vectorial field_object_vectorial type~field_object->type~field_object_vectorial type~primitive_object primitive_object type~field_object_scalar->type~primitive_object density, pressure, partial_densities type~field_object_vectorial->type~primitive_object velocity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Type-Bound Procedures assign_field assign_real add div div_integer div_real mul mul_integer integer_mul mul_real real_mul sub pow_integer pow_real eq not_eq assignment(=) operator(+) operator(/) operator(*) operator(-) operator(**) operator(==) operator(/=) Source Code field_object Type-Bound Procedures procedure( abstract_assign ), public, deferred, pass(lhs) :: assign_field Assign fields. pure subroutine abstract_assign (lhs, rhs) Prototype Assign fields. Arguments Type Intent Optional Attributes Name class( field_object ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. procedure( abstract_assign_real ), public, deferred, pass(lhs) :: assign_real Assign real to field. pure subroutine abstract_assign_real (lhs, rhs) Prototype Assign real to field. Arguments Type Intent Optional Attributes Name class( field_object ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. procedure( abstract_simmetric_operator ), public, deferred, pass(lhs) :: add Add fields. pure function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Symmetric operator field.op.field. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( abstract_simmetric_operator ), public, deferred, pass(lhs) :: div Divide fields. pure function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Symmetric operator field.op.field. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( abstract_field_op_integer ), public, deferred, pass(lhs) :: div_integer Divide field by integer. pure function abstract_field_op_integer (lhs, rhs) result(opr) Prototype Non symmetric operator field.op.integer. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( abstract_field_op_real ), public, deferred, pass(lhs) :: div_real Divide field by real. pure function abstract_field_op_real (lhs, rhs) result(opr) Prototype Non symmetric operator field.op.real. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( abstract_simmetric_operator ), public, deferred, pass(lhs) :: mul Multiply fields. pure function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Symmetric operator field.op.field. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( abstract_field_op_integer ), public, deferred, pass(lhs) :: mul_integer Multiply field for integer. pure function abstract_field_op_integer (lhs, rhs) result(opr) Prototype Non symmetric operator field.op.integer. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( abstract_integer_op_field ), public, deferred, pass(rhs) :: integer_mul Multiply integer for field. pure function abstract_integer_op_field (lhs, rhs) result(opr) Prototype Non symmetric operator integer.op.field. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( abstract_field_op_real ), public, deferred, pass(lhs) :: mul_real Multiply field for real. pure function abstract_field_op_real (lhs, rhs) result(opr) Prototype Non symmetric operator field.op.real. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( abstract_real_op_field ), public, deferred, pass(rhs) :: real_mul Multiply real for field. pure function abstract_real_op_field (lhs, rhs) result(opr) Prototype Non symmetric operator real.op.field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( abstract_simmetric_operator ), public, deferred, pass(lhs) :: sub Subtract fields. pure function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Symmetric operator field.op.field. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( abstract_field_op_integer ), public, deferred, pass(lhs) :: pow_integer Power field by integer. pure function abstract_field_op_integer (lhs, rhs) result(opr) Prototype Non symmetric operator field.op.integer. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( abstract_field_op_real ), public, deferred, pass(lhs) :: pow_real Power field by real. pure function abstract_field_op_real (lhs, rhs) result(opr) Prototype Non symmetric operator field.op.real. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( abstract_compare ), public, deferred, pass(lhs) :: eq Compare (`==') fields. pure function abstract_compare (lhs, rhs) result(opr) Prototype Compare overloading. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure( abstract_compare ), public, deferred, pass(lhs) :: not_eq Compare (`/=') fields. pure function abstract_compare (lhs, rhs) result(opr) Prototype Compare overloading. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: assignment(=) => assign_field , assign_real Assignment overloading. private pure subroutine assign_field_vectorial (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private pure subroutine assign_real_vectorial (lhs, rhs) Assign real to field. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. generic, public :: operator(+) => add Operator + overloading. private pure function vectorial_add_vectorial (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/) => div , div_integer , div_real Operator / overloading. private pure function vectorial_div_object (lhs, rhs) result(opr) Divide fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_div_integer (lhs, rhs) result(opr) Divide field by integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_div_real (lhs, rhs) result(opr) Divide field by real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(*) => mul , mul_integer , integer_mul , real_mul , mul_real Operator * overloading. private pure function vectorial_mul_object (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_mul_integer (lhs, rhs) result(opr) Multiply field for integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function integer_mul_vectorial (lhs, rhs) result(opr) Multiply integer for field. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: lhs Left hand side. class( field_object_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function real_mul_vectorial (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_object_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_mul_real (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub Operator - overloading. private pure function vectorial_sub_vectorial (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(**) => pow_integer , pow_real Operator ** overloading. private pure function vectorial_pow_integer (lhs, rhs) result(opr) Power field by integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_pow_real (lhs, rhs) result(opr) Power field by real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(==) => eq Operator /= overloading. private pure function eq_vectorial (lhs, rhs) result(opr) Compare ( == ) fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(/=) => not_eq Operator /= overloading. private pure function not_eq_vectorial (lhs, rhs) result(opr) Compare ( /= ) fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code type , abstract :: field_object !< **field** (abstract) object. contains ! deferred operators methods procedure ( abstract_assign ), pass ( lhs ), deferred :: assign_field !< Assign fields. procedure ( abstract_assign_real ), pass ( lhs ), deferred :: assign_real !< Assign real to field. procedure ( abstract_simmetric_operator ), pass ( lhs ), deferred :: add !< Add fields. procedure ( abstract_simmetric_operator ), pass ( lhs ), deferred :: div !< Divide fields. procedure ( abstract_field_op_integer ), pass ( lhs ), deferred :: div_integer !< Divide field by integer. procedure ( abstract_field_op_real ), pass ( lhs ), deferred :: div_real !< Divide field by real. procedure ( abstract_simmetric_operator ), pass ( lhs ), deferred :: mul !< Multiply fields. procedure ( abstract_field_op_integer ), pass ( lhs ), deferred :: mul_integer !< Multiply field for integer. procedure ( abstract_integer_op_field ), pass ( rhs ), deferred :: integer_mul !< Multiply integer for field. procedure ( abstract_field_op_real ), pass ( lhs ), deferred :: mul_real !< Multiply field for real. procedure ( abstract_real_op_field ), pass ( rhs ), deferred :: real_mul !< Multiply real for field. procedure ( abstract_simmetric_operator ), pass ( lhs ), deferred :: sub !< Subtract fields. procedure ( abstract_field_op_integer ), pass ( lhs ), deferred :: pow_integer !< Power field by integer. procedure ( abstract_field_op_real ), pass ( lhs ), deferred :: pow_real !< Power field by real. procedure ( abstract_compare ), pass ( lhs ), deferred :: eq !< Compare (`==') fields. procedure ( abstract_compare ), pass ( lhs ), deferred :: not_eq !< Compare (`/=') fields. ! public operators generic :: assignment ( = ) => assign_field , assign_real !< Assignment overloading. generic :: operator ( + ) => add !< Operator `+` overloading. generic :: operator ( / ) => div , div_integer , div_real !< Operator `/` overloading. generic :: operator ( * ) => mul , mul_integer , integer_mul , real_mul , mul_real !< Operator `*` overloading. generic :: operator ( - ) => sub !< Operator `-` overloading. generic :: operator ( ** ) => pow_integer , pow_real !< Operator `**` overloading. generic :: operator ( == ) => eq !< Operator `/=` overloading. generic :: operator ( /= ) => not_eq !< Operator `/=` overloading. endtype field_object","tags":"","loc":"type/field_object.html","title":"field_object – FLOw "},{"text":"type, public, extends( field_object ) :: field_object_scalar type~~field_object_scalar~~InheritsGraph type~field_object_scalar field_object_scalar type~field_object field_object type~field_object->type~field_object_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). scalar field object. Inherited By type~~field_object_scalar~~InheritedByGraph type~field_object_scalar field_object_scalar type~primitive_object primitive_object type~field_object_scalar->type~primitive_object density, pressure, partial_densities Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables field Type-Bound Procedures assignment(=) operator(+) operator(/) operator(*) operator(-) operator(**) operator(==) operator(/=) assign_field assign_real add div div_integer div_real mul mul_integer integer_mul mul_real real_mul sub pow_integer pow_real eq not_eq Source Code field_object_scalar Components Type Visibility Attributes Name Initial real(kind=R_P), public :: field Scalar field. Type-Bound Procedures generic, public :: assignment(=) => assign_field , assign_real Assignment overloading. private pure subroutine assign_field_vectorial (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private pure subroutine assign_real_vectorial (lhs, rhs) Assign real to field. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. generic, public :: operator(+) => add Operator + overloading. private pure function vectorial_add_vectorial (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/) => div , div_integer , div_real Operator / overloading. private pure function vectorial_div_object (lhs, rhs) result(opr) Divide fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_div_integer (lhs, rhs) result(opr) Divide field by integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_div_real (lhs, rhs) result(opr) Divide field by real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(*) => mul , mul_integer , integer_mul , real_mul , mul_real Operator * overloading. private pure function vectorial_mul_object (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_mul_integer (lhs, rhs) result(opr) Multiply field for integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function integer_mul_vectorial (lhs, rhs) result(opr) Multiply integer for field. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: lhs Left hand side. class( field_object_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function real_mul_vectorial (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_object_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_mul_real (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub Operator - overloading. private pure function vectorial_sub_vectorial (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(**) => pow_integer , pow_real Operator ** overloading. private pure function vectorial_pow_integer (lhs, rhs) result(opr) Power field by integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_pow_real (lhs, rhs) result(opr) Power field by real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(==) => eq Operator /= overloading. private pure function eq_vectorial (lhs, rhs) result(opr) Compare ( == ) fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(/=) => not_eq Operator /= overloading. private pure function not_eq_vectorial (lhs, rhs) result(opr) Compare ( /= ) fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, public, pass(lhs) :: assign_field => assign_field_scalar Assign fields. private pure subroutine assign_field_scalar (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real => assign_real_scalar Assign real to field. private pure subroutine assign_real_scalar (lhs, rhs) Assign real to field. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: add => scalar_add_scalar Add fields. private pure function scalar_add_scalar (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: div => scalar_div_scalar Divide fields. private pure function scalar_div_scalar (lhs, rhs) result(opr) Divide fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: div_integer => scalar_div_integer Divide field by integer. private pure function scalar_div_integer (lhs, rhs) result(opr) Divide field by integer. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: div_real => scalar_div_real Divide field by real. private pure function scalar_div_real (lhs, rhs) result(opr) Divide field by real. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul => scalar_mul_object Multiply fields. private pure function scalar_mul_object (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul_integer => scalar_mul_integer Multiply field for integer. private pure function scalar_mul_integer (lhs, rhs) result(opr) Multiply field for integer. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(rhs) :: integer_mul => integer_mul_scalar Multiply scalar or field. private pure function integer_mul_scalar (lhs, rhs) result(opr) Multiply integer for field. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: lhs Left hand side. class( field_object_scalar ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul_real => scalar_mul_real Multiply field for real. private pure function scalar_mul_real (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(rhs) :: real_mul => real_mul_scalar Multiply real for field. private pure function real_mul_scalar (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_object_scalar ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: sub => scalar_sub_scalar Subtract fields. private pure function scalar_sub_scalar (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: pow_integer => scalar_pow_integer Power field by integer. private pure function scalar_pow_integer (lhs, rhs) result(opr) Power field by integer. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: pow_real => scalar_pow_real Power field by real. private pure function scalar_pow_real (lhs, rhs) result(opr) Power field by real. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: eq => eq_scalar Compare (`==') fields. private pure function eq_scalar (lhs, rhs) result(opr) Compare ( == ) fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, public, pass(lhs) :: not_eq => not_eq_scalar Compare (`/=') fields. private pure function not_eq_scalar (lhs, rhs) result(opr) Compare ( /= ) fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code type , extends ( field_object ) :: field_object_scalar !< **scalar field** object. real ( R_P ) :: field !< Scalar field. contains ! deferred methods procedure , pass ( lhs ) :: assign_field => assign_field_scalar !< Assign fields. procedure , pass ( lhs ) :: assign_real => assign_real_scalar !< Assign real to field. procedure , pass ( lhs ) :: add => scalar_add_scalar !< Add fields. procedure , pass ( lhs ) :: div => scalar_div_scalar !< Divide fields. procedure , pass ( lhs ) :: div_integer => scalar_div_integer !< Divide field by integer. procedure , pass ( lhs ) :: div_real => scalar_div_real !< Divide field by real. procedure , pass ( lhs ) :: mul => scalar_mul_object !< Multiply fields. procedure , pass ( lhs ) :: mul_integer => scalar_mul_integer !< Multiply field for integer. procedure , pass ( rhs ) :: integer_mul => integer_mul_scalar !< Multiply scalar or field. procedure , pass ( lhs ) :: mul_real => scalar_mul_real !< Multiply field for real. procedure , pass ( rhs ) :: real_mul => real_mul_scalar !< Multiply real for field. procedure , pass ( lhs ) :: sub => scalar_sub_scalar !< Subtract fields. procedure , pass ( lhs ) :: pow_integer => scalar_pow_integer !< Power field by integer. procedure , pass ( lhs ) :: pow_real => scalar_pow_real !< Power field by real. procedure , pass ( lhs ) :: eq => eq_scalar !< Compare (`==') fields. procedure , pass ( lhs ) :: not_eq => not_eq_scalar !< Compare (`/=') fields. endtype field_object_scalar","tags":"","loc":"type/field_object_scalar.html","title":"field_object_scalar – FLOw "},{"text":"type, public, extends( field_object ) :: field_object_vectorial type~~field_object_vectorial~~InheritsGraph type~field_object_vectorial field_object_vectorial vector vector vector->type~field_object_vectorial field type~field_object field_object type~field_object->type~field_object_vectorial Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). vectorial field object. Inherited By type~~field_object_vectorial~~InheritedByGraph type~field_object_vectorial field_object_vectorial type~primitive_object primitive_object type~field_object_vectorial->type~primitive_object velocity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables field Type-Bound Procedures assignment(=) operator(+) operator(/) operator(*) operator(-) operator(**) operator(==) operator(/=) assign_field assign_real add div div_integer div_real mul mul_integer integer_mul mul_real real_mul sub pow_integer pow_real eq not_eq Source Code field_object_vectorial Components Type Visibility Attributes Name Initial type(vector), public :: field Vectorial field. Type-Bound Procedures generic, public :: assignment(=) => assign_field , assign_real Assignment overloading. private pure subroutine assign_field_vectorial (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private pure subroutine assign_real_vectorial (lhs, rhs) Assign real to field. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. generic, public :: operator(+) => add Operator + overloading. private pure function vectorial_add_vectorial (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/) => div , div_integer , div_real Operator / overloading. private pure function vectorial_div_object (lhs, rhs) result(opr) Divide fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_div_integer (lhs, rhs) result(opr) Divide field by integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_div_real (lhs, rhs) result(opr) Divide field by real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(*) => mul , mul_integer , integer_mul , real_mul , mul_real Operator * overloading. private pure function vectorial_mul_object (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_mul_integer (lhs, rhs) result(opr) Multiply field for integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function integer_mul_vectorial (lhs, rhs) result(opr) Multiply integer for field. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: lhs Left hand side. class( field_object_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function real_mul_vectorial (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_object_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_mul_real (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub Operator - overloading. private pure function vectorial_sub_vectorial (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(**) => pow_integer , pow_real Operator ** overloading. private pure function vectorial_pow_integer (lhs, rhs) result(opr) Power field by integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_pow_real (lhs, rhs) result(opr) Power field by real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(==) => eq Operator /= overloading. private pure function eq_vectorial (lhs, rhs) result(opr) Compare ( == ) fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(/=) => not_eq Operator /= overloading. private pure function not_eq_vectorial (lhs, rhs) result(opr) Compare ( /= ) fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, public, pass(lhs) :: assign_field => assign_field_vectorial Assign fields. private pure subroutine assign_field_vectorial (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real => assign_real_vectorial Assign real to field. private pure subroutine assign_real_vectorial (lhs, rhs) Assign real to field. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: add => vectorial_add_vectorial Add fields. private pure function vectorial_add_vectorial (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: div => vectorial_div_object Divide fields. private pure function vectorial_div_object (lhs, rhs) result(opr) Divide fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: div_integer => vectorial_div_integer Divide field by integer. private pure function vectorial_div_integer (lhs, rhs) result(opr) Divide field by integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: div_real => vectorial_div_real Divide field by real. private pure function vectorial_div_real (lhs, rhs) result(opr) Divide field by real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul => vectorial_mul_object Multiply fields. private pure function vectorial_mul_object (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul_integer => vectorial_mul_integer Multiply field for integer. private pure function vectorial_mul_integer (lhs, rhs) result(opr) Multiply field for integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(rhs) :: integer_mul => integer_mul_vectorial Multiply integer for field. private pure function integer_mul_vectorial (lhs, rhs) result(opr) Multiply integer for field. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: lhs Left hand side. class( field_object_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul_real => vectorial_mul_real Multiply field for real. private pure function vectorial_mul_real (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(rhs) :: real_mul => real_mul_vectorial Multiply real for field. private pure function real_mul_vectorial (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_object_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: sub => vectorial_sub_vectorial Subtract fields. private pure function vectorial_sub_vectorial (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: pow_integer => vectorial_pow_integer Power field by integer. private pure function vectorial_pow_integer (lhs, rhs) result(opr) Power field by integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: pow_real => vectorial_pow_real Power field by real. private pure function vectorial_pow_real (lhs, rhs) result(opr) Power field by real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: eq => eq_vectorial Compare (`==') fields. private pure function eq_vectorial (lhs, rhs) result(opr) Compare ( == ) fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, public, pass(lhs) :: not_eq => not_eq_vectorial Compare (`/=') fields. private pure function not_eq_vectorial (lhs, rhs) result(opr) Compare ( /= ) fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code type , extends ( field_object ) :: field_object_vectorial !< **vectorial field** object. type ( vector ) :: field !< Vectorial field. contains ! deferred methods procedure , pass ( lhs ) :: assign_field => assign_field_vectorial !< Assign fields. procedure , pass ( lhs ) :: assign_real => assign_real_vectorial !< Assign real to field. procedure , pass ( lhs ) :: add => vectorial_add_vectorial !< Add fields. procedure , pass ( lhs ) :: div => vectorial_div_object !< Divide fields. procedure , pass ( lhs ) :: div_integer => vectorial_div_integer !< Divide field by integer. procedure , pass ( lhs ) :: div_real => vectorial_div_real !< Divide field by real. procedure , pass ( lhs ) :: mul => vectorial_mul_object !< Multiply fields. procedure , pass ( lhs ) :: mul_integer => vectorial_mul_integer !< Multiply field for integer. procedure , pass ( rhs ) :: integer_mul => integer_mul_vectorial !< Multiply integer for field. procedure , pass ( lhs ) :: mul_real => vectorial_mul_real !< Multiply field for real. procedure , pass ( rhs ) :: real_mul => real_mul_vectorial !< Multiply real for field. procedure , pass ( lhs ) :: sub => vectorial_sub_vectorial !< Subtract fields. procedure , pass ( lhs ) :: pow_integer => vectorial_pow_integer !< Power field by integer. procedure , pass ( lhs ) :: pow_real => vectorial_pow_real !< Power field by real. procedure , pass ( lhs ) :: eq => eq_vectorial !< Compare (`==') fields. procedure , pass ( lhs ) :: not_eq => not_eq_vectorial !< Compare (`/=') fields. endtype field_object_vectorial","tags":"","loc":"type/field_object_vectorial.html","title":"field_object_vectorial – FLOw "},{"text":"type, public :: primitive_object type~~primitive_object~~InheritsGraph type~primitive_object primitive_object type~field_object_scalar field_object_scalar type~field_object_scalar->type~primitive_object density, pressure, partial_densities type~field_object_vectorial field_object_vectorial type~field_object_vectorial->type~primitive_object velocity type~field_object field_object type~field_object->type~field_object_scalar type~field_object->type~field_object_vectorial vector vector vector->type~field_object_vectorial field Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FLOw primitive class definition. Variables density velocity pressure partial_densities Type-Bound Procedures assignment(=) operator(+) operator(/) operator(*) operator(-) operator(==) operator(/=) operator(.compatible.) assign_primitive assign_real add div div_integer div_real mul mul_integer integer_mul mul_real real_mul sub eq not_eq compatible Source Code primitive_object Components Type Visibility Attributes Name Initial type( field_object_scalar ), public :: density Density field. type( field_object_vectorial ), public :: velocity Velocity field. type( field_object_scalar ), public :: pressure Pressure field. type( field_object_scalar ), public, allocatable :: partial_densities (:) Partial densities fields. Type-Bound Procedures generic, public :: assignment(=) => assign_primitive , assign_real Assignment overloading. private pure subroutine assign_primitive (lhs, rhs) Assign primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. private pure subroutine assign_real (lhs, rhs) Assign real to primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. generic, public :: operator(+) => add Operator + overloading. private elemental function add (lhs, rhs) result(opr) Add primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. generic, public :: operator(/) => div , div_integer , div_real Operator / overloading. private elemental function div (lhs, rhs) result(opr) Divide primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. private elemental function div_integer (lhs, rhs) result(opr) Divide primitive by integer. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. private elemental function div_real (lhs, rhs) result(opr) Divide primitive by real. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. generic, public :: operator(*) => mul , mul_integer , integer_mul , mul_real , real_mul Operator * overloading. private elemental function mul (lhs, rhs) result(opr) Multiply primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. private elemental function mul_integer (lhs, rhs) result(opr) Multiply primitive for integer. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. private elemental function integer_mul (lhs, rhs) result(opr) Multiply integer for primitive. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. private elemental function mul_real (lhs, rhs) result(opr) Multiply primitive for real. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. private elemental function real_mul (lhs, rhs) result(opr) Multiply real for primitive. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. generic, public :: operator(-) => sub Operator - overloading. private elemental function sub (lhs, rhs) result(opr) Subtract primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. generic, public :: operator(==) => eq Operator == overloading. private pure function eq (lhs, rhs) result(opr) Compare ( == ) primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(/=) => not_eq Operator /= overloading. private pure function not_eq (lhs, rhs) result(opr) Compare ( /= ) primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(.compatible.) => compatible Operator .compatible. overloading. private pure function compatible (lhs, rhs) result(opr) Check primitives compatibility (size of partial densities). Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, private, pass(lhs) :: assign_primitive Assign primitives. private pure subroutine assign_primitive (lhs, rhs) Assign primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: assign_real Assign real to primitive. private pure subroutine assign_real (lhs, rhs) Assign real to primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: add Add primitives. private elemental function add (lhs, rhs) result(opr) Add primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. procedure, private, pass(lhs) :: div Divide primitives. private elemental function div (lhs, rhs) result(opr) Divide primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. procedure, private, pass(lhs) :: div_integer Divide primitive by integer. private elemental function div_integer (lhs, rhs) result(opr) Divide primitive by integer. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. procedure, private, pass(lhs) :: div_real Divide primitive by real. private elemental function div_real (lhs, rhs) result(opr) Divide primitive by real. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. procedure, private, pass(lhs) :: mul Multiply primitives. private elemental function mul (lhs, rhs) result(opr) Multiply primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. procedure, private, pass(lhs) :: mul_integer Multiply primitive for integer. private elemental function mul_integer (lhs, rhs) result(opr) Multiply primitive for integer. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. procedure, private, pass(rhs) :: integer_mul Multiply integer for primitive. private elemental function integer_mul (lhs, rhs) result(opr) Multiply integer for primitive. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. procedure, private, pass(lhs) :: mul_real Multiply primitive for real. private elemental function mul_real (lhs, rhs) result(opr) Multiply primitive for real. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. procedure, private, pass(rhs) :: real_mul Multiply real for primitive. private elemental function real_mul (lhs, rhs) result(opr) Multiply real for primitive. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. procedure, private, pass(lhs) :: sub Subtract primitives. private elemental function sub (lhs, rhs) result(opr) Subtract primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. procedure, private, pass(lhs) :: eq Compare (`==') primitives. private pure function eq (lhs, rhs) result(opr) Compare ( == ) primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, private, pass(lhs) :: not_eq Compare (`/=') primitives. private pure function not_eq (lhs, rhs) result(opr) Compare ( /= ) primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, private, pass(lhs) :: compatible Compare ( .compatible. ) primitives. private pure function compatible (lhs, rhs) result(opr) Check primitives compatibility (size of partial densities). Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code type :: primitive_object !< FLOw **primitive** class definition. type ( field_object_scalar ) :: density !< Density field. type ( field_object_vectorial ) :: velocity !< Velocity field. type ( field_object_scalar ) :: pressure !< Pressure field. type ( field_object_scalar ), allocatable :: partial_densities (:) !< Partial densities fields. contains ! public operators generic :: assignment ( = ) => assign_primitive , assign_real !< Assignment overloading. generic :: operator ( + ) => add !< Operator `+` overloading. generic :: operator ( / ) => div , div_integer , div_real !< Operator `/` overloading. generic :: operator ( * ) => mul , mul_integer , integer_mul , mul_real , real_mul !< Operator `*` overloading. generic :: operator ( - ) => sub !< Operator `-` overloading. generic :: operator ( == ) => eq !< Operator `==` overloading. generic :: operator ( /= ) => not_eq !< Operator `/=` overloading. generic :: operator (. compatible .) => compatible !< Operator `.compatible.` overloading. ! private methods procedure , pass ( lhs ), private :: assign_primitive !< Assign primitives. procedure , pass ( lhs ), private :: assign_real !< Assign real to primitive. procedure , pass ( lhs ), private :: add !< Add primitives. procedure , pass ( lhs ), private :: div !< Divide primitives. procedure , pass ( lhs ), private :: div_integer !< Divide primitive by integer. procedure , pass ( lhs ), private :: div_real !< Divide primitive by real. procedure , pass ( lhs ), private :: mul !< Multiply primitives. procedure , pass ( lhs ), private :: mul_integer !< Multiply primitive for integer. procedure , pass ( rhs ), private :: integer_mul !< Multiply integer for primitive. procedure , pass ( lhs ), private :: mul_real !< Multiply primitive for real. procedure , pass ( rhs ), private :: real_mul !< Multiply real for primitive. procedure , pass ( lhs ), private :: sub !< Subtract primitives. procedure , pass ( lhs ), private :: eq !< Compare (`==') primitives. procedure , pass ( lhs ), private :: not_eq !< Compare (`/=') primitives. procedure , pass ( lhs ), private :: compatible !< Compare (`.compatible.`) primitives. endtype primitive_object","tags":"","loc":"type/primitive_object.html","title":"primitive_object – FLOw "},{"text":"type, public :: Vector Vector class. Inherited By type~~vector~~InheritedByGraph type~vector Vector type~vector_ptr Vector_Ptr type~vector->type~vector_ptr p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables x y z Type-Bound Procedures init set iolen load save print sq_norm normL2 normalize normalized face_normal4 face_normal3 operator(.cross.) operator(.dot.) operator(.paral.) operator(.ortho.) crossproduct dotproduct parallel orthogonal assignment(=) assign_self assign_ScalR8P assign_ScalR4P assign_ScalI8P assign_ScalI4P assign_ScalI2P assign_ScalI1P operator(*) self_mul_self ScalR8P_mul_self ScalR4P_mul_self ScalI8P_mul_self ScalI4P_mul_self ScalI2P_mul_self ScalI1P_mul_self self_mul_ScalR8P self_mul_ScalR4P self_mul_ScalI8P self_mul_ScalI4P self_mul_ScalI2P self_mul_ScalI1P operator(/) self_div_self self_div_ScalR8P self_div_ScalR4P self_div_ScalI8P self_div_ScalI4P self_div_ScalI2P self_div_ScalI1P operator(+) positive_self self_sum_self ScalR8P_sum_self ScalR4P_sum_self ScalI8P_sum_self ScalI4P_sum_self ScalI2P_sum_self ScalI1P_sum_self self_sum_ScalR8P self_sum_ScalR4P self_sum_ScalI8P self_sum_ScalI4P self_sum_ScalI2P self_sum_ScalI1P operator(-) negative_self self_sub_self ScalR8P_sub_self ScalR4P_sub_self ScalI8P_sub_self ScalI4P_sub_self ScalI2P_sub_self ScalI1P_sub_self self_sub_ScalR8P self_sub_ScalR4P self_sub_ScalI8P self_sub_ScalI4P self_sub_ScalI2P self_sub_ScalI1P operator(/=) operator(<) operator(<=) operator(==) operator(>=) operator(>) self_not_eq_self R8P_not_eq_self R4P_not_eq_self I8P_not_eq_self I4P_not_eq_self I2P_not_eq_self I1P_not_eq_self self_not_eq_R8P self_not_eq_R4P self_not_eq_I8P self_not_eq_I4P self_not_eq_I2P self_not_eq_I1P self_low_self R8P_low_self R4P_low_self I8P_low_self I4P_low_self I2P_low_self I1P_low_self self_low_R8P self_low_R4P self_low_I8P self_low_I4P self_low_I2P self_low_I1P self_low_eq_self R8P_low_eq_self R4P_low_eq_self I8P_low_eq_self I4P_low_eq_self I2P_low_eq_self I1P_low_eq_self self_low_eq_R8P self_low_eq_R4P self_low_eq_I8P self_low_eq_I4P self_low_eq_I2P self_low_eq_I1P self_eq_self R8P_eq_self R4P_eq_self I8P_eq_self I4P_eq_self I2P_eq_self I1P_eq_self self_eq_R8P self_eq_R4P self_eq_I8P self_eq_I4P self_eq_I2P self_eq_I1P self_great_eq_self R8P_great_eq_self R4P_great_eq_self I8P_great_eq_self I4P_great_eq_self I2P_great_eq_self I1P_great_eq_self self_great_eq_R8P self_great_eq_R4P self_great_eq_I8P self_great_eq_I4P self_great_eq_I2P self_great_eq_I1P self_great_self R8P_great_self R4P_great_self I8P_great_self I4P_great_self I2P_great_self I1P_great_self self_great_R8P self_great_R4P self_great_I8P self_great_I4P self_great_I2P self_great_I1P Source Code Vector Components Type Visibility Attributes Name Initial real(kind=R8P), public :: x = 0._R8P Cartesian component in x direction. real(kind=R8P), public :: y = 0._R8P Cartesian component in y direction. real(kind=R8P), public :: z = 0._R8P Cartesian component in z direction. Type-Bound Procedures procedure, public :: init => init_vector_self private elemental subroutine init_vector_self (vec) Initialize components of Vector variable. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector. procedure, public :: set => set_vector_self private elemental subroutine set_vector_self (vec, x, y, z) Set components of Vector variable. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector. real(kind=R8P), intent(in), optional :: x Cartesian component in x direction. real(kind=R8P), intent(in), optional :: y Cartesian component in y direction. real(kind=R8P), intent(in), optional :: z Cartesian component in z direction. procedure, public :: iolen => iolen_vector_self private function iolen_vector_self (vec) result(iolen) Compute IO length. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value integer(kind=I4P) IO length. procedure, public :: load => load_vector_self private subroutine load_vector_self (vec, unit, pos, iostat, iomsg) Load Vector data. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. procedure, public :: save => save_vector_self private subroutine save_vector_self (vec, unit, pos, iostat, iomsg) Save Vector data. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. procedure, public :: print => print_vector_self private subroutine print_vector_self (vec, unit, pref, iostat, iomsg) Print in a pretty ascii format the components of type Vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. integer(kind=I4P), intent(in), optional :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string for outputs. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. procedure, public :: sq_norm => sq_norm_self private elemental function sq_norm_self (vec) result(sq) Compute the square of the norm of a vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Square of the Norm. procedure, public :: normL2 => normL2_self private elemental function normL2_self (vec) result(norm) Compute the norm L2 of a vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Norm L2. procedure, public :: normalize => normalize_self private elemental subroutine normalize_self (vec) Normalize a vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector to be normalized. procedure, public :: normalized => normalized_self private elemental function normalized_self (vec) result(norm) Get a normalized copy of a vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector to be normalized. Return Value type( Vector ) Normalized copy. procedure, public :: face_normal4 => face_normal4_self private elemental subroutine face_normal4_self (fnormal, pt1, pt2, pt3, pt4, norm) Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: fnormal Face normal. type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. type( Vector ), intent(in) :: pt4 Fourth face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. procedure, public :: face_normal3 => face_normal3_self private elemental subroutine face_normal3_self (fnormal, pt1, pt2, pt3, norm) Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: fnormal Face normal. type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. generic, public :: operator(.cross.) => crossproduct private elemental function crossproduct (vec1, vec2) result(cross) Compute the cross product of 2 vectors. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Cross product vector. generic, public :: operator(.dot.) => dotproduct private elemental function dotproduct (vec1, vec2) result(dot) Compute the scalar (dot) product of 2 vectors. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value real(kind=R8P) Dot product. generic, public :: operator(.paral.) => parallel private elemental function parallel (vec1, vec2) result(paral) Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 Compute the component of vec1 parallel to vec2.\n First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Component of of vec1 parallel to vec2. generic, public :: operator(.ortho.) => orthogonal private elemental function orthogonal (vec1, vec2) result(ortho) Compute the component of vec1 orthogonal to vec2. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Component of of vec1 orthogonal to vec2. procedure, private, pass(vec1) :: crossproduct private elemental function crossproduct (vec1, vec2) result(cross) Compute the cross product of 2 vectors. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Cross product vector. procedure, private, pass(vec1) :: dotproduct private elemental function dotproduct (vec1, vec2) result(dot) Compute the scalar (dot) product of 2 vectors. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value real(kind=R8P) Dot product. procedure, private, pass(vec1) :: parallel private elemental function parallel (vec1, vec2) result(paral) Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 Compute the component of vec1 parallel to vec2.\n First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Component of of vec1 parallel to vec2. procedure, private, pass(vec1) :: orthogonal private elemental function orthogonal (vec1, vec2) result(ortho) Compute the component of vec1 orthogonal to vec2. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Component of of vec1 orthogonal to vec2. generic, public :: assignment(=) => assign_self , assign_ScalR8P , assign_ScalR4P , assign_ScalI8P , assign_ScalI4P , assign_ScalI2P , assign_ScalI1P private pure subroutine assign_self (self1, self2) Assignment between two selfs. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self1 class( Vector ), intent(in) :: self2 private elemental subroutine assign_ScalR8P (self, scal) Assignment between a scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R8P), intent(in) :: scal private elemental subroutine assign_ScalR4P (self, scal) Assignment between a scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R4P), intent(in) :: scal private elemental subroutine assign_ScalI8P (self, scal) Assignment between a scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I8P), intent(in) :: scal private elemental subroutine assign_ScalI4P (self, scal) Assignment between a scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I4P), intent(in) :: scal private elemental subroutine assign_ScalI2P (self, scal) Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self Assignment between a scalar (integer I2P) and self. integer(kind=I2P), intent(in) :: scal private elemental subroutine assign_ScalI1P (self, scal) Assignment between a scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I1P), intent(in) :: scal procedure, private, pass(self1) :: assign_self private pure subroutine assign_self (self1, self2) Assignment between two selfs. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self1 class( Vector ), intent(in) :: self2 procedure, private, pass(self ) :: assign_ScalR8P private elemental subroutine assign_ScalR8P (self, scal) Assignment between a scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R8P), intent(in) :: scal procedure, private, pass(self ) :: assign_ScalR4P private elemental subroutine assign_ScalR4P (self, scal) Assignment between a scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R4P), intent(in) :: scal procedure, private, pass(self ) :: assign_ScalI8P private elemental subroutine assign_ScalI8P (self, scal) Assignment between a scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I8P), intent(in) :: scal procedure, private, pass(self ) :: assign_ScalI4P private elemental subroutine assign_ScalI4P (self, scal) Assignment between a scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I4P), intent(in) :: scal procedure, private, pass(self ) :: assign_ScalI2P private elemental subroutine assign_ScalI2P (self, scal) Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self Assignment between a scalar (integer I2P) and self. integer(kind=I2P), intent(in) :: scal procedure, private, pass(self ) :: assign_ScalI1P private elemental subroutine assign_ScalI1P (self, scal) Assignment between a scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I1P), intent(in) :: scal generic, public :: operator(*) => self_mul_self , ScalR8P_mul_self , self_mul_ScalR8P , ScalR4P_mul_self , self_mul_ScalR4P , ScalI8P_mul_self , self_mul_ScalI8P , ScalI4P_mul_self , self_mul_ScalI4P , ScalI2P_mul_self , self_mul_ScalI2P , ScalI1P_mul_self , self_mul_ScalI1P private elemental function self_mul_self (self1, self2) result(mul) Multiply (by components) two selfs. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) private elemental function ScalR8P_mul_self (scal, self) result(mul) Multiply scalar (real R8P) for self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalR8P (self, scal) result(mul) Multiply self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalR4P_mul_self (scal, self) result(mul) Multiply scalar (real R4P) for self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalR4P (self, scal) result(mul) Multiply self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI8P_mul_self (scal, self) result(mul) Multiply scalar (integer I8P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalI8P (self, scal) result(mul) Multiply self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI4P_mul_self (scal, self) result(mul) Multiply scalar (integer I4P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalI4P (self, scal) result(mul) Multiply self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI2P_mul_self (scal, self) result(mul) Multiply scalar (integer I2P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalI2P (self, scal) result(mul) Multiply self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI1P_mul_self (scal, self) result(mul) Multiply scalar (integer I1P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalI1P (self, scal) result(mul) Multiply self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self1) :: self_mul_self private elemental function self_mul_self (self1, self2) result(mul) Multiply (by components) two selfs. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) procedure, private, pass(self ) :: ScalR8P_mul_self private elemental function ScalR8P_mul_self (scal, self) result(mul) Multiply scalar (real R8P) for self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalR4P_mul_self private elemental function ScalR4P_mul_self (scal, self) result(mul) Multiply scalar (real R4P) for self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI8P_mul_self private elemental function ScalI8P_mul_self (scal, self) result(mul) Multiply scalar (integer I8P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI4P_mul_self private elemental function ScalI4P_mul_self (scal, self) result(mul) Multiply scalar (integer I4P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI2P_mul_self private elemental function ScalI2P_mul_self (scal, self) result(mul) Multiply scalar (integer I2P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI1P_mul_self private elemental function ScalI1P_mul_self (scal, self) result(mul) Multiply scalar (integer I1P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: self_mul_ScalR8P private elemental function self_mul_ScalR8P (self, scal) result(mul) Multiply self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_mul_ScalR4P private elemental function self_mul_ScalR4P (self, scal) result(mul) Multiply self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_mul_ScalI8P private elemental function self_mul_ScalI8P (self, scal) result(mul) Multiply self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_mul_ScalI4P private elemental function self_mul_ScalI4P (self, scal) result(mul) Multiply self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_mul_ScalI2P private elemental function self_mul_ScalI2P (self, scal) result(mul) Multiply self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_mul_ScalI1P private elemental function self_mul_ScalI1P (self, scal) result(mul) Multiply self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) generic, public :: operator(/) => self_div_self , self_div_ScalR8P , self_div_ScalR4P , self_div_ScalI8P , self_div_ScalI4P , self_div_ScalI2P , self_div_ScalI1P private elemental function self_div_self (self1, self2) result(div) Divide self for self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) private elemental function self_div_ScalR8P (self, scal) result(div) Divide self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalR4P (self, scal) result(div) Divide self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalI8P (self, scal) result(div) Divide self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalI4P (self, scal) result(div) Divide self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalI2P (self, scal) result(div) Divide self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalI1P (self, scal) result(div) Divide self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self1) :: self_div_self private elemental function self_div_self (self1, self2) result(div) Divide self for self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) procedure, private, pass(self ) :: self_div_ScalR8P private elemental function self_div_ScalR8P (self, scal) result(div) Divide self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_div_ScalR4P private elemental function self_div_ScalR4P (self, scal) result(div) Divide self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_div_ScalI8P private elemental function self_div_ScalI8P (self, scal) result(div) Divide self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_div_ScalI4P private elemental function self_div_ScalI4P (self, scal) result(div) Divide self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_div_ScalI2P private elemental function self_div_ScalI2P (self, scal) result(div) Divide self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_div_ScalI1P private elemental function self_div_ScalI1P (self, scal) result(div) Divide self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) generic, public :: operator(+) => positive_self , self_sum_self , ScalR8P_sum_self , self_sum_ScalR8P , ScalR4P_sum_self , self_sum_ScalR4P , ScalI8P_sum_self , self_sum_ScalI8P , ScalI4P_sum_self , self_sum_ScalI4P , ScalI2P_sum_self , self_sum_ScalI2P , ScalI1P_sum_self , self_sum_ScalI1P private elemental function positive_self (self) result(pos) Applay unary + to a self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_self (self1, self2) result(summ) Sum self and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) private elemental function ScalR8P_sum_self (scal, self) result(summ) Sum scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalR8P (self, scal) result(summ) Sum self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalR4P_sum_self (scal, self) result(summ) Sum scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalR4P (self, scal) result(summ) Sum self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI8P_sum_self (scal, self) result(summ) Sum scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalI8P (self, scal) result(summ) Sum self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI4P_sum_self (scal, self) result(summ) Sum scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalI4P (self, scal) result(summ) Sum self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI2P_sum_self (scal, self) result(summ) Sum scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalI2P (self, scal) result(summ) Sum self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI1P_sum_self (scal, self) result(summ) Sum scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalI1P (self, scal) result(summ) Sum self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: positive_self private elemental function positive_self (self) result(pos) Applay unary + to a self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self1) :: self_sum_self private elemental function self_sum_self (self1, self2) result(summ) Sum self and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) procedure, private, pass(self ) :: ScalR8P_sum_self private elemental function ScalR8P_sum_self (scal, self) result(summ) Sum scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalR4P_sum_self private elemental function ScalR4P_sum_self (scal, self) result(summ) Sum scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI8P_sum_self private elemental function ScalI8P_sum_self (scal, self) result(summ) Sum scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI4P_sum_self private elemental function ScalI4P_sum_self (scal, self) result(summ) Sum scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI2P_sum_self private elemental function ScalI2P_sum_self (scal, self) result(summ) Sum scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI1P_sum_self private elemental function ScalI1P_sum_self (scal, self) result(summ) Sum scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: self_sum_ScalR8P private elemental function self_sum_ScalR8P (self, scal) result(summ) Sum self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sum_ScalR4P private elemental function self_sum_ScalR4P (self, scal) result(summ) Sum self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sum_ScalI8P private elemental function self_sum_ScalI8P (self, scal) result(summ) Sum self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sum_ScalI4P private elemental function self_sum_ScalI4P (self, scal) result(summ) Sum self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sum_ScalI2P private elemental function self_sum_ScalI2P (self, scal) result(summ) Sum self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sum_ScalI1P private elemental function self_sum_ScalI1P (self, scal) result(summ) Sum self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) generic, public :: operator(-) => negative_self , self_sub_self , ScalR8P_sub_self , self_sub_ScalR8P , ScalR4P_sub_self , self_sub_ScalR4P , ScalI8P_sub_self , self_sub_ScalI8P , ScalI4P_sub_self , self_sub_ScalI4P , ScalI2P_sub_self , self_sub_ScalI2P , ScalI1P_sub_self , self_sub_ScalI1P private elemental function negative_self (self) result(neg) Applay unary - to a self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_self (self1, self2) result(sub) Subtract self and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) private elemental function ScalR8P_sub_self (scal, self) result(sub) Subtract scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalR8P (self, scal) result(sub) Subtract self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalR4P_sub_self (scal, self) result(sub) Subtract scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalR4P (self, scal) result(sub) Subtract self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI8P_sub_self (scal, self) result(sub) Subtract scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalI8P (self, scal) result(sub) Subtract self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI4P_sub_self (scal, self) result(sub) Subtract scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalI4P (self, scal) result(sub) Subtract self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI2P_sub_self (scal, self) result(sub) Subtract scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalI2P (self, scal) result(sub) Subtract self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI1P_sub_self (scal, self) result(sub) Subtract scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalI1P (self, scal) result(sub) Subtract self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: negative_self private elemental function negative_self (self) result(neg) Applay unary - to a self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self1) :: self_sub_self private elemental function self_sub_self (self1, self2) result(sub) Subtract self and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) procedure, private, pass(self ) :: ScalR8P_sub_self private elemental function ScalR8P_sub_self (scal, self) result(sub) Subtract scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalR4P_sub_self private elemental function ScalR4P_sub_self (scal, self) result(sub) Subtract scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI8P_sub_self private elemental function ScalI8P_sub_self (scal, self) result(sub) Subtract scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI4P_sub_self private elemental function ScalI4P_sub_self (scal, self) result(sub) Subtract scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI2P_sub_self private elemental function ScalI2P_sub_self (scal, self) result(sub) Subtract scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI1P_sub_self private elemental function ScalI1P_sub_self (scal, self) result(sub) Subtract scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: self_sub_ScalR8P private elemental function self_sub_ScalR8P (self, scal) result(sub) Subtract self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sub_ScalR4P private elemental function self_sub_ScalR4P (self, scal) result(sub) Subtract self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sub_ScalI8P private elemental function self_sub_ScalI8P (self, scal) result(sub) Subtract self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sub_ScalI4P private elemental function self_sub_ScalI4P (self, scal) result(sub) Subtract self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sub_ScalI2P private elemental function self_sub_ScalI2P (self, scal) result(sub) Subtract self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sub_ScalI1P private elemental function self_sub_ScalI1P (self, scal) result(sub) Subtract self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) generic, public :: operator(/=) => self_not_eq_self , R8P_not_eq_self , self_not_eq_R8P , R4P_not_eq_self , self_not_eq_R4P , I8P_not_eq_self , self_not_eq_I8P , I4P_not_eq_self , self_not_eq_I4P , I2P_not_eq_self , self_not_eq_I2P , I1P_not_eq_self , self_not_eq_I1P private elemental function self_not_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1\n and self2 are different, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 First selftor. type( Vector ), intent(in) :: self2 Second selftor. Return Value logical The result of the comparison. private elemental function R8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical generic, public :: operator(<) => self_low_self , R8P_low_self , self_low_R8P , R4P_low_self , self_low_R4P , I8P_low_self , self_low_I8P , I4P_low_self , self_low_I4P , I2P_low_self , self_low_I2P , I1P_low_self , self_low_I1P private elemental function self_low_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical private elemental function R8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical generic, public :: operator(<=) => self_low_eq_self , R8P_low_eq_self , self_low_eq_R8P , R4P_low_eq_self , self_low_eq_R4P , I8P_low_eq_self , self_low_eq_I8P , I4P_low_eq_self , self_low_eq_I4P , I2P_low_eq_self , self_low_eq_I2P , I1P_low_eq_self , self_low_eq_I1P private elemental function self_low_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical private elemental function R8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical generic, public :: operator(==) => self_eq_self , R8P_eq_self , self_eq_R8P , R4P_eq_self , self_eq_R4P , I8P_eq_self , self_eq_I8P , I4P_eq_self , self_eq_I4P , I2P_eq_self , self_eq_I2P , I1P_eq_self , self_eq_I1P private elemental function self_eq_self (self1, self2) result(compare) Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of\n self1 and self2 are the same, .false. otherwise. type( Vector ), intent(in) :: self2 Return Value logical private elemental function R8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_eq_self (scal, self) result(compare) @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical generic, public :: operator(>=) => self_great_eq_self , R8P_great_eq_self , self_great_eq_R8P , R4P_great_eq_self , self_great_eq_R4P , I8P_great_eq_self , self_great_eq_I8P , I4P_great_eq_self , self_great_eq_I4P , I2P_great_eq_self , self_great_eq_I2P , I1P_great_eq_self , self_great_eq_I1P private elemental function self_great_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical private elemental function R8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical generic, public :: operator(>) => self_great_self , R8P_great_self , self_great_R8P , R4P_great_self , self_great_R4P , I8P_great_self , self_great_I8P , I4P_great_self , self_great_I4P , I2P_great_self , self_great_I2P , I1P_great_self , self_great_I1P private elemental function self_great_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical private elemental function R8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical procedure, private, pass(self1) :: self_not_eq_self private elemental function self_not_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1\n and self2 are different, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 First selftor. type( Vector ), intent(in) :: self2 Second selftor. Return Value logical The result of the comparison. procedure, private, pass(self ) :: R8P_not_eq_self private elemental function R8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R4P_not_eq_self private elemental function R4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I8P_not_eq_self private elemental function I8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I4P_not_eq_self private elemental function I4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I2P_not_eq_self private elemental function I2P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I1P_not_eq_self private elemental function I1P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: self_not_eq_R8P private elemental function self_not_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_not_eq_R4P private elemental function self_not_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_not_eq_I8P private elemental function self_not_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_not_eq_I4P private elemental function self_not_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_not_eq_I2P private elemental function self_not_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_not_eq_I1P private elemental function self_not_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical procedure, private, pass(self1) :: self_low_self private elemental function self_low_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical procedure, private, pass(self ) :: R8P_low_self private elemental function R8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R4P_low_self private elemental function R4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I8P_low_self private elemental function I8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I4P_low_self private elemental function I4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I2P_low_self private elemental function I2P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I1P_low_self private elemental function I1P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: self_low_R8P private elemental function self_low_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_R4P private elemental function self_low_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_I8P private elemental function self_low_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_I4P private elemental function self_low_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_I2P private elemental function self_low_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_I1P private elemental function self_low_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical procedure, private, pass(self1) :: self_low_eq_self private elemental function self_low_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical procedure, private, pass(self ) :: R8P_low_eq_self private elemental function R8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R4P_low_eq_self private elemental function R4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I8P_low_eq_self private elemental function I8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I4P_low_eq_self private elemental function I4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I2P_low_eq_self private elemental function I2P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I1P_low_eq_self private elemental function I1P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: self_low_eq_R8P private elemental function self_low_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_eq_R4P private elemental function self_low_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_eq_I8P private elemental function self_low_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_eq_I4P private elemental function self_low_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_eq_I2P private elemental function self_low_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_eq_I1P private elemental function self_low_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical procedure, private, pass(self1) :: self_eq_self private elemental function self_eq_self (self1, self2) result(compare) Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of\n self1 and self2 are the same, .false. otherwise. type( Vector ), intent(in) :: self2 Return Value logical procedure, private, pass(self ) :: R8P_eq_self private elemental function R8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R4P_eq_self private elemental function R4P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I8P_eq_self private elemental function I8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I4P_eq_self private elemental function I4P_eq_self (scal, self) result(compare) @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I2P_eq_self private elemental function I2P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I1P_eq_self private elemental function I1P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: self_eq_R8P private elemental function self_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_eq_R4P private elemental function self_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_eq_I8P private elemental function self_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_eq_I4P private elemental function self_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_eq_I2P private elemental function self_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_eq_I1P private elemental function self_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical procedure, private, pass(self1) :: self_great_eq_self private elemental function self_great_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical procedure, private, pass(self ) :: R8P_great_eq_self private elemental function R8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R4P_great_eq_self private elemental function R4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I8P_great_eq_self private elemental function I8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I4P_great_eq_self private elemental function I4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I2P_great_eq_self private elemental function I2P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I1P_great_eq_self private elemental function I1P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: self_great_eq_R8P private elemental function self_great_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_eq_R4P private elemental function self_great_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_eq_I8P private elemental function self_great_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_eq_I4P private elemental function self_great_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_eq_I2P private elemental function self_great_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_eq_I1P private elemental function self_great_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical procedure, private, pass(self1) :: self_great_self private elemental function self_great_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical procedure, private, pass(self ) :: R8P_great_self private elemental function R8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R4P_great_self private elemental function R4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I8P_great_self private elemental function I8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I4P_great_self private elemental function I4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I2P_great_self private elemental function I2P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I1P_great_self private elemental function I1P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: self_great_R8P private elemental function self_great_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_R4P private elemental function self_great_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_I8P private elemental function self_great_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_I4P private elemental function self_great_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_I2P private elemental function self_great_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_I1P private elemental function self_great_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical Source Code type , public :: Vector !< Vector class. real ( R8P ) :: x = 0._R8P !< Cartesian component in x direction. real ( R8P ) :: y = 0._R8P !< Cartesian component in y direction. real ( R8P ) :: z = 0._R8P !< Cartesian component in z direction. contains procedure :: init => init_vector_self ! Procedure for initializing vector components. procedure :: set => set_vector_self ! Procedure for setting vector components. procedure :: iolen => iolen_vector_self ! Procedure for computing IO length. procedure :: load => load_vector_self ! Procedure for loading Vector data. procedure :: save => save_vector_self ! Procedure for saving Vector data. procedure :: print => print_vector_self ! Procedure for printing vector components with a \"pretty\" format. procedure :: sq_norm => sq_norm_self ! Procedure for computing the square of the norm of a vector. procedure :: normL2 => normL2_self ! Procedure for computing the norm L2 of a vector. procedure :: normalize => normalize_self ! Procedure for normalizing a vector. procedure :: normalized => normalized_self ! Procedure for obtaining a normalized copy of a vector. procedure :: face_normal4 => face_normal4_self ! Procedure for calculating the normal of the face defined by 4 points vector. procedure :: face_normal3 => face_normal3_self ! Procedure for calculating the normal of the face defined by 3 points vector. generic :: operator (. cross .) => crossproduct ! Procedure for computing the cross product of 2 vectors. generic :: operator (. dot .) => dotproduct ! Procedure for computing the scalar (dot) product of 2 vectors. generic :: operator (. paral .) => parallel ! Procedure for computing the component of vec1 parallel to vec2. generic :: operator (. ortho .) => orthogonal ! Procedure for computign the component of vec1 orthogonal to vec2. procedure , pass ( vec1 ), private :: crossproduct procedure , pass ( vec1 ), private :: dotproduct procedure , pass ( vec1 ), private :: parallel procedure , pass ( vec1 ), private :: orthogonal ! operators overloading generic :: assignment ( = ) => assign_self , & #ifdef r16p assign_ScalR16P ,& #endif assign_ScalR8P , assign_ScalR4P , assign_ScalI8P , assign_ScalI4P , assign_ScalI2P , assign_ScalI1P #ifdef r16p procedure , pass ( self ), private :: assign_ScalR16P #endif procedure , pass ( self1 ), private :: assign_self procedure , pass ( self ), private :: assign_ScalR8P procedure , pass ( self ), private :: assign_ScalR4P procedure , pass ( self ), private :: assign_ScalI8P procedure , pass ( self ), private :: assign_ScalI4P procedure , pass ( self ), private :: assign_ScalI2P procedure , pass ( self ), private :: assign_ScalI1P generic :: operator ( * ) => self_mul_self , & #ifdef r16p ScalR16P_mul_self , self_mul_ScalR16P , & #endif ScalR8P_mul_self , self_mul_ScalR8P , ScalR4P_mul_self , self_mul_ScalR4P , ScalI8P_mul_self , self_mul_ScalI8P ,& ScalI4P_mul_self , self_mul_ScalI4P , ScalI2P_mul_self , self_mul_ScalI2P , ScalI1P_mul_self , self_mul_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_mul_self procedure , pass ( self ), private :: self_mul_ScalR16P #endif procedure , pass ( self1 ), private :: self_mul_self procedure , pass ( self ), private :: ScalR8P_mul_self procedure , pass ( self ), private :: ScalR4P_mul_self procedure , pass ( self ), private :: ScalI8P_mul_self procedure , pass ( self ), private :: ScalI4P_mul_self procedure , pass ( self ), private :: ScalI2P_mul_self procedure , pass ( self ), private :: ScalI1P_mul_self procedure , pass ( self ), private :: self_mul_ScalR8P procedure , pass ( self ), private :: self_mul_ScalR4P procedure , pass ( self ), private :: self_mul_ScalI8P procedure , pass ( self ), private :: self_mul_ScalI4P procedure , pass ( self ), private :: self_mul_ScalI2P procedure , pass ( self ), private :: self_mul_ScalI1P generic :: operator ( / ) => self_div_self , & #ifdef r16p self_div_ScalR16P ,& #endif self_div_ScalR8P , self_div_ScalR4P , self_div_ScalI8P , self_div_ScalI4P , self_div_ScalI2P , self_div_ScalI1P #ifdef r16p procedure , pass ( self ), private :: self_div_ScalR16P #endif procedure , pass ( self1 ), private :: self_div_self procedure , pass ( self ), private :: self_div_ScalR8P procedure , pass ( self ), private :: self_div_ScalR4P procedure , pass ( self ), private :: self_div_ScalI8P procedure , pass ( self ), private :: self_div_ScalI4P procedure , pass ( self ), private :: self_div_ScalI2P procedure , pass ( self ), private :: self_div_ScalI1P generic :: operator ( + ) => positive_self , self_sum_self , & #ifdef r16p ScalR16P_sum_self , self_sum_ScalR16P , & #endif ScalR8P_sum_self , self_sum_ScalR8P , ScalR4P_sum_self , self_sum_ScalR4P , ScalI8P_sum_self , self_sum_ScalI8P ,& ScalI4P_sum_self , self_sum_ScalI4P , ScalI2P_sum_self , self_sum_ScalI2P , ScalI1P_sum_self , self_sum_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_sum_self procedure , pass ( self ), private :: self_sum_ScalR16P #endif procedure , pass ( self ), private :: positive_self procedure , pass ( self1 ), private :: self_sum_self procedure , pass ( self ), private :: ScalR8P_sum_self procedure , pass ( self ), private :: ScalR4P_sum_self procedure , pass ( self ), private :: ScalI8P_sum_self procedure , pass ( self ), private :: ScalI4P_sum_self procedure , pass ( self ), private :: ScalI2P_sum_self procedure , pass ( self ), private :: ScalI1P_sum_self procedure , pass ( self ), private :: self_sum_ScalR8P procedure , pass ( self ), private :: self_sum_ScalR4P procedure , pass ( self ), private :: self_sum_ScalI8P procedure , pass ( self ), private :: self_sum_ScalI4P procedure , pass ( self ), private :: self_sum_ScalI2P procedure , pass ( self ), private :: self_sum_ScalI1P generic :: operator ( - ) => negative_self , self_sub_self , & #ifdef r16p ScalR16P_sub_self , self_sub_ScalR16P , & #endif ScalR8P_sub_self , self_sub_ScalR8P , ScalR4P_sub_self , self_sub_ScalR4P , ScalI8P_sub_self , self_sub_ScalI8P ,& ScalI4P_sub_self , self_sub_ScalI4P , ScalI2P_sub_self , self_sub_ScalI2P , ScalI1P_sub_self , self_sub_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_sub_self procedure , pass ( self ), private :: self_sub_ScalR16P #endif procedure , pass ( self ), private :: negative_self procedure , pass ( self1 ), private :: self_sub_self procedure , pass ( self ), private :: ScalR8P_sub_self procedure , pass ( self ), private :: ScalR4P_sub_self procedure , pass ( self ), private :: ScalI8P_sub_self procedure , pass ( self ), private :: ScalI4P_sub_self procedure , pass ( self ), private :: ScalI2P_sub_self procedure , pass ( self ), private :: ScalI1P_sub_self procedure , pass ( self ), private :: self_sub_ScalR8P procedure , pass ( self ), private :: self_sub_ScalR4P procedure , pass ( self ), private :: self_sub_ScalI8P procedure , pass ( self ), private :: self_sub_ScalI4P procedure , pass ( self ), private :: self_sub_ScalI2P procedure , pass ( self ), private :: self_sub_ScalI1P generic :: operator ( /= ) => self_not_eq_self , & #ifdef r16p R16P_not_eq_self , self_not_eq_R16P , & #endif R8P_not_eq_self , self_not_eq_R8P , R4P_not_eq_self , self_not_eq_R4P , I8P_not_eq_self , self_not_eq_I8P ,& I4P_not_eq_self , self_not_eq_I4P , I2P_not_eq_self , self_not_eq_I2P , I1P_not_eq_self , self_not_eq_I1P generic :: operator ( < ) => self_low_self , & #ifdef r16p R16P_low_self , self_low_R16P , & #endif R8P_low_self , self_low_R8P , R4P_low_self , self_low_R4P , I8P_low_self , self_low_I8P ,& I4P_low_self , self_low_I4P , I2P_low_self , self_low_I2P , I1P_low_self , self_low_I1P generic :: operator ( <= ) => self_low_eq_self , & #ifdef r16p R16P_low_eq_self , self_low_eq_R16P , & #endif R8P_low_eq_self , self_low_eq_R8P , R4P_low_eq_self , self_low_eq_R4P , I8P_low_eq_self , self_low_eq_I8P ,& I4P_low_eq_self , self_low_eq_I4P , I2P_low_eq_self , self_low_eq_I2P , I1P_low_eq_self , self_low_eq_I1P generic :: operator ( == ) => self_eq_self , & #ifdef r16p R16P_eq_self , self_eq_R16P , & #endif R8P_eq_self , self_eq_R8P , R4P_eq_self , self_eq_R4P , I8P_eq_self , self_eq_I8P ,& I4P_eq_self , self_eq_I4P , I2P_eq_self , self_eq_I2P , I1P_eq_self , self_eq_I1P generic :: operator ( >= ) => self_great_eq_self , & #ifdef r16p R16P_great_eq_self , self_great_eq_R16P , & #endif R8P_great_eq_self , self_great_eq_R8P , R4P_great_eq_self , self_great_eq_R4P , I8P_great_eq_self ,& self_great_eq_I8P , I4P_great_eq_self , self_great_eq_I4P , I2P_great_eq_self , self_great_eq_I2P ,& I1P_great_eq_self , self_great_eq_I1P generic :: operator ( > ) => self_great_self , & #ifdef r16p R16P_great_self , self_great_R16P , & #endif R8P_great_self , self_great_R8P , R4P_great_self , self_great_R4P , I8P_great_self , self_great_I8P ,& I4P_great_self , self_great_I4P , I2P_great_self , self_great_I2P , I1P_great_self , self_great_I1P #ifdef r16p procedure , pass ( self ), private :: R16P_not_eq_self procedure , pass ( self ), private :: self_not_eq_R16P procedure , pass ( self ), private :: R16P_low_self procedure , pass ( self ), private :: self_low_R16P procedure , pass ( self ), private :: R16P_low_eq_self procedure , pass ( self ), private :: self_low_eq_R16P procedure , pass ( self ), private :: R16P_eq_self procedure , pass ( self ), private :: self_eq_R16P procedure , pass ( self ), private :: R16P_great_eq_self procedure , pass ( self ), private :: self_great_eq_R16P procedure , pass ( self ), private :: R16P_great_self procedure , pass ( self ), private :: self_great_R16P #endif procedure , pass ( self1 ), private :: self_not_eq_self procedure , pass ( self ), private :: R8P_not_eq_self procedure , pass ( self ), private :: R4P_not_eq_self procedure , pass ( self ), private :: I8P_not_eq_self procedure , pass ( self ), private :: I4P_not_eq_self procedure , pass ( self ), private :: I2P_not_eq_self procedure , pass ( self ), private :: I1P_not_eq_self procedure , pass ( self ), private :: self_not_eq_R8P procedure , pass ( self ), private :: self_not_eq_R4P procedure , pass ( self ), private :: self_not_eq_I8P procedure , pass ( self ), private :: self_not_eq_I4P procedure , pass ( self ), private :: self_not_eq_I2P procedure , pass ( self ), private :: self_not_eq_I1P procedure , pass ( self1 ), private :: self_low_self procedure , pass ( self ), private :: R8P_low_self procedure , pass ( self ), private :: R4P_low_self procedure , pass ( self ), private :: I8P_low_self procedure , pass ( self ), private :: I4P_low_self procedure , pass ( self ), private :: I2P_low_self procedure , pass ( self ), private :: I1P_low_self procedure , pass ( self ), private :: self_low_R8P procedure , pass ( self ), private :: self_low_R4P procedure , pass ( self ), private :: self_low_I8P procedure , pass ( self ), private :: self_low_I4P procedure , pass ( self ), private :: self_low_I2P procedure , pass ( self ), private :: self_low_I1P procedure , pass ( self1 ), private :: self_low_eq_self procedure , pass ( self ), private :: R8P_low_eq_self procedure , pass ( self ), private :: R4P_low_eq_self procedure , pass ( self ), private :: I8P_low_eq_self procedure , pass ( self ), private :: I4P_low_eq_self procedure , pass ( self ), private :: I2P_low_eq_self procedure , pass ( self ), private :: I1P_low_eq_self procedure , pass ( self ), private :: self_low_eq_R8P procedure , pass ( self ), private :: self_low_eq_R4P procedure , pass ( self ), private :: self_low_eq_I8P procedure , pass ( self ), private :: self_low_eq_I4P procedure , pass ( self ), private :: self_low_eq_I2P procedure , pass ( self ), private :: self_low_eq_I1P procedure , pass ( self1 ), private :: self_eq_self procedure , pass ( self ), private :: R8P_eq_self procedure , pass ( self ), private :: R4P_eq_self procedure , pass ( self ), private :: I8P_eq_self procedure , pass ( self ), private :: I4P_eq_self procedure , pass ( self ), private :: I2P_eq_self procedure , pass ( self ), private :: I1P_eq_self procedure , pass ( self ), private :: self_eq_R8P procedure , pass ( self ), private :: self_eq_R4P procedure , pass ( self ), private :: self_eq_I8P procedure , pass ( self ), private :: self_eq_I4P procedure , pass ( self ), private :: self_eq_I2P procedure , pass ( self ), private :: self_eq_I1P procedure , pass ( self1 ), private :: self_great_eq_self procedure , pass ( self ), private :: R8P_great_eq_self procedure , pass ( self ), private :: R4P_great_eq_self procedure , pass ( self ), private :: I8P_great_eq_self procedure , pass ( self ), private :: I4P_great_eq_self procedure , pass ( self ), private :: I2P_great_eq_self procedure , pass ( self ), private :: I1P_great_eq_self procedure , pass ( self ), private :: self_great_eq_R8P procedure , pass ( self ), private :: self_great_eq_R4P procedure , pass ( self ), private :: self_great_eq_I8P procedure , pass ( self ), private :: self_great_eq_I4P procedure , pass ( self ), private :: self_great_eq_I2P procedure , pass ( self ), private :: self_great_eq_I1P procedure , pass ( self1 ), private :: self_great_self procedure , pass ( self ), private :: R8P_great_self procedure , pass ( self ), private :: R4P_great_self procedure , pass ( self ), private :: I8P_great_self procedure , pass ( self ), private :: I4P_great_self procedure , pass ( self ), private :: I2P_great_self procedure , pass ( self ), private :: I1P_great_self procedure , pass ( self ), private :: self_great_R8P procedure , pass ( self ), private :: self_great_R4P procedure , pass ( self ), private :: self_great_I8P procedure , pass ( self ), private :: self_great_I4P procedure , pass ( self ), private :: self_great_I2P procedure , pass ( self ), private :: self_great_I1P endtype Vector","tags":"","loc":"type/vector.html","title":"Vector – FLOw "},{"text":"type, public :: Vector_Ptr type~~vector_ptr~~InheritsGraph type~vector_ptr Vector_Ptr type~vector Vector type~vector->type~vector_ptr p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Pointer of Vector for creating array of pointers of Vector. Variables p Source Code Vector_Ptr Components Type Visibility Attributes Name Initial type( Vector ), public, pointer :: p => null() Source Code type , public :: Vector_Ptr !< Pointer of Vector for creating array of pointers of Vector. type ( Vector ), pointer :: p => null () endtype Vector_Ptr","tags":"","loc":"type/vector_ptr.html","title":"Vector_Ptr – FLOw "},{"text":"abstract interface Assignment overloading. private pure subroutine abstract_assign(lhs, rhs) Arguments Type Intent Optional Attributes Name class( field_object ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Description Assign fields.","tags":"","loc":"interface/abstract_assign.html","title":"abstract_assign – FLOw"},{"text":"abstract interface Assignment overloading. private pure subroutine abstract_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( field_object ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign real to field.","tags":"","loc":"interface/abstract_assign_real.html","title":"abstract_assign_real – FLOw"},{"text":"abstract interface Symmetric operator field.op.field. private pure function abstract_simmetric_operator(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Description Symmetric operator field.op.field.","tags":"","loc":"interface/abstract_simmetric_operator.html","title":"abstract_simmetric_operator – FLOw"},{"text":"abstract interface Non symmetric operator integer.op.field. private pure function abstract_integer_op_field(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Description Non symmetric operator integer.op.field.","tags":"","loc":"interface/abstract_integer_op_field.html","title":"abstract_integer_op_field – FLOw"},{"text":"abstract interface Non symmetric operator field.op.integer. private pure function abstract_field_op_integer(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Description Non symmetric operator field.op.integer.","tags":"","loc":"interface/abstract_field_op_integer.html","title":"abstract_field_op_integer – FLOw"},{"text":"abstract interface Non symmetric operator field.op.real. private pure function abstract_field_op_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Description Non symmetric operator field.op.real.","tags":"","loc":"interface/abstract_field_op_real.html","title":"abstract_field_op_real – FLOw"},{"text":"abstract interface Non symmetric operator real.op.field. private pure function abstract_real_op_field(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Description Non symmetric operator real.op.field.","tags":"","loc":"interface/abstract_real_op_field.html","title":"abstract_real_op_field – FLOw"},{"text":"abstract interface Compare overloading. private pure function abstract_compare(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Description Compare overloading.","tags":"","loc":"interface/abstract_compare.html","title":"abstract_compare – FLOw"},{"text":"private pure function scalar_add_scalar(lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_add_scalar Source Code pure function scalar_add_scalar ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) select type ( rhs ) class is ( field_object_scalar ) opr % field = lhs % field + rhs % field endselect endselect endfunction scalar_add_scalar","tags":"","loc":"proc/scalar_add_scalar.html","title":"scalar_add_scalar – FLOw"},{"text":"private pure function scalar_div_scalar(lhs, rhs) result(opr) Divide fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_div_scalar Source Code pure function scalar_div_scalar ( lhs , rhs ) result ( opr ) !< Divide fields. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) select type ( rhs ) class is ( field_object_scalar ) opr % field = lhs % field / rhs % field endselect endselect endfunction scalar_div_scalar","tags":"","loc":"proc/scalar_div_scalar.html","title":"scalar_div_scalar – FLOw"},{"text":"private pure function scalar_div_integer(lhs, rhs) result(opr) Divide field by integer. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_div_integer Source Code pure function scalar_div_integer ( lhs , rhs ) result ( opr ) !< Divide field by integer. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs % field / rhs endselect endfunction scalar_div_integer","tags":"","loc":"proc/scalar_div_integer.html","title":"scalar_div_integer – FLOw"},{"text":"private pure function scalar_div_real(lhs, rhs) result(opr) Divide field by real. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_div_real Source Code pure function scalar_div_real ( lhs , rhs ) result ( opr ) !< Divide field by real. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs % field / rhs endselect endfunction scalar_div_real","tags":"","loc":"proc/scalar_div_real.html","title":"scalar_div_real – FLOw"},{"text":"private pure function scalar_mul_object(lhs, rhs) result(opr) Multiply fields. Note The combinations accepted are:\n+ field_object_scalar * field_object_vectorial => field_object_vectorial + field_object_scalar * field_object_scalar    => field_object_scalar Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_mul_object Source Code pure function scalar_mul_object ( lhs , rhs ) result ( opr ) !< Multiply fields. !< !< @note The combinations accepted are: !<+ `field_object_scalar * field_object_vectorial => field_object_vectorial` !<+ `field_object_scalar * field_object_scalar    => field_object_scalar` class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. select type ( rhs ) type is ( field_object_vectorial ) allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field = lhs % field * rhs % field endselect class is ( field_object_scalar ) allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs % field * rhs % field endselect endselect endfunction scalar_mul_object","tags":"","loc":"proc/scalar_mul_object.html","title":"scalar_mul_object – FLOw"},{"text":"private pure function scalar_mul_integer(lhs, rhs) result(opr) Multiply field for integer. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_mul_integer Source Code pure function scalar_mul_integer ( lhs , rhs ) result ( opr ) !< Multiply field for integer. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs % field * rhs endselect endfunction scalar_mul_integer","tags":"","loc":"proc/scalar_mul_integer.html","title":"scalar_mul_integer – FLOw"},{"text":"private pure function integer_mul_scalar(lhs, rhs) result(opr) Multiply integer for field. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: lhs Left hand side. class( field_object_scalar ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code integer_mul_scalar Source Code pure function integer_mul_scalar ( lhs , rhs ) result ( opr ) !< Multiply integer for field. integer ( I_P ), intent ( in ) :: lhs !< Left hand side. class ( field_object_scalar ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs * rhs % field endselect endfunction integer_mul_scalar","tags":"","loc":"proc/integer_mul_scalar.html","title":"integer_mul_scalar – FLOw"},{"text":"private pure function scalar_mul_real(lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_mul_real Source Code pure function scalar_mul_real ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs % field * rhs endselect endfunction scalar_mul_real","tags":"","loc":"proc/scalar_mul_real.html","title":"scalar_mul_real – FLOw"},{"text":"private pure function real_mul_scalar(lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_object_scalar ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code real_mul_scalar Source Code pure function real_mul_scalar ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_object_scalar ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs * rhs % field endselect endfunction real_mul_scalar","tags":"","loc":"proc/real_mul_scalar.html","title":"real_mul_scalar – FLOw"},{"text":"private pure function scalar_sub_scalar(lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_sub_scalar Source Code pure function scalar_sub_scalar ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) select type ( rhs ) class is ( field_object_scalar ) opr % field = lhs % field - rhs % field endselect endselect endfunction scalar_sub_scalar","tags":"","loc":"proc/scalar_sub_scalar.html","title":"scalar_sub_scalar – FLOw"},{"text":"private pure function scalar_pow_integer(lhs, rhs) result(opr) Power field by integer. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_pow_integer Source Code pure function scalar_pow_integer ( lhs , rhs ) result ( opr ) !< Power field by integer. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs % field ** rhs endselect endfunction scalar_pow_integer","tags":"","loc":"proc/scalar_pow_integer.html","title":"scalar_pow_integer – FLOw"},{"text":"private pure function scalar_pow_real(lhs, rhs) result(opr) Power field by real. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_pow_real Source Code pure function scalar_pow_real ( lhs , rhs ) result ( opr ) !< Power field by real. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_scalar :: opr ) select type ( opr ) class is ( field_object_scalar ) opr % field = lhs % field ** rhs endselect endfunction scalar_pow_real","tags":"","loc":"proc/scalar_pow_real.html","title":"scalar_pow_real – FLOw"},{"text":"private pure function eq_scalar(lhs, rhs) result(opr) Compare ( == ) fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code eq_scalar Source Code pure function eq_scalar ( lhs , rhs ) result ( opr ) !< Compare (`==`) fields. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . false . select type ( rhs ) class is ( field_object_scalar ) opr = lhs % field == rhs % field endselect endfunction eq_scalar","tags":"","loc":"proc/eq_scalar.html","title":"eq_scalar – FLOw"},{"text":"private pure function not_eq_scalar(lhs, rhs) result(opr) Compare ( /= ) fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code not_eq_scalar Source Code pure function not_eq_scalar ( lhs , rhs ) result ( opr ) !< Compare (`/=`) fields. class ( field_object_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . false . select type ( rhs ) class is ( field_object_scalar ) opr = lhs % field /= rhs % field endselect endfunction not_eq_scalar","tags":"","loc":"proc/not_eq_scalar.html","title":"not_eq_scalar – FLOw"},{"text":"private pure function vectorial_add_vectorial(lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_add_vectorial Source Code pure function vectorial_add_vectorial ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) select type ( rhs ) class is ( field_object_vectorial ) opr % field = lhs % field + rhs % field endselect endselect endfunction vectorial_add_vectorial","tags":"","loc":"proc/vectorial_add_vectorial.html","title":"vectorial_add_vectorial – FLOw"},{"text":"private pure function vectorial_div_object(lhs, rhs) result(opr) Divide fields. Note The combinations accepted are:\n+ field_object_vectorial / field_object_vectorial => field_object_vectorial + field_object_vectorial / field_object_scalar    => field_object_vectorial Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_div_object Source Code pure function vectorial_div_object ( lhs , rhs ) result ( opr ) !< Divide fields. !< !< @note The combinations accepted are: !<+ `field_object_vectorial / field_object_vectorial => field_object_vectorial` !<+ `field_object_vectorial / field_object_scalar    => field_object_vectorial` class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) select type ( rhs ) class is ( field_object_vectorial ) opr % field = lhs % field / rhs % field class is ( field_object_scalar ) opr % field = lhs % field / rhs % field endselect endselect endfunction vectorial_div_object","tags":"","loc":"proc/vectorial_div_object.html","title":"vectorial_div_object – FLOw"},{"text":"private pure function vectorial_div_integer(lhs, rhs) result(opr) Divide field by integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_div_integer Source Code pure function vectorial_div_integer ( lhs , rhs ) result ( opr ) !< Divide field by integer. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field = lhs % field / rhs endselect endfunction vectorial_div_integer","tags":"","loc":"proc/vectorial_div_integer.html","title":"vectorial_div_integer – FLOw"},{"text":"private pure function vectorial_div_real(lhs, rhs) result(opr) Divide field by real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_div_real Source Code pure function vectorial_div_real ( lhs , rhs ) result ( opr ) !< Divide field by real. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field = lhs % field / rhs endselect endfunction vectorial_div_real","tags":"","loc":"proc/vectorial_div_real.html","title":"vectorial_div_real – FLOw"},{"text":"private pure function vectorial_mul_object(lhs, rhs) result(opr) Multiply fields. Note The combinations accepted are:\n+ field_object_vectorial * field_object_vectorial => field_object_vectorial + field_object_vectorial * field_object_scalar    => field_object_vectorial Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_mul_object Source Code pure function vectorial_mul_object ( lhs , rhs ) result ( opr ) !< Multiply fields. !< !< @note The combinations accepted are: !<+ `field_object_vectorial * field_object_vectorial => field_object_vectorial` !<+ `field_object_vectorial * field_object_scalar    => field_object_vectorial` class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) select type ( rhs ) class is ( field_object_vectorial ) opr % field = lhs % field * rhs % field class is ( field_object_scalar ) opr % field = lhs % field * rhs % field endselect endselect endfunction vectorial_mul_object","tags":"","loc":"proc/vectorial_mul_object.html","title":"vectorial_mul_object – FLOw"},{"text":"private pure function vectorial_mul_integer(lhs, rhs) result(opr) Multiply field for integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_mul_integer Source Code pure function vectorial_mul_integer ( lhs , rhs ) result ( opr ) !< Multiply field for integer. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field = lhs % field * rhs endselect endfunction vectorial_mul_integer","tags":"","loc":"proc/vectorial_mul_integer.html","title":"vectorial_mul_integer – FLOw"},{"text":"private pure function integer_mul_vectorial(lhs, rhs) result(opr) Multiply integer for field. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: lhs Left hand side. class( field_object_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code integer_mul_vectorial Source Code pure function integer_mul_vectorial ( lhs , rhs ) result ( opr ) !< Multiply integer for field. integer ( I_P ), intent ( in ) :: lhs !< Left hand side. class ( field_object_vectorial ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field = lhs * rhs % field endselect endfunction integer_mul_vectorial","tags":"","loc":"proc/integer_mul_vectorial.html","title":"integer_mul_vectorial – FLOw"},{"text":"private pure function vectorial_mul_real(lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_mul_real Source Code pure function vectorial_mul_real ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field = lhs % field * rhs endselect endfunction vectorial_mul_real","tags":"","loc":"proc/vectorial_mul_real.html","title":"vectorial_mul_real – FLOw"},{"text":"private pure function real_mul_vectorial(lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_object_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code real_mul_vectorial Source Code pure function real_mul_vectorial ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_object_vectorial ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field = lhs * rhs % field endselect endfunction real_mul_vectorial","tags":"","loc":"proc/real_mul_vectorial.html","title":"real_mul_vectorial – FLOw"},{"text":"private pure function vectorial_sub_vectorial(lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_sub_vectorial Source Code pure function vectorial_sub_vectorial ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) select type ( rhs ) class is ( field_object_vectorial ) opr % field = lhs % field - rhs % field endselect endselect endfunction vectorial_sub_vectorial","tags":"","loc":"proc/vectorial_sub_vectorial.html","title":"vectorial_sub_vectorial – FLOw"},{"text":"private pure function vectorial_pow_integer(lhs, rhs) result(opr) Power field by integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_pow_integer Source Code pure function vectorial_pow_integer ( lhs , rhs ) result ( opr ) !< Power field by integer. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field % x = lhs % field % x ** rhs opr % field % y = lhs % field % y ** rhs opr % field % z = lhs % field % z ** rhs endselect endfunction vectorial_pow_integer","tags":"","loc":"proc/vectorial_pow_integer.html","title":"vectorial_pow_integer – FLOw"},{"text":"private pure function vectorial_pow_real(lhs, rhs) result(opr) Power field by real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_pow_real Source Code pure function vectorial_pow_real ( lhs , rhs ) result ( opr ) !< Power field by real. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_object_vectorial :: opr ) select type ( opr ) class is ( field_object_vectorial ) opr % field % x = lhs % field % x ** rhs opr % field % y = lhs % field % y ** rhs opr % field % z = lhs % field % z ** rhs endselect endfunction vectorial_pow_real","tags":"","loc":"proc/vectorial_pow_real.html","title":"vectorial_pow_real – FLOw"},{"text":"private pure function eq_vectorial(lhs, rhs) result(opr) Compare ( == ) fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code eq_vectorial Source Code pure function eq_vectorial ( lhs , rhs ) result ( opr ) !< Compare (`==`) fields. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . false . select type ( rhs ) class is ( field_object_vectorial ) opr = lhs % field == rhs % field endselect endfunction eq_vectorial","tags":"","loc":"proc/eq_vectorial.html","title":"eq_vectorial – FLOw"},{"text":"private pure function not_eq_vectorial(lhs, rhs) result(opr) Compare ( /= ) fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code not_eq_vectorial Source Code pure function not_eq_vectorial ( lhs , rhs ) result ( opr ) !< Compare (`/=`) fields. class ( field_object_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . false . select type ( rhs ) class is ( field_object_vectorial ) opr = lhs % field /= rhs % field endselect endfunction not_eq_vectorial","tags":"","loc":"proc/not_eq_vectorial.html","title":"not_eq_vectorial – FLOw"},{"text":"private pure subroutine assign_field_scalar(lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Source Code assign_field_scalar Source Code pure subroutine assign_field_scalar ( lhs , rhs ) !< Assign fields. class ( field_object_scalar ), intent ( inout ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( field_object_scalar ) lhs % field = rhs % field endselect endsubroutine assign_field_scalar","tags":"","loc":"proc/assign_field_scalar.html","title":"assign_field_scalar – FLOw"},{"text":"private pure subroutine assign_real_scalar(lhs, rhs) Assign real to field. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Source Code assign_real_scalar Source Code pure subroutine assign_real_scalar ( lhs , rhs ) !< Assign real to field. class ( field_object_scalar ), intent ( inout ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. lhs % field = rhs endsubroutine assign_real_scalar","tags":"","loc":"proc/assign_real_scalar.html","title":"assign_real_scalar – FLOw"},{"text":"private pure subroutine assign_field_vectorial(lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Source Code assign_field_vectorial Source Code pure subroutine assign_field_vectorial ( lhs , rhs ) !< Assign fields. class ( field_object_vectorial ), intent ( inout ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( field_object_vectorial ) lhs % field = rhs % field endselect endsubroutine assign_field_vectorial","tags":"","loc":"proc/assign_field_vectorial.html","title":"assign_field_vectorial – FLOw"},{"text":"private pure subroutine assign_real_vectorial(lhs, rhs) Assign real to field. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Source Code assign_real_vectorial Source Code pure subroutine assign_real_vectorial ( lhs , rhs ) !< Assign real to field. class ( field_object_vectorial ), intent ( inout ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. lhs % field = rhs endsubroutine assign_real_vectorial","tags":"","loc":"proc/assign_real_vectorial.html","title":"assign_real_vectorial – FLOw"},{"text":"private elemental function add(lhs, rhs) result(opr) Add primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. Source Code add Source Code elemental function add ( lhs , rhs ) result ( opr ) !< Add primitives. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. type ( primitive_object ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs % density + rhs % density opr % velocity = lhs % velocity + rhs % velocity opr % pressure = lhs % pressure + rhs % pressure if ( lhs . compatible . rhs ) then allocate ( opr % partial_densities ( 1 : size ( lhs % partial_densities , dim = 1 ))) do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs % partial_densities ( d ) + rhs % partial_densities ( d ) enddo endif endfunction add","tags":"","loc":"proc/add.html","title":"add – FLOw"},{"text":"private elemental function div(lhs, rhs) result(opr) Divide primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. Source Code div Source Code elemental function div ( lhs , rhs ) result ( opr ) !< Divide primitives. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. type ( primitive_object ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs % density / rhs % density opr % velocity = lhs % velocity / rhs % velocity opr % pressure = lhs % pressure / rhs % pressure if ( lhs . compatible . rhs ) then allocate ( opr % partial_densities ( 1 : size ( lhs % partial_densities , dim = 1 ))) do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs % partial_densities ( d ) / rhs % partial_densities ( d ) enddo endif endfunction div","tags":"","loc":"proc/div.html","title":"div – FLOw"},{"text":"private elemental function div_integer(lhs, rhs) result(opr) Divide primitive by integer. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. Source Code div_integer Source Code elemental function div_integer ( lhs , rhs ) result ( opr ) !< Divide primitive by integer. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs % density / rhs opr % velocity = lhs % velocity / rhs opr % pressure = lhs % pressure / rhs if ( allocated ( lhs % partial_densities )) then allocate ( opr % partial_densities ( 1 : size ( lhs % partial_densities , dim = 1 ))) do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs % partial_densities ( d ) / rhs enddo endif endfunction div_integer","tags":"","loc":"proc/div_integer.html","title":"div_integer – FLOw"},{"text":"private elemental function div_real(lhs, rhs) result(opr) Divide primitive by real. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. Source Code div_real Source Code elemental function div_real ( lhs , rhs ) result ( opr ) !< Divide primitive by real. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs % density / rhs opr % velocity = lhs % velocity / rhs opr % pressure = lhs % pressure / rhs if ( allocated ( lhs % partial_densities )) then allocate ( opr % partial_densities ( 1 : size ( lhs % partial_densities , dim = 1 ))) do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs % partial_densities ( d ) / rhs enddo endif endfunction div_real","tags":"","loc":"proc/div_real.html","title":"div_real – FLOw"},{"text":"private elemental function mul(lhs, rhs) result(opr) Multiply primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. Source Code mul Source Code elemental function mul ( lhs , rhs ) result ( opr ) !< Multiply primitives. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. type ( primitive_object ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs % density * rhs % density opr % velocity = lhs % velocity * rhs % velocity opr % pressure = lhs % pressure * rhs % pressure if ( lhs . compatible . rhs ) then allocate ( opr % partial_densities ( 1 : size ( lhs % partial_densities , dim = 1 ))) do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs % partial_densities ( d ) * rhs % partial_densities ( d ) enddo endif endfunction mul","tags":"","loc":"proc/mul.html","title":"mul – FLOw"},{"text":"private elemental function mul_integer(lhs, rhs) result(opr) Multiply primitive for integer. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. Source Code mul_integer Source Code elemental function mul_integer ( lhs , rhs ) result ( opr ) !< Multiply primitive for integer. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. integer ( I_P ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs % density * rhs opr % velocity = lhs % velocity * rhs opr % pressure = lhs % pressure * rhs if ( allocated ( lhs % partial_densities )) then allocate ( opr % partial_densities ( 1 : size ( lhs % partial_densities , dim = 1 ))) do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs % partial_densities ( d ) * rhs enddo endif endfunction mul_integer","tags":"","loc":"proc/mul_integer.html","title":"mul_integer – FLOw"},{"text":"private elemental function integer_mul(lhs, rhs) result(opr) Multiply integer for primitive. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. Source Code integer_mul Source Code elemental function integer_mul ( lhs , rhs ) result ( opr ) !< Multiply integer for primitive. integer ( I_P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs * rhs % density opr % velocity = lhs * rhs % velocity opr % pressure = lhs * rhs % pressure if ( allocated ( rhs % partial_densities )) then allocate ( opr % partial_densities ( 1 : size ( rhs % partial_densities , dim = 1 ))) do d = 1 , size ( rhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs * rhs % partial_densities ( d ) enddo endif endfunction integer_mul","tags":"","loc":"proc/integer_mul.html","title":"integer_mul – FLOw"},{"text":"private elemental function mul_real(lhs, rhs) result(opr) Multiply primitive for real. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. Source Code mul_real Source Code elemental function mul_real ( lhs , rhs ) result ( opr ) !< Multiply primitive for real. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs % density * rhs opr % velocity = lhs % velocity * rhs opr % pressure = lhs % pressure * rhs if ( allocated ( lhs % partial_densities )) then allocate ( opr % partial_densities ( 1 : size ( lhs % partial_densities , dim = 1 ))) do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs % partial_densities ( d ) * rhs enddo endif endfunction mul_real","tags":"","loc":"proc/mul_real.html","title":"mul_real – FLOw"},{"text":"private elemental function real_mul(lhs, rhs) result(opr) Multiply real for primitive. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. Source Code real_mul Source Code elemental function real_mul ( lhs , rhs ) result ( opr ) !< Multiply real for primitive. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs * rhs % density opr % velocity = lhs * rhs % velocity opr % pressure = lhs * rhs % pressure if ( allocated ( rhs % partial_densities )) then allocate ( opr % partial_densities ( 1 : size ( rhs % partial_densities , dim = 1 ))) do d = 1 , size ( rhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs * rhs % partial_densities ( d ) enddo endif endfunction real_mul","tags":"","loc":"proc/real_mul.html","title":"real_mul – FLOw"},{"text":"private elemental function sub(lhs, rhs) result(opr) Subtract primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. Source Code sub Source Code elemental function sub ( lhs , rhs ) result ( opr ) !< Subtract primitives. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. type ( primitive_object ), intent ( in ) :: rhs !< Right hand side. type ( primitive_object ) :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr % density = lhs % density - rhs % density opr % velocity = lhs % velocity - rhs % velocity opr % pressure = lhs % pressure - rhs % pressure if ( lhs . compatible . rhs ) then allocate ( opr % partial_densities ( 1 : size ( lhs % partial_densities , dim = 1 ))) do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr % partial_densities ( d ) = lhs % partial_densities ( d ) - rhs % partial_densities ( d ) enddo endif endfunction sub","tags":"","loc":"proc/sub.html","title":"sub – FLOw"},{"text":"private pure function eq(lhs, rhs) result(opr) Compare ( == ) primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code eq Source Code pure function eq ( lhs , rhs ) result ( opr ) !< Compare (`==`) primitives. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. type ( primitive_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. integer ( I_P ) :: d !< Counter. opr = lhs % density == rhs % density if ( opr ) opr = lhs % velocity == rhs % velocity if ( opr ) opr = lhs % pressure == rhs % pressure if ( opr . and . allocated ( lhs % partial_densities ). and . allocated ( rhs % partial_densities )) then if ( opr ) opr = lhs . compatible . rhs if ( opr ) then do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr = lhs % partial_densities ( d ) == rhs % partial_densities ( d ) if (. not . opr ) exit enddo endif elseif ( opr . and . allocated ( lhs % partial_densities ). and .(. not . allocated ( rhs % partial_densities ))) then opr = . false . elseif ( opr . and .(. not . allocated ( lhs % partial_densities )). and . allocated ( rhs % partial_densities )) then opr = . false . endif endfunction eq","tags":"","loc":"proc/eq.html","title":"eq – FLOw"},{"text":"private pure function not_eq(lhs, rhs) result(opr) Compare ( /= ) primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code not_eq Source Code pure function not_eq ( lhs , rhs ) result ( opr ) !< Compare (`/=`) primitives. class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. type ( primitive_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . not .( lhs % eq ( rhs = rhs )) endfunction not_eq","tags":"","loc":"proc/not_eq.html","title":"not_eq – FLOw"},{"text":"private pure function compatible(lhs, rhs) result(opr) Check primitives compatibility (size of partial densities). Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code compatible Source Code pure function compatible ( lhs , rhs ) result ( opr ) !< Check primitives compatibility (size of partial densities). class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. type ( primitive_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = allocated ( lhs % partial_densities ). and . allocated ( rhs % partial_densities ) if ( opr ) opr = size ( lhs % partial_densities , dim = 1 ) == size ( rhs % partial_densities , dim = 1 ) endfunction compatible","tags":"","loc":"proc/compatible.html","title":"compatible – FLOw"},{"text":"private pure subroutine assign_primitive(lhs, rhs) Assign primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Source Code assign_primitive Source Code pure subroutine assign_primitive ( lhs , rhs ) !< Assign primitives. class ( primitive_object ), intent ( inout ) :: lhs !< Left hand side. type ( primitive_object ), intent ( in ) :: rhs !< Right hand side. lhs % density = rhs % density lhs % velocity = rhs % velocity lhs % pressure = rhs % pressure if ( allocated ( rhs % partial_densities )) lhs % partial_densities = rhs % partial_densities endsubroutine assign_primitive","tags":"","loc":"proc/assign_primitive.html","title":"assign_primitive – FLOw"},{"text":"private pure subroutine assign_real(lhs, rhs) Assign real to primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Source Code assign_real Source Code pure subroutine assign_real ( lhs , rhs ) !< Assign real to primitive. class ( primitive_object ), intent ( inout ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. integer ( I_P ) :: d !< Counter. lhs % density = rhs lhs % velocity = rhs lhs % pressure = rhs if ( allocated ( lhs % partial_densities )) then do d = 1 , size ( lhs % partial_densities , dim = 1 ) lhs % partial_densities ( d ) = rhs enddo endif endsubroutine assign_real","tags":"","loc":"proc/assign_real.html","title":"assign_real – FLOw"},{"text":"subroutine print_error(test, is_test_passed) Print error message if test is failed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test Test description. logical, intent(in) :: is_test_passed Test result. Called By proc~~print_error~~CalledByGraph proc~print_error print_error program~flow_test_primitive_div flow_test_primitive_div program~flow_test_primitive_div->proc~print_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code print_error Source Code subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive1 % partial_densities ( 1 )% field , primitive1 % partial_densities ( 2 )% field print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive2 % partial_densities ( 1 )% field , primitive2 % partial_densities ( 2 )% field print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field endif endsubroutine print_error","tags":"","loc":"proc/print_error.html","title":"print_error – FLOw"},{"text":"subroutine print_error(test, is_test_passed) Print error message if test is failed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test Test description. logical, intent(in) :: is_test_passed Test result. Called By proc~~print_error~2~~CalledByGraph proc~print_error~2 print_error program~flow_test_primitive_mul flow_test_primitive_mul program~flow_test_primitive_mul->proc~print_error~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code print_error Source Code subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive1 % partial_densities ( 1 )% field , primitive1 % partial_densities ( 2 )% field print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive2 % partial_densities ( 1 )% field , primitive2 % partial_densities ( 2 )% field print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field endif endsubroutine print_error","tags":"","loc":"proc/print_error~2.html","title":"print_error – FLOw"},{"text":"private elemental function digit_I8(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i8~~CalledByGraph proc~digit_i8 digit_I8 interface~digit digit interface~digit->proc~digit_i8 program~test_all test_all program~test_all->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I8 Source Code elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8","tags":"","loc":"proc/digit_i8.html","title":"digit_I8 – FLOw"},{"text":"private elemental function digit_I4(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i4~~CalledByGraph proc~digit_i4 digit_I4 interface~digit digit interface~digit->proc~digit_i4 program~test_all test_all program~test_all->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I4 Source Code elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4","tags":"","loc":"proc/digit_i4.html","title":"digit_I4 – FLOw"},{"text":"private elemental function digit_I2(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i2~~CalledByGraph proc~digit_i2 digit_I2 interface~digit digit interface~digit->proc~digit_i2 program~test_all test_all program~test_all->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I2 Source Code elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2","tags":"","loc":"proc/digit_i2.html","title":"digit_I2 – FLOw"},{"text":"private elemental function digit_I1(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i1~~CalledByGraph proc~digit_i1 digit_I1 interface~digit digit interface~digit->proc~digit_i1 program~test_all test_all program~test_all->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I1 Source Code elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1","tags":"","loc":"proc/digit_i1.html","title":"digit_I1 – FLOw"},{"text":"public subroutine check_endian() Check the type of bit ordering (big or little endian) of the running architecture. Note The result is stored into the endian global variable. Arguments None Called By proc~~check_endian~~CalledByGraph proc~check_endian check_endian proc~penf_init penf_init proc~penf_init->proc~check_endian program~compact_real compact_real program~compact_real->proc~penf_init program~test_all test_all program~test_all->proc~penf_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code check_endian Source Code subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian","tags":"","loc":"proc/check_endian.html","title":"check_endian – FLOw"},{"text":"public subroutine penf_init() Initialize PENF's variables that are not initialized into the definition specification. Arguments None Calls proc~~penf_init~~CallsGraph proc~penf_init penf_init proc~check_endian check_endian proc~penf_init->proc~check_endian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~penf_init~~CalledByGraph proc~penf_init penf_init program~compact_real compact_real program~compact_real->proc~penf_init program~test_all test_all program~test_all->proc~penf_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code penf_init Source Code subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init","tags":"","loc":"proc/penf_init.html","title":"penf_init – FLOw"},{"text":"public subroutine penf_print(unit, pref, iostat, iomsg) Print to the specified unit the PENF's environment data. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Called By proc~~penf_print~~CalledByGraph proc~penf_print penf_print program~test_all test_all program~test_all->proc~penf_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code penf_print Source Code subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print","tags":"","loc":"proc/penf_print.html","title":"penf_print – FLOw"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables.","tags":"","loc":"interface/bit_size.html","title":"bit_size – FLOw"},{"text":"public interface digit Compute the number of digits in decimal base of the input integer. Calls interface~~digit~~CallsGraph interface~digit digit proc~digit_i8 digit_I8 interface~digit->proc~digit_i8 proc~digit_i1 digit_I1 interface~digit->proc~digit_i1 proc~digit_i4 digit_I4 interface~digit->proc~digit_i4 proc~digit_i2 digit_I2 interface~digit->proc~digit_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~digit~~CalledByGraph interface~digit digit program~test_all test_all program~test_all->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures digit_I8 digit_I4 digit_I2 digit_I1 Module Procedures private elemental function digit_I8 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I4 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I2 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I1 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits.","tags":"","loc":"interface/digit.html","title":"digit – FLOw"},{"text":"private elemental function bit_size_R16P(i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Source Code bit_size_R16P Source Code elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P","tags":"","loc":"proc/bit_size_r16p.html","title":"bit_size_R16P – FLOw"},{"text":"private elemental function bit_size_R8P(i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Called By proc~~bit_size_r8p~~CalledByGraph proc~bit_size_r8p bit_size_R8P interface~bit_size~2 bit_size interface~bit_size~2->proc~bit_size_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bit_size_R8P Source Code elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P","tags":"","loc":"proc/bit_size_r8p.html","title":"bit_size_R8P – FLOw"},{"text":"private elemental function bit_size_R4P(i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Called By proc~~bit_size_r4p~~CalledByGraph proc~bit_size_r4p bit_size_R4P interface~bit_size~2 bit_size interface~bit_size~2->proc~bit_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bit_size_R4P Source Code elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P","tags":"","loc":"proc/bit_size_r4p.html","title":"bit_size_R4P – FLOw"},{"text":"private elemental function bit_size_chr(i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Called By proc~~bit_size_chr~~CalledByGraph proc~bit_size_chr bit_size_chr interface~bit_size~2 bit_size interface~bit_size~2->proc~bit_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bit_size_chr Source Code elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr","tags":"","loc":"proc/bit_size_chr.html","title":"bit_size_chr – FLOw"},{"text":"private elemental function byte_size_I8P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i8p~~CalledByGraph proc~byte_size_i8p byte_size_I8P interface~byte_size byte_size interface~byte_size->proc~byte_size_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I8P Source Code elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P","tags":"","loc":"proc/byte_size_i8p.html","title":"byte_size_I8P – FLOw"},{"text":"private elemental function byte_size_I4P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i4p~~CalledByGraph proc~byte_size_i4p byte_size_I4P interface~byte_size byte_size interface~byte_size->proc~byte_size_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I4P Source Code elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P","tags":"","loc":"proc/byte_size_i4p.html","title":"byte_size_I4P – FLOw"},{"text":"private elemental function byte_size_I2P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i2p~~CalledByGraph proc~byte_size_i2p byte_size_I2P interface~byte_size byte_size interface~byte_size->proc~byte_size_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I2P Source Code elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P","tags":"","loc":"proc/byte_size_i2p.html","title":"byte_size_I2P – FLOw"},{"text":"private elemental function byte_size_I1P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i1p~~CalledByGraph proc~byte_size_i1p byte_size_I1P interface~byte_size byte_size interface~byte_size->proc~byte_size_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I1P Source Code elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P","tags":"","loc":"proc/byte_size_i1p.html","title":"byte_size_I1P – FLOw"},{"text":"private elemental function byte_size_R16P(i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Source Code byte_size_R16P Source Code elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P","tags":"","loc":"proc/byte_size_r16p.html","title":"byte_size_R16P – FLOw"},{"text":"private elemental function byte_size_R8P(i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Called By proc~~byte_size_r8p~~CalledByGraph proc~byte_size_r8p byte_size_R8P interface~byte_size byte_size interface~byte_size->proc~byte_size_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_R8P Source Code elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P","tags":"","loc":"proc/byte_size_r8p.html","title":"byte_size_R8P – FLOw"},{"text":"private elemental function byte_size_R4P(i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Called By proc~~byte_size_r4p~~CalledByGraph proc~byte_size_r4p byte_size_R4P interface~byte_size byte_size interface~byte_size->proc~byte_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_R4P Source Code elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P","tags":"","loc":"proc/byte_size_r4p.html","title":"byte_size_R4P – FLOw"},{"text":"private elemental function byte_size_chr(i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Called By proc~~byte_size_chr~~CalledByGraph proc~byte_size_chr byte_size_chr interface~byte_size byte_size interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_chr Source Code elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr","tags":"","loc":"proc/byte_size_chr.html","title":"byte_size_chr – FLOw"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. Calls interface~~bit_size~2~~CallsGraph interface~bit_size~2 bit_size proc~bit_size_r8p bit_size_R8P interface~bit_size~2->proc~bit_size_r8p proc~bit_size_r4p bit_size_R4P interface~bit_size~2->proc~bit_size_r4p proc~bit_size_chr bit_size_chr interface~bit_size~2->proc~bit_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures bit_size_R8P bit_size_R4P bit_size_chr Module Procedures private elemental function bit_size_R8P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_R4P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_chr (i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c.","tags":"","loc":"interface/bit_size~2.html","title":"bit_size – FLOw"},{"text":"public interface byte_size Compute the number of bytes of a variable. Calls interface~~byte_size~~CallsGraph interface~byte_size byte_size proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures byte_size_I8P byte_size_I4P byte_size_I2P byte_size_I1P byte_size_R8P byte_size_R4P byte_size_chr Module Procedures private elemental function byte_size_I8P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I4P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I2P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I1P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_R8P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R4P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_chr (i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c.","tags":"","loc":"interface/byte_size.html","title":"byte_size – FLOw"},{"text":"private elemental function strf_R16P(fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Source Code strf_R16P Source Code elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P","tags":"","loc":"proc/strf_r16p.html","title":"strf_R16P – FLOw"},{"text":"private elemental function strf_R8P(fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Called By proc~~strf_r8p~~CalledByGraph proc~strf_r8p strf_R8P interface~str str interface~str->proc~strf_r8p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_R8P Source Code elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P","tags":"","loc":"proc/strf_r8p.html","title":"strf_R8P – FLOw"},{"text":"private elemental function strf_R4P(fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Called By proc~~strf_r4p~~CalledByGraph proc~strf_r4p strf_R4P interface~str str interface~str->proc~strf_r4p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_R4P Source Code elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P","tags":"","loc":"proc/strf_r4p.html","title":"strf_R4P – FLOw"},{"text":"private elemental function strf_I8P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Called By proc~~strf_i8p~~CalledByGraph proc~strf_i8p strf_I8P interface~str str interface~str->proc~strf_i8p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I8P Source Code elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P","tags":"","loc":"proc/strf_i8p.html","title":"strf_I8P – FLOw"},{"text":"private elemental function strf_I4P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Called By proc~~strf_i4p~~CalledByGraph proc~strf_i4p strf_I4P interface~str str interface~str->proc~strf_i4p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I4P Source Code elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P","tags":"","loc":"proc/strf_i4p.html","title":"strf_I4P – FLOw"},{"text":"private elemental function strf_I2P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Called By proc~~strf_i2p~~CalledByGraph proc~strf_i2p strf_I2P interface~str str interface~str->proc~strf_i2p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I2P Source Code elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P","tags":"","loc":"proc/strf_i2p.html","title":"strf_I2P – FLOw"},{"text":"private elemental function strf_I1P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Called By proc~~strf_i1p~~CalledByGraph proc~strf_i1p strf_I1P interface~str str interface~str->proc~strf_i1p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I1P Source Code elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P","tags":"","loc":"proc/strf_i1p.html","title":"strf_I1P – FLOw"},{"text":"private elemental function str_R16P(n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR16P) Returned string containing input number. Calls proc~~str_r16p~~CallsGraph proc~str_r16p str_R16P proc~compact_real_string compact_real_string proc~str_r16p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_r16p~~CalledByGraph proc~str_r16p str_R16P proc~str_a_r16p str_a_R16P proc~str_a_r16p->proc~str_r16p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_R16P Source Code elemental function str_R16P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P","tags":"","loc":"proc/str_r16p.html","title":"str_R16P – FLOw"},{"text":"private elemental function str_R8P(n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. Calls proc~~str_r8p~~CallsGraph proc~str_r8p str_R8P proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_r8p~~CalledByGraph proc~str_r8p str_R8P proc~str_a_r8p str_a_R8P proc~str_a_r8p->proc~str_r8p interface~str str interface~str->proc~str_r8p interface~str->proc~str_a_r8p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_R8P Source Code elemental function str_R8P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P","tags":"","loc":"proc/str_r8p.html","title":"str_R8P – FLOw"},{"text":"private elemental function str_R4P(n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. Calls proc~~str_r4p~~CallsGraph proc~str_r4p str_R4P proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_r4p~~CalledByGraph proc~str_r4p str_R4P proc~str_a_r4p str_a_R4P proc~str_a_r4p->proc~str_r4p interface~str str interface~str->proc~str_r4p interface~str->proc~str_a_r4p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_R4P Source Code elemental function str_R4P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P","tags":"","loc":"proc/str_r4p.html","title":"str_R4P – FLOw"},{"text":"private elemental function str_I8P(n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Called By proc~~str_i8p~~CalledByGraph proc~str_i8p str_I8P proc~str_a_i8p str_a_I8P proc~str_a_i8p->proc~str_i8p interface~str str interface~str->proc~str_i8p interface~str->proc~str_a_i8p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I8P Source Code elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P","tags":"","loc":"proc/str_i8p.html","title":"str_I8P – FLOw"},{"text":"private elemental function str_I4P(n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Called By proc~~str_i4p~~CalledByGraph proc~str_i4p str_I4P proc~str_a_i4p str_a_I4P proc~str_a_i4p->proc~str_i4p interface~str str interface~str->proc~str_i4p interface~str->proc~str_a_i4p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I4P Source Code elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P","tags":"","loc":"proc/str_i4p.html","title":"str_I4P – FLOw"},{"text":"private elemental function str_I2P(n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Called By proc~~str_i2p~~CalledByGraph proc~str_i2p str_I2P proc~str_a_i2p str_a_I2P proc~str_a_i2p->proc~str_i2p interface~str str interface~str->proc~str_i2p interface~str->proc~str_a_i2p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I2P Source Code elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P","tags":"","loc":"proc/str_i2p.html","title":"str_I2P – FLOw"},{"text":"private elemental function str_I1P(n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Called By proc~~str_i1p~~CalledByGraph proc~str_i1p str_I1P proc~str_a_i1p str_a_I1P proc~str_a_i1p->proc~str_i1p interface~str str interface~str->proc~str_i1p interface~str->proc~str_a_i1p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I1P Source Code elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P","tags":"","loc":"proc/str_i1p.html","title":"str_I1P – FLOw"},{"text":"private elemental function str_bol(n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Called By proc~~str_bol~~CalledByGraph proc~str_bol str_bol interface~str str interface~str->proc~str_bol proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_bol Source Code elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol","tags":"","loc":"proc/str_bol.html","title":"str_bol – FLOw"},{"text":"private pure function str_a_R16P(n, no_sign, separator, delimiters, compact) result(str) Converting real array to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator (1) Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_r16p~~CallsGraph proc~str_a_r16p str_a_R16P proc~str_r16p str_R16P proc~str_a_r16p->proc~str_r16p proc~compact_real_string compact_real_string proc~str_r16p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_R16P Source Code pure function str_a_R16P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator ( 1 ) !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator ( 1 ) do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P","tags":"","loc":"proc/str_a_r16p.html","title":"str_a_R16P – FLOw"},{"text":"private pure function str_a_R8P(n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_r8p~~CallsGraph proc~str_a_r8p str_a_R8P proc~str_r8p str_R8P proc~str_a_r8p->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_r8p~~CalledByGraph proc~str_a_r8p str_a_R8P interface~str str interface~str->proc~str_a_r8p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_R8P Source Code pure function str_a_R8P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P","tags":"","loc":"proc/str_a_r8p.html","title":"str_a_R8P – FLOw"},{"text":"private pure function str_a_R4P(n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_r4p~~CallsGraph proc~str_a_r4p str_a_R4P proc~str_r4p str_R4P proc~str_a_r4p->proc~str_r4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_r4p~~CalledByGraph proc~str_a_r4p str_a_R4P interface~str str interface~str->proc~str_a_r4p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_R4P Source Code pure function str_a_R4P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P","tags":"","loc":"proc/str_a_r4p.html","title":"str_a_R4P – FLOw"},{"text":"private pure function str_a_I8P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i8p~~CallsGraph proc~str_a_i8p str_a_I8P proc~str_i8p str_I8P proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i8p~~CalledByGraph proc~str_a_i8p str_a_I8P interface~str str interface~str->proc~str_a_i8p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I8P Source Code pure function str_a_I8P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P","tags":"","loc":"proc/str_a_i8p.html","title":"str_a_I8P – FLOw"},{"text":"private pure function str_a_I4P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i4p~~CallsGraph proc~str_a_i4p str_a_I4P proc~str_i4p str_I4P proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i4p~~CalledByGraph proc~str_a_i4p str_a_I4P interface~str str interface~str->proc~str_a_i4p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I4P Source Code pure function str_a_I4P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P","tags":"","loc":"proc/str_a_i4p.html","title":"str_a_I4P – FLOw"},{"text":"private pure function str_a_I2P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i2p~~CallsGraph proc~str_a_i2p str_a_I2P proc~str_i2p str_I2P proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i2p~~CalledByGraph proc~str_a_i2p str_a_I2P interface~str str interface~str->proc~str_a_i2p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I2P Source Code pure function str_a_I2P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P","tags":"","loc":"proc/str_a_i2p.html","title":"str_a_I2P – FLOw"},{"text":"private pure function str_a_I1P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i1p~~CallsGraph proc~str_a_i1p str_a_I1P proc~str_i1p str_I1P proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i1p~~CalledByGraph proc~str_a_i1p str_a_I1P interface~str str interface~str->proc~str_a_i1p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I1P Source Code pure function str_a_I1P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P","tags":"","loc":"proc/str_a_i1p.html","title":"str_a_I1P – FLOw"},{"text":"private elemental function strz_I8P(n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Called By proc~~strz_i8p~~CalledByGraph proc~strz_i8p strz_I8P interface~strz strz interface~strz->proc~strz_i8p program~test_all test_all program~test_all->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I8P Source Code elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P","tags":"","loc":"proc/strz_i8p.html","title":"strz_I8P – FLOw"},{"text":"private elemental function strz_I4P(n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Called By proc~~strz_i4p~~CalledByGraph proc~strz_i4p strz_I4P interface~strz strz interface~strz->proc~strz_i4p program~test_all test_all program~test_all->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I4P Source Code elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P","tags":"","loc":"proc/strz_i4p.html","title":"strz_I4P – FLOw"},{"text":"private elemental function strz_I2P(n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Called By proc~~strz_i2p~~CalledByGraph proc~strz_i2p strz_I2P interface~strz strz interface~strz->proc~strz_i2p program~test_all test_all program~test_all->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I2P Source Code elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P","tags":"","loc":"proc/strz_i2p.html","title":"strz_I2P – FLOw"},{"text":"private elemental function strz_I1P(n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Called By proc~~strz_i1p~~CalledByGraph proc~strz_i1p strz_I1P interface~strz strz interface~strz->proc~strz_i1p program~test_all test_all program~test_all->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I1P Source Code elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P","tags":"","loc":"proc/strz_i1p.html","title":"strz_I1P – FLOw"},{"text":"private function ctor_R16P(str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Source Code ctor_R16P Source Code function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P","tags":"","loc":"proc/ctor_r16p.html","title":"ctor_R16P – FLOw"},{"text":"private function ctor_R8P(str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Called By proc~~ctor_r8p~~CalledByGraph proc~ctor_r8p ctor_R8P interface~cton cton interface~cton->proc~ctor_r8p program~test_all test_all program~test_all->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctor_R8P Source Code function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P","tags":"","loc":"proc/ctor_r8p.html","title":"ctor_R8P – FLOw"},{"text":"private function ctor_R4P(str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Called By proc~~ctor_r4p~~CalledByGraph proc~ctor_r4p ctor_R4P interface~cton cton interface~cton->proc~ctor_r4p program~test_all test_all program~test_all->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctor_R4P Source Code function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P","tags":"","loc":"proc/ctor_r4p.html","title":"ctor_R4P – FLOw"},{"text":"private function ctoi_I8P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Called By proc~~ctoi_i8p~~CalledByGraph proc~ctoi_i8p ctoi_I8P interface~cton cton interface~cton->proc~ctoi_i8p program~test_all test_all program~test_all->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I8P Source Code function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P","tags":"","loc":"proc/ctoi_i8p.html","title":"ctoi_I8P – FLOw"},{"text":"private function ctoi_I4P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Called By proc~~ctoi_i4p~~CalledByGraph proc~ctoi_i4p ctoi_I4P interface~cton cton interface~cton->proc~ctoi_i4p program~test_all test_all program~test_all->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I4P Source Code function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P","tags":"","loc":"proc/ctoi_i4p.html","title":"ctoi_I4P – FLOw"},{"text":"private function ctoi_I2P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Called By proc~~ctoi_i2p~~CalledByGraph proc~ctoi_i2p ctoi_I2P interface~cton cton interface~cton->proc~ctoi_i2p program~test_all test_all program~test_all->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I2P Source Code function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P","tags":"","loc":"proc/ctoi_i2p.html","title":"ctoi_I2P – FLOw"},{"text":"private function ctoi_I1P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Called By proc~~ctoi_i1p~~CalledByGraph proc~ctoi_i1p ctoi_I1P interface~cton cton interface~cton->proc~ctoi_i1p program~test_all test_all program~test_all->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I1P Source Code function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P","tags":"","loc":"proc/ctoi_i1p.html","title":"ctoi_I1P – FLOw"},{"text":"private elemental function bstr_R16P(n) result(bstr) Convert real to string of bits. Note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Source Code bstr_R16P Source Code elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P","tags":"","loc":"proc/bstr_r16p.html","title":"bstr_R16P – FLOw"},{"text":"private elemental function bstr_R8P(n) result(bstr) Convert real to string of bits. Note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Called By proc~~bstr_r8p~~CalledByGraph proc~bstr_r8p bstr_R8P interface~bstr bstr interface~bstr->proc~bstr_r8p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_R8P Source Code elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P","tags":"","loc":"proc/bstr_r8p.html","title":"bstr_R8P – FLOw"},{"text":"private elemental function bstr_R4P(n) result(bstr) Convert real to string of bits. Note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Called By proc~~bstr_r4p~~CalledByGraph proc~bstr_r4p bstr_R4P interface~bstr bstr interface~bstr->proc~bstr_r4p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_R4P Source Code elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P","tags":"","loc":"proc/bstr_r4p.html","title":"bstr_R4P – FLOw"},{"text":"private elemental function bstr_I8P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Called By proc~~bstr_i8p~~CalledByGraph proc~bstr_i8p bstr_I8P interface~bstr bstr interface~bstr->proc~bstr_i8p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I8P Source Code elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P","tags":"","loc":"proc/bstr_i8p.html","title":"bstr_I8P – FLOw"},{"text":"private elemental function bstr_I4P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Called By proc~~bstr_i4p~~CalledByGraph proc~bstr_i4p bstr_I4P interface~bstr bstr interface~bstr->proc~bstr_i4p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I4P Source Code elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P","tags":"","loc":"proc/bstr_i4p.html","title":"bstr_I4P – FLOw"},{"text":"private elemental function bstr_I2P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Called By proc~~bstr_i2p~~CalledByGraph proc~bstr_i2p bstr_I2P interface~bstr bstr interface~bstr->proc~bstr_i2p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I2P Source Code elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P","tags":"","loc":"proc/bstr_i2p.html","title":"bstr_I2P – FLOw"},{"text":"private elemental function bstr_I1P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Called By proc~~bstr_i1p~~CalledByGraph proc~bstr_i1p bstr_I1P interface~bstr bstr interface~bstr->proc~bstr_i1p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I1P Source Code elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P","tags":"","loc":"proc/bstr_i1p.html","title":"bstr_I1P – FLOw"},{"text":"private elemental function bctor_R16P(bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Calls proc~~bctor_r16p~~CallsGraph proc~bctor_r16p bctor_R16P interface~str str proc~bctor_r16p->interface~str proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctor_R16P Source Code elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P","tags":"","loc":"proc/bctor_r16p.html","title":"bctor_R16P – FLOw"},{"text":"private elemental function bctor_R8P(bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Calls proc~~bctor_r8p~~CallsGraph proc~bctor_r8p bctor_R8P interface~str str proc~bctor_r8p->interface~str proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctor_r8p~~CalledByGraph proc~bctor_r8p bctor_R8P interface~bcton bcton interface~bcton->proc~bctor_r8p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctor_R8P Source Code elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P","tags":"","loc":"proc/bctor_r8p.html","title":"bctor_R8P – FLOw"},{"text":"private elemental function bctor_R4P(bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Calls proc~~bctor_r4p~~CallsGraph proc~bctor_r4p bctor_R4P interface~str str proc~bctor_r4p->interface~str proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctor_r4p~~CalledByGraph proc~bctor_r4p bctor_R4P interface~bcton bcton interface~bcton->proc~bctor_r4p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctor_R4P Source Code elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P","tags":"","loc":"proc/bctor_r4p.html","title":"bctor_R4P – FLOw"},{"text":"private elemental function bctoi_I8P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Calls proc~~bctoi_i8p~~CallsGraph proc~bctoi_i8p bctoi_I8P interface~str str proc~bctoi_i8p->interface~str proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i8p~~CalledByGraph proc~bctoi_i8p bctoi_I8P interface~bcton bcton interface~bcton->proc~bctoi_i8p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I8P Source Code elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P","tags":"","loc":"proc/bctoi_i8p.html","title":"bctoi_I8P – FLOw"},{"text":"private elemental function bctoi_I4P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Calls proc~~bctoi_i4p~~CallsGraph proc~bctoi_i4p bctoi_I4P interface~str str proc~bctoi_i4p->interface~str proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i4p~~CalledByGraph proc~bctoi_i4p bctoi_I4P interface~bcton bcton interface~bcton->proc~bctoi_i4p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I4P Source Code elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P","tags":"","loc":"proc/bctoi_i4p.html","title":"bctoi_I4P – FLOw"},{"text":"private elemental function bctoi_I2P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Calls proc~~bctoi_i2p~~CallsGraph proc~bctoi_i2p bctoi_I2P interface~str str proc~bctoi_i2p->interface~str proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i2p~~CalledByGraph proc~bctoi_i2p bctoi_I2P interface~bcton bcton interface~bcton->proc~bctoi_i2p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I2P Source Code elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P","tags":"","loc":"proc/bctoi_i2p.html","title":"bctoi_I2P – FLOw"},{"text":"private elemental function bctoi_I1P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Calls proc~~bctoi_i1p~~CallsGraph proc~bctoi_i1p bctoi_I1P interface~str str proc~bctoi_i1p->interface~str proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i1p~~CalledByGraph proc~bctoi_i1p bctoi_I1P interface~bcton bcton interface~bcton->proc~bctoi_i1p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I1P Source Code elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P","tags":"","loc":"proc/bctoi_i1p.html","title":"bctoi_I1P – FLOw"},{"text":"private pure subroutine compact_real_string(string) Compact a string representing a real number, so that the same value is displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string string representation of a real number. Called By proc~~compact_real_string~~CalledByGraph proc~compact_real_string compact_real_string proc~str_r4p str_R4P proc~str_r4p->proc~compact_real_string proc~str_r16p str_R16P proc~str_r16p->proc~compact_real_string proc~str_r8p str_R8P proc~str_r8p->proc~compact_real_string proc~str_a_r4p str_a_R4P proc~str_a_r4p->proc~str_r4p interface~str str interface~str->proc~str_r4p interface~str->proc~str_r8p interface~str->proc~str_a_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p proc~str_a_r16p str_a_R16P proc~str_a_r16p->proc~str_r16p proc~str_a_r8p->proc~str_r8p var panproccompact_real_stringCalledByGraph = svgPanZoom('#proccompact_real_stringCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compact_real_string Source Code pure subroutine compact_real_string ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< author: Izaak Beekman !< date: 02/24/2015 !< !< Compact a string representing a real number, so that the same value is displayed with fewer characters. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( inout ) :: string !< string representation of a real number. character ( len = len ( string )) :: significand !< Significand characters. character ( len = len ( string )) :: expnt !< Exponent characters. character ( len = 2 ) :: separator !< Separator characters. integer ( I4P ) :: exp_start !< Start position of exponent. integer ( I4P ) :: decimal_pos !< Decimal positions. integer ( I4P ) :: sig_trim !< Signature trim. integer ( I4P ) :: exp_trim !< Exponent trim. integer ( I4P ) :: i !< counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- string = adjustl ( string ) exp_start = scan ( string , 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( string , '-+' , back = . true .) decimal_pos = scan ( string , '.' ) if ( exp_start /= 0 ) separator = string ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then ! possibly signed, exponent-less float significand = string sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s, but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo string = trim ( significand ( 1 : sig_trim )) elseif ( exp_start > decimal_pos ) then ! float has exponent significand = string ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo expnt = adjustl ( string ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( string ( exp_start + 1 :)) endif exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) ! look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit endif enddo string = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable endif !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine compact_real_string","tags":"","loc":"proc/compact_real_string.html","title":"compact_real_string – FLOw"},{"text":"public interface str Convert number (real and integer) to string (number to string type casting). Calls interface~~str~~CallsGraph interface~str str proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~str~~CalledByGraph interface~str str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures strf_R8P str_R8P strf_R4P str_R4P strf_I8P str_I8P strf_I4P str_I4P strf_I2P str_I2P strf_I1P str_I1P str_bol str_a_R8P str_a_R4P str_a_I8P str_a_I4P str_a_I2P str_a_I1P Module Procedures private elemental function strf_R8P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. private elemental function str_R8P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. private elemental function strf_R4P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. private elemental function str_R4P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. private elemental function strf_I8P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. private elemental function str_I8P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strf_I4P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. private elemental function str_I4P (n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strf_I2P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. private elemental function str_I2P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strf_I1P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. private elemental function str_I1P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function str_bol (n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. private pure function str_a_R8P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R4P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I8P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I4P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I2P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I1P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number.","tags":"","loc":"interface/str.html","title":"str – FLOw"},{"text":"public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). Calls interface~~strz~~CallsGraph interface~strz strz proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~strz~~CalledByGraph interface~strz strz program~test_all test_all program~test_all->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures strz_I8P strz_I4P strz_I2P strz_I1P Module Procedures private elemental function strz_I8P (n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strz_I4P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strz_I2P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strz_I1P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros.","tags":"","loc":"interface/strz.html","title":"strz – FLOw"},{"text":"public interface cton Convert string to number (real and integer, string to number type casting). Calls interface~~cton~~CallsGraph interface~cton cton proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~cton~~CalledByGraph interface~cton cton program~test_all test_all program~test_all->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures ctor_R8P ctor_R4P ctoi_I8P ctoi_I4P ctoi_I2P ctoi_I1P Module Procedures private function ctor_R8P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. private function ctor_R4P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. private function ctoi_I8P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. private function ctoi_I4P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. private function ctoi_I2P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. private function ctoi_I1P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned.","tags":"","loc":"interface/cton.html","title":"cton – FLOw"},{"text":"public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). Calls interface~~bstr~~CallsGraph interface~bstr bstr proc~bstr_i8p bstr_I8P interface~bstr->proc~bstr_i8p proc~bstr_i4p bstr_I4P interface~bstr->proc~bstr_i4p proc~bstr_r4p bstr_R4P interface~bstr->proc~bstr_r4p proc~bstr_r8p bstr_R8P interface~bstr->proc~bstr_r8p proc~bstr_i1p bstr_I1P interface~bstr->proc~bstr_i1p proc~bstr_i2p bstr_I2P interface~bstr->proc~bstr_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~bstr~~CalledByGraph interface~bstr bstr program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures bstr_R8P bstr_R4P bstr_I8P bstr_I4P bstr_I2P bstr_I1P Module Procedures private elemental function bstr_R8P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_R4P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I8P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_I4P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I2P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. private elemental function bstr_I1P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number.","tags":"","loc":"interface/bstr.html","title":"bstr – FLOw"},{"text":"public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). Calls interface~~bcton~~CallsGraph interface~bcton bcton proc~bctor_r4p bctor_R4P interface~bcton->proc~bctor_r4p proc~bctoi_i8p bctoi_I8P interface~bcton->proc~bctoi_i8p proc~bctoi_i4p bctoi_I4P interface~bcton->proc~bctoi_i4p proc~bctor_r8p bctor_R8P interface~bcton->proc~bctor_r8p proc~bctoi_i2p bctoi_I2P interface~bcton->proc~bctoi_i2p proc~bctoi_i1p bctoi_I1P interface~bcton->proc~bctoi_i1p interface~str str proc~bctor_r4p->interface~str proc~bctoi_i8p->interface~str proc~bctoi_i4p->interface~str proc~bctor_r8p->interface~str proc~bctoi_i2p->interface~str proc~bctoi_i1p->interface~str proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~bcton~~CalledByGraph interface~bcton bcton program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures bctor_R8P bctor_R4P bctoi_I8P bctoi_I4P bctoi_I2P bctoi_I1P Module Procedures private elemental function bctor_R8P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. private elemental function bctor_R4P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. private elemental function bctoi_I8P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. private elemental function bctoi_I4P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. private elemental function bctoi_I2P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. private elemental function bctoi_I1P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned.","tags":"","loc":"interface/bcton.html","title":"bcton – FLOw"},{"text":"public elemental function sq_norm(vec) result(sq) Compute the square of the norm of a vector. The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Square of the Norm. Called By proc~~sq_norm~~CalledByGraph proc~sq_norm sq_norm program~simple simple program~simple->proc~sq_norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sq_norm Source Code elemental function sq_norm ( vec ) result ( sq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the square of the norm of a vector. !< !< The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: vec !< Vector. real ( R8P ) :: sq !< Square of the Norm. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sq = ( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sq_norm","tags":"","loc":"proc/sq_norm.html","title":"sq_norm – FLOw"},{"text":"public elemental function normL2(vec) result(norm) Compute the norm L2 of a vector. The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Norm L2. Called By proc~~norml2~~CalledByGraph proc~norml2 normL2 proc~self_great_eq_r16p self_great_eq_R16P proc~self_great_eq_r16p->proc~norml2 proc~self_not_eq_self self_not_eq_self proc~self_not_eq_self->proc~norml2 proc~normalize normalize proc~self_not_eq_self->proc~normalize proc~self_great_i8p self_great_I8P proc~self_great_i8p->proc~norml2 proc~normalize_self normalize_self proc~normalize_self->proc~norml2 proc~r16p_not_eq_self R16P_not_eq_self proc~r16p_not_eq_self->proc~norml2 proc~self_not_eq_r16p self_not_eq_R16P proc~self_not_eq_r16p->proc~norml2 proc~self_great_eq_r4p self_great_eq_R4P proc~self_great_eq_r4p->proc~norml2 proc~self_not_eq_r8p self_not_eq_R8P proc~self_not_eq_r8p->proc~norml2 proc~self_not_eq_i4p self_not_eq_I4P proc~self_not_eq_i4p->proc~norml2 proc~r4p_not_eq_self R4P_not_eq_self proc~r4p_not_eq_self->proc~norml2 proc~i4p_great_eq_self I4P_great_eq_self proc~i4p_great_eq_self->proc~norml2 proc~i4p_great_self I4P_great_self proc~i4p_great_self->proc~norml2 proc~i8p_not_eq_self I8P_not_eq_self proc~i8p_not_eq_self->proc~norml2 proc~self_not_eq_i8p self_not_eq_I8P proc~self_not_eq_i8p->proc~norml2 proc~r8p_great_eq_self R8P_great_eq_self proc~r8p_great_eq_self->proc~norml2 proc~i4p_not_eq_self I4P_not_eq_self proc~i4p_not_eq_self->proc~norml2 proc~i1p_great_eq_self I1P_great_eq_self proc~i1p_great_eq_self->proc~norml2 proc~i2p_not_eq_self I2P_not_eq_self proc~i2p_not_eq_self->proc~norml2 proc~self_great_eq_i1p self_great_eq_I1P proc~self_great_eq_i1p->proc~norml2 proc~self_great_self self_great_self proc~self_great_self->proc~norml2 proc~self_great_i4p self_great_I4P proc~self_great_i4p->proc~norml2 proc~r16p_great_self R16P_great_self proc~r16p_great_self->proc~norml2 proc~self_great_r16p self_great_R16P proc~self_great_r16p->proc~norml2 proc~self_great_eq_r8p self_great_eq_R8P proc~self_great_eq_r8p->proc~norml2 proc~r8p_great_self R8P_great_self proc~r8p_great_self->proc~norml2 proc~r16p_low_self R16P_low_self proc~r16p_low_self->proc~norml2 proc~self_not_eq_i2p self_not_eq_I2P proc~self_not_eq_i2p->proc~norml2 proc~r4p_great_self R4P_great_self proc~r4p_great_self->proc~norml2 proc~r8p_low_self R8P_low_self proc~r8p_low_self->proc~norml2 proc~i2p_great_self I2P_great_self proc~i2p_great_self->proc~norml2 proc~self_low_r8p self_low_R8P proc~self_low_r8p->proc~norml2 proc~r4p_low_self R4P_low_self proc~r4p_low_self->proc~norml2 proc~r4p_great_eq_self R4P_great_eq_self proc~r4p_great_eq_self->proc~norml2 proc~self_low_r4p self_low_R4P proc~self_low_r4p->proc~norml2 proc~i8p_low_self I8P_low_self proc~i8p_low_self->proc~norml2 proc~i1p_not_eq_self I1P_not_eq_self proc~i1p_not_eq_self->proc~norml2 proc~self_low_i8p self_low_I8P proc~self_low_i8p->proc~norml2 proc~i4p_low_self I4P_low_self proc~i4p_low_self->proc~norml2 proc~self_great_i2p self_great_I2P proc~self_great_i2p->proc~norml2 proc~self_low_i4p self_low_I4P proc~self_low_i4p->proc~norml2 proc~i2p_low_self I2P_low_self proc~i2p_low_self->proc~norml2 proc~r8p_not_eq_self R8P_not_eq_self proc~r8p_not_eq_self->proc~norml2 proc~self_low_i2p self_low_I2P proc~self_low_i2p->proc~norml2 proc~i1p_low_self I1P_low_self proc~i1p_low_self->proc~norml2 proc~self_not_eq_i1p self_not_eq_I1P proc~self_not_eq_i1p->proc~norml2 proc~normalize->proc~norml2 proc~self_low_i1p self_low_I1P proc~self_low_i1p->proc~norml2 proc~self_low_eq_self self_low_eq_self proc~self_low_eq_self->proc~norml2 proc~i1p_great_self I1P_great_self proc~i1p_great_self->proc~norml2 proc~r16p_low_eq_self R16P_low_eq_self proc~r16p_low_eq_self->proc~norml2 proc~i8p_great_eq_self I8P_great_eq_self proc~i8p_great_eq_self->proc~norml2 proc~self_low_eq_r16p self_low_eq_R16P proc~self_low_eq_r16p->proc~norml2 proc~normalized_self normalized_self proc~normalized_self->proc~norml2 proc~r8p_low_eq_self R8P_low_eq_self proc~r8p_low_eq_self->proc~norml2 proc~self_low_self self_low_self proc~self_low_self->proc~norml2 proc~self_low_eq_r8p self_low_eq_R8P proc~self_low_eq_r8p->proc~norml2 proc~r4p_low_eq_self R4P_low_eq_self proc~r4p_low_eq_self->proc~norml2 proc~self_great_i1p self_great_I1P proc~self_great_i1p->proc~norml2 proc~self_low_eq_r4p self_low_eq_R4P proc~self_low_eq_r4p->proc~norml2 proc~i8p_low_eq_self I8P_low_eq_self proc~i8p_low_eq_self->proc~norml2 proc~parallel parallel proc~parallel->proc~norml2 proc~parallel->proc~normalize proc~self_great_eq_i8p self_great_eq_I8P proc~self_great_eq_i8p->proc~norml2 proc~self_low_eq_i8p self_low_eq_I8P proc~self_low_eq_i8p->proc~norml2 proc~i4p_low_eq_self I4P_low_eq_self proc~i4p_low_eq_self->proc~norml2 proc~self_great_r8p self_great_R8P proc~self_great_r8p->proc~norml2 proc~self_low_eq_i4p self_low_eq_I4P proc~self_low_eq_i4p->proc~norml2 proc~i2p_low_eq_self I2P_low_eq_self proc~i2p_low_eq_self->proc~norml2 proc~self_low_eq_i2p self_low_eq_I2P proc~self_low_eq_i2p->proc~norml2 proc~i1p_low_eq_self I1P_low_eq_self proc~i1p_low_eq_self->proc~norml2 proc~self_not_eq_r4p self_not_eq_R4P proc~self_not_eq_r4p->proc~norml2 proc~self_low_eq_i1p self_low_eq_I1P proc~self_low_eq_i1p->proc~norml2 proc~self_eq_self self_eq_self proc~self_eq_self->proc~norml2 proc~self_eq_self->proc~normalize proc~self_low_r16p self_low_R16P proc~self_low_r16p->proc~norml2 proc~r16p_eq_self R16P_eq_self proc~r16p_eq_self->proc~norml2 proc~self_eq_r16p self_eq_R16P proc~self_eq_r16p->proc~norml2 proc~r8p_eq_self R8P_eq_self proc~r8p_eq_self->proc~norml2 proc~self_eq_r8p self_eq_R8P proc~self_eq_r8p->proc~norml2 proc~self_great_eq_i4p self_great_eq_I4P proc~self_great_eq_i4p->proc~norml2 proc~r4p_eq_self R4P_eq_self proc~r4p_eq_self->proc~norml2 proc~self_eq_r4p self_eq_R4P proc~self_eq_r4p->proc~norml2 proc~self_great_r4p self_great_R4P proc~self_great_r4p->proc~norml2 proc~i8p_eq_self I8P_eq_self proc~i8p_eq_self->proc~norml2 proc~self_eq_i8p self_eq_I8P proc~self_eq_i8p->proc~norml2 proc~i4p_eq_self I4P_eq_self proc~i4p_eq_self->proc~norml2 proc~self_eq_i4p self_eq_I4P proc~self_eq_i4p->proc~norml2 proc~i2p_great_eq_self I2P_great_eq_self proc~i2p_great_eq_self->proc~norml2 proc~i2p_eq_self I2P_eq_self proc~i2p_eq_self->proc~norml2 proc~self_eq_i2p self_eq_I2P proc~self_eq_i2p->proc~norml2 proc~i8p_great_self I8P_great_self proc~i8p_great_self->proc~norml2 proc~i1p_eq_self I1P_eq_self proc~i1p_eq_self->proc~norml2 proc~self_eq_i1p self_eq_I1P proc~self_eq_i1p->proc~norml2 program~simple simple program~simple->proc~norml2 proc~face_normal3 face_normal3 program~simple->proc~face_normal3 proc~face_normal4 face_normal4 program~simple->proc~face_normal4 proc~self_great_eq_self self_great_eq_self proc~self_great_eq_self->proc~norml2 proc~r16p_great_eq_self R16P_great_eq_self proc~r16p_great_eq_self->proc~norml2 proc~self_great_eq_i2p self_great_eq_I2P proc~self_great_eq_i2p->proc~norml2 proc~face_normal3_self face_normal3_self proc~face_normal3_self->proc~normalize proc~face_normal4_self face_normal4_self proc~face_normal4_self->proc~normalize proc~face_normal3->proc~normalize proc~face_normal4->proc~normalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code normL2 Source Code elemental function normL2 ( vec ) result ( norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the norm L2 of a vector. !< !< The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: vec !< Vector. real ( R8P ) :: norm !< Norm L2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- norm = sqrt (( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction normL2","tags":"","loc":"proc/norml2.html","title":"normL2 – FLOw"},{"text":"public elemental function normalize(vec) result(norm) Normalize a vector. The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the\n normalization value is set to normL2(vec)+smallR8P. Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: vec Vector to be normalized. Return Value type( Vector ) Vector normalized. Calls proc~~normalize~~CallsGraph proc~normalize normalize proc~norml2 normL2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~normalize~~CalledByGraph proc~normalize normalize proc~face_normal3_self face_normal3_self proc~face_normal3_self->proc~normalize proc~face_normal4_self face_normal4_self proc~face_normal4_self->proc~normalize proc~face_normal3 face_normal3 proc~face_normal3->proc~normalize proc~self_not_eq_self self_not_eq_self proc~self_not_eq_self->proc~normalize proc~face_normal4 face_normal4 proc~face_normal4->proc~normalize proc~self_eq_self self_eq_self proc~self_eq_self->proc~normalize proc~parallel parallel proc~parallel->proc~normalize program~simple simple program~simple->proc~face_normal3 program~simple->proc~face_normal4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code normalize Source Code elemental function normalize ( vec ) result ( norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Normalize a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the !< normalization value is set to normL2(vec)+smallR8P. !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: vec !< Vector to be normalized. type ( Vector ) :: norm !< Vector normalized. real ( R8P ) :: nm !< Norm L2 of vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- nm = normL2 ( vec ) if ( nm < smallR8P ) then nm = nm + smallR8P endif norm % x = vec % x / nm norm % y = vec % y / nm norm % z = vec % z / nm return !--------------------------------------------------------------------------------------------------------------------------------- endfunction normalize","tags":"","loc":"proc/normalize.html","title":"normalize – FLOw"},{"text":"public elemental function face_normal4(pt1, pt2, pt3, pt4, norm) result(fnormal) Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. The convention for the points numeration is the following: 1.----------.2\n  |          |\n  |          |\n  |          |\n  |          |\n 4.----------.3 The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24.\n The normal is normalized if the variable norm is passed (with any value). Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. type( Vector ), intent(in) :: pt4 Fourth face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Return Value type( Vector ) Face normal. Calls proc~~face_normal4~~CallsGraph proc~face_normal4 face_normal4 proc~normalize normalize proc~face_normal4->proc~normalize proc~norml2 normL2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~face_normal4~~CalledByGraph proc~face_normal4 face_normal4 program~simple simple program~simple->proc~face_normal4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code face_normal4 Source Code elemental function face_normal4 ( pt1 , pt2 , pt3 , pt4 , norm ) result ( fnormal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. !< !< The convention for the points numeration is the following: !<``` !< 1.----------.2 !<  |          | !<  |          | !<  |          | !<  |          | !< 4.----------.3 !<``` !< The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24. !< The normal is normalized if the variable *norm* is passed (with any value). !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: pt1 !< First face point. type ( Vector ), intent ( IN ) :: pt2 !< Second face point. type ( Vector ), intent ( IN ) :: pt3 !< Third face point. type ( Vector ), intent ( IN ) :: pt4 !< Fourth face point. character ( 1 ), intent ( IN ), optional :: norm !< If 'norm' is passed as argument the normal is normalized. type ( Vector ) :: fnormal !< Face normal. type ( Vector ) :: d13 !< Face 1-3 diagonal. type ( Vector ) :: d24 !< Face 2-4 diagonal. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- d13 = pt3 - pt1 d24 = pt4 - pt2 if ( present ( norm )) then fnormal = normalize ( d13 . cross . d24 ) else fnormal = 0.5_R8P * ( d13 . cross . d24 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction face_normal4","tags":"","loc":"proc/face_normal4.html","title":"face_normal4 – FLOw"},{"text":"public elemental function face_normal3(pt1, pt2, pt3, norm) result(fnormal) Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. The convention for the points numeration is the following: 1.----.2\n   \\   |\n    \\  |\n     \\ |\n      \\|\n       .3 The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13.\n The normal is normalized if the variable 'norm' is passed (with any value). Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Return Value type( Vector ) Face normal. Calls proc~~face_normal3~~CallsGraph proc~face_normal3 face_normal3 proc~normalize normalize proc~face_normal3->proc~normalize proc~norml2 normL2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~face_normal3~~CalledByGraph proc~face_normal3 face_normal3 program~simple simple program~simple->proc~face_normal3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code face_normal3 Source Code elemental function face_normal3 ( pt1 , pt2 , pt3 , norm ) result ( fnormal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. !< !< The convention for the points numeration is the following: !<``` !< 1.----.2 !<   \\   | !<    \\  | !<     \\ | !<      \\| !<       .3 !<``` !< The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13. !< The normal is normalized if the variable 'norm' is passed (with any value). !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: pt1 !< First face point. type ( Vector ), intent ( IN ) :: pt2 !< Second face point. type ( Vector ), intent ( IN ) :: pt3 !< Third face point. character ( 1 ), intent ( IN ), optional :: norm !< If 'norm' is passed as argument the normal is normalized. type ( Vector ) :: fnormal !< Face normal. type ( Vector ) :: s12 !< Face 1-2 diagonals. type ( Vector ) :: s13 !< Face 1-3 diagonals. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- s12 = pt2 - pt1 s13 = pt3 - pt1 if ( present ( norm )) then fnormal = normalize ( s12 . cross . s13 ) else fnormal = 0.5_R8P * ( s12 . cross . s13 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction face_normal3","tags":"","loc":"proc/face_normal3.html","title":"face_normal3 – FLOw"},{"text":"private function iolen_vector_self(vec) result(iolen) Compute IO length. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value integer(kind=I4P) IO length. Source Code iolen_vector_self Source Code function iolen_vector_self ( vec ) result ( iolen ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute IO length. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector. integer ( I4P ) :: iolen !< IO length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- inquire ( iolength = iolen ) vec % x , vec % y , vec % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction iolen_vector_self","tags":"","loc":"proc/iolen_vector_self.html","title":"iolen_vector_self – FLOw"},{"text":"private elemental function normalized_self(vec) result(norm) Get a normalized copy of a vector. The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the\n normalization value is set to normL2(vec)+smallR8P. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector to be normalized. Return Value type( Vector ) Normalized copy. Calls proc~~normalized_self~~CallsGraph proc~normalized_self normalized_self proc~norml2 normL2 proc~normalized_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code normalized_self Source Code elemental function normalized_self ( vec ) result ( norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get a normalized copy of a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the !< normalization value is set to normL2(vec)+smallR8P. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector to be normalized. type ( Vector ) :: norm !< Normalized copy. real ( R8P ) :: nm !< Norm L2 of vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- nm = normL2 ( vec ) if ( nm < smallR8P ) then nm = nm + smallR8P endif norm % x = vec % x / nm norm % y = vec % y / nm norm % z = vec % z / nm return !--------------------------------------------------------------------------------------------------------------------------------- endfunction normalized_self","tags":"","loc":"proc/normalized_self.html","title":"normalized_self – FLOw"},{"text":"private elemental function sq_norm_self(vec) result(sq) Compute the square of the norm of a vector. The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Square of the Norm. Source Code sq_norm_self Source Code elemental function sq_norm_self ( vec ) result ( sq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the square of the norm of a vector. !< !< The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector. real ( R8P ) :: sq !< Square of the Norm. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sq = ( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sq_norm_self","tags":"","loc":"proc/sq_norm_self.html","title":"sq_norm_self – FLOw"},{"text":"private elemental function normL2_self(vec) result(norm) Compute the norm L2 of a vector. The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Norm L2. Source Code normL2_self Source Code elemental function normL2_self ( vec ) result ( norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the norm L2 of a vector. !< !< The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector. real ( R8P ) :: norm !< Norm L2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- norm = sqrt (( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction normL2_self","tags":"","loc":"proc/norml2_self.html","title":"normL2_self – FLOw"},{"text":"private elemental function crossproduct(vec1, vec2) result(cross) Compute the cross product of 2 vectors.  \\vec V=\\left({y_1 z_2 - z_1 y_2}\\right)\\vec i +\n           \\left({z_1 x_2 - x_1 z_2}\\right)\\vec j +\n           \\left({x_1 y_2 - y_1 x_2}\\right)\\vec k \n where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Cross product vector. Source Code crossproduct Source Code elemental function crossproduct ( vec1 , vec2 ) result ( cross ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the cross product of 2 vectors. !< !<  \\vec V=\\left({y_1 z_2 - z_1 y_2}\\right)\\vec i + !<           \\left({z_1 x_2 - x_1 z_2}\\right)\\vec j + !<           \\left({x_1 y_2 - y_1 x_2}\\right)\\vec k  !< where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec1 !< First vector. type ( Vector ), intent ( IN ) :: vec2 !< Second vector. type ( Vector ) :: cross !< Cross product vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- cross % x = ( vec1 % y * vec2 % z ) - ( vec1 % z * vec2 % y ) cross % y = ( vec1 % z * vec2 % x ) - ( vec1 % x * vec2 % z ) cross % z = ( vec1 % x * vec2 % y ) - ( vec1 % y * vec2 % x ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction crossproduct","tags":"","loc":"proc/crossproduct.html","title":"crossproduct – FLOw"},{"text":"private elemental function dotproduct(vec1, vec2) result(dot) Compute the scalar (dot) product of 2 vectors.  {\\rm D}= x_1 \\cdot x_2 + y_1 \\cdot y_2 + z_1 \\cdot z_2 \n where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value real(kind=R8P) Dot product. Source Code dotproduct Source Code elemental function dotproduct ( vec1 , vec2 ) result ( dot ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the scalar (dot) product of 2 vectors. !< !<  {\\rm D}= x_1 \\cdot x_2 + y_1 \\cdot y_2 + z_1 \\cdot z_2  !< where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec1 !< First vector. type ( Vector ), intent ( IN ) :: vec2 !< Second vector. real ( R8P ) :: dot !< Dot product. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dot = ( vec1 % x * vec2 % x ) + ( vec1 % y * vec2 % y ) + ( vec1 % z * vec2 % z ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dotproduct","tags":"","loc":"proc/dotproduct.html","title":"dotproduct – FLOw"},{"text":"private elemental function parallel(vec1, vec2) result(paral) Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 Compute the component of vec1 parallel to vec2.\n First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Component of of vec1 parallel to vec2. Calls proc~~parallel~~CallsGraph proc~parallel parallel proc~normalize normalize proc~parallel->proc~normalize proc~norml2 normL2 proc~parallel->proc~norml2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code parallel Source Code elemental function parallel ( vec1 , vec2 ) result ( paral ) !--------------------------------------------------------------------------------------------------------------------------------- !> Compute the component of vec1 parallel to vec2. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec1 !< First vector. type ( Vector ), intent ( IN ) :: vec2 !< Second vector. type ( Vector ) :: paral !< Component of of vec1 parallel to vec2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- paral = ( vec1 . dot . vec2 ) * normalize ( vec2 ) / normL2 ( vec2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction parallel","tags":"","loc":"proc/parallel.html","title":"parallel – FLOw"},{"text":"private elemental function orthogonal(vec1, vec2) result(ortho) Compute the component of vec1 orthogonal to vec2. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Component of of vec1 orthogonal to vec2. Source Code orthogonal Source Code elemental function orthogonal ( vec1 , vec2 ) result ( ortho ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the component of vec1 orthogonal to vec2. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec1 !< First vector. type ( Vector ), intent ( IN ) :: vec2 !< Second vector. type ( Vector ) :: ortho !< Component of of vec1 orthogonal to vec2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ortho = vec1 - ( vec1 . paral . vec2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction orthogonal","tags":"","loc":"proc/orthogonal.html","title":"orthogonal – FLOw"},{"text":"private elemental function self_mul_self(self1, self2) result(mul) Multiply (by components) two selfs. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) Source Code self_mul_self Source Code elemental function self_mul_self ( self1 , self2 ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply (by components) two selfs. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = self1 % x * self2 % x mul % y = self1 % y * self2 % y mul % z = self1 % z * self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_self","tags":"","loc":"proc/self_mul_self.html","title":"self_mul_self – FLOw"},{"text":"private elemental function ScalR16P_mul_self(scal, self) result(mul) Multiply scalar (real R16P) for self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR16P_mul_self Source Code elemental function ScalR16P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (real R16P) for self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR16P_mul_self","tags":"","loc":"proc/scalr16p_mul_self.html","title":"ScalR16P_mul_self – FLOw"},{"text":"private elemental function self_mul_ScalR16P(self, scal) result(mul) Multiply self for scalar (real R16P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value type( Vector ) Source Code self_mul_ScalR16P Source Code elemental function self_mul_ScalR16P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (real R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalR16P","tags":"","loc":"proc/self_mul_scalr16p.html","title":"self_mul_ScalR16P – FLOw"},{"text":"private elemental function ScalR8P_mul_self(scal, self) result(mul) Multiply scalar (real R8P) for self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR8P_mul_self Source Code elemental function ScalR8P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (real R8P) for self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR8P_mul_self","tags":"","loc":"proc/scalr8p_mul_self.html","title":"ScalR8P_mul_self – FLOw"},{"text":"private elemental function self_mul_ScalR8P(self, scal) result(mul) Multiply self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) Source Code self_mul_ScalR8P Source Code elemental function self_mul_ScalR8P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (real R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalR8P","tags":"","loc":"proc/self_mul_scalr8p.html","title":"self_mul_ScalR8P – FLOw"},{"text":"private elemental function ScalR4P_mul_self(scal, self) result(mul) Multiply scalar (real R4P) for self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR4P_mul_self Source Code elemental function ScalR4P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (real R4P) for self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR4P_mul_self","tags":"","loc":"proc/scalr4p_mul_self.html","title":"ScalR4P_mul_self – FLOw"},{"text":"private elemental function self_mul_ScalR4P(self, scal) result(mul) Multiply self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) Source Code self_mul_ScalR4P Source Code elemental function self_mul_ScalR4P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (real R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalR4P","tags":"","loc":"proc/self_mul_scalr4p.html","title":"self_mul_ScalR4P – FLOw"},{"text":"private elemental function ScalI8P_mul_self(scal, self) result(mul) Multiply scalar (integer I8P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI8P_mul_self Source Code elemental function ScalI8P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (integer I8P) for self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI8P_mul_self","tags":"","loc":"proc/scali8p_mul_self.html","title":"ScalI8P_mul_self – FLOw"},{"text":"private elemental function self_mul_ScalI8P(self, scal) result(mul) Multiply self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) Source Code self_mul_ScalI8P Source Code elemental function self_mul_ScalI8P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (integer I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalI8P","tags":"","loc":"proc/self_mul_scali8p.html","title":"self_mul_ScalI8P – FLOw"},{"text":"private elemental function ScalI4P_mul_self(scal, self) result(mul) Multiply scalar (integer I4P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI4P_mul_self Source Code elemental function ScalI4P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (integer I4P) for self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI4P_mul_self","tags":"","loc":"proc/scali4p_mul_self.html","title":"ScalI4P_mul_self – FLOw"},{"text":"private elemental function self_mul_ScalI4P(self, scal) result(mul) Multiply self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) Source Code self_mul_ScalI4P Source Code elemental function self_mul_ScalI4P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (integer I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalI4P","tags":"","loc":"proc/self_mul_scali4p.html","title":"self_mul_ScalI4P – FLOw"},{"text":"private elemental function ScalI2P_mul_self(scal, self) result(mul) Multiply scalar (integer I2P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI2P_mul_self Source Code elemental function ScalI2P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (integer I2P) for self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI2P_mul_self","tags":"","loc":"proc/scali2p_mul_self.html","title":"ScalI2P_mul_self – FLOw"},{"text":"private elemental function self_mul_ScalI2P(self, scal) result(mul) Multiply self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) Source Code self_mul_ScalI2P Source Code elemental function self_mul_ScalI2P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (integer I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalI2P","tags":"","loc":"proc/self_mul_scali2p.html","title":"self_mul_ScalI2P – FLOw"},{"text":"private elemental function ScalI1P_mul_self(scal, self) result(mul) Multiply scalar (integer I1P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI1P_mul_self Source Code elemental function ScalI1P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (integer I1P) for self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI1P_mul_self","tags":"","loc":"proc/scali1p_mul_self.html","title":"ScalI1P_mul_self – FLOw"},{"text":"private elemental function self_mul_ScalI1P(self, scal) result(mul) Multiply self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) Source Code self_mul_ScalI1P Source Code elemental function self_mul_ScalI1P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (integer I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalI1P","tags":"","loc":"proc/self_mul_scali1p.html","title":"self_mul_ScalI1P – FLOw"},{"text":"private elemental function self_div_self(self1, self2) result(div) Divide self for self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) Source Code self_div_self Source Code elemental function self_div_self ( self1 , self2 ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self1 % x / self2 % x div % y = self1 % y / self2 % y div % z = self1 % z / self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_self","tags":"","loc":"proc/self_div_self.html","title":"self_div_self – FLOw"},{"text":"private elemental function self_div_ScalR16P(self, scal) result(div) Divide self for scalar (real R16P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value type( Vector ) Source Code self_div_ScalR16P Source Code elemental function self_div_ScalR16P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (real R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalR16P","tags":"","loc":"proc/self_div_scalr16p.html","title":"self_div_ScalR16P – FLOw"},{"text":"private elemental function self_div_ScalR8P(self, scal) result(div) Divide self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) Source Code self_div_ScalR8P Source Code elemental function self_div_ScalR8P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (real R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalR8P","tags":"","loc":"proc/self_div_scalr8p.html","title":"self_div_ScalR8P – FLOw"},{"text":"private elemental function self_div_ScalR4P(self, scal) result(div) Divide self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) Source Code self_div_ScalR4P Source Code elemental function self_div_ScalR4P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (real R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalR4P","tags":"","loc":"proc/self_div_scalr4p.html","title":"self_div_ScalR4P – FLOw"},{"text":"private elemental function self_div_ScalI8P(self, scal) result(div) Divide self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) Source Code self_div_ScalI8P Source Code elemental function self_div_ScalI8P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (integer I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalI8P","tags":"","loc":"proc/self_div_scali8p.html","title":"self_div_ScalI8P – FLOw"},{"text":"private elemental function self_div_ScalI4P(self, scal) result(div) Divide self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) Source Code self_div_ScalI4P Source Code elemental function self_div_ScalI4P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (integer I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalI4P","tags":"","loc":"proc/self_div_scali4p.html","title":"self_div_ScalI4P – FLOw"},{"text":"private elemental function self_div_ScalI2P(self, scal) result(div) Divide self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) Source Code self_div_ScalI2P Source Code elemental function self_div_ScalI2P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (integer I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalI2P","tags":"","loc":"proc/self_div_scali2p.html","title":"self_div_ScalI2P – FLOw"},{"text":"private elemental function self_div_ScalI1P(self, scal) result(div) Divide self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) Source Code self_div_ScalI1P Source Code elemental function self_div_ScalI1P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (integer I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalI1P","tags":"","loc":"proc/self_div_scali1p.html","title":"self_div_ScalI1P – FLOw"},{"text":"private elemental function positive_self(self) result(pos) Applay unary + to a self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code positive_self Source Code elemental function positive_self ( self ) result ( pos ) !--------------------------------------------------------------------------------------------------------------------------------- !< Applay unary + to a self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self type ( Vector ) :: pos !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pos % x = + self % x pos % y = + self % y pos % z = + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction positive_self","tags":"","loc":"proc/positive_self.html","title":"positive_self – FLOw"},{"text":"private elemental function self_sum_self(self1, self2) result(summ) Sum self and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) Source Code self_sum_self Source Code elemental function self_sum_self ( self1 , self2 ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = self1 % x + self2 % x summ % y = self1 % y + self2 % y summ % z = self1 % z + self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_self","tags":"","loc":"proc/self_sum_self.html","title":"self_sum_self – FLOw"},{"text":"private elemental function ScalR16P_sum_self(scal, self) result(summ) Sum scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR16P_sum_self Source Code elemental function ScalR16P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (real R16P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR16P_sum_self","tags":"","loc":"proc/scalr16p_sum_self.html","title":"ScalR16P_sum_self – FLOw"},{"text":"private elemental function self_sum_ScalR16P(self, scal) result(summ) Sum self and scalar (real R16P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value type( Vector ) Source Code self_sum_ScalR16P Source Code elemental function self_sum_ScalR16P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (real R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalR16P","tags":"","loc":"proc/self_sum_scalr16p.html","title":"self_sum_ScalR16P – FLOw"},{"text":"private elemental function ScalR8P_sum_self(scal, self) result(summ) Sum scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR8P_sum_self Source Code elemental function ScalR8P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (real R8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR8P_sum_self","tags":"","loc":"proc/scalr8p_sum_self.html","title":"ScalR8P_sum_self – FLOw"},{"text":"private elemental function self_sum_ScalR8P(self, scal) result(summ) Sum self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) Source Code self_sum_ScalR8P Source Code elemental function self_sum_ScalR8P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (real R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalR8P","tags":"","loc":"proc/self_sum_scalr8p.html","title":"self_sum_ScalR8P – FLOw"},{"text":"private elemental function ScalR4P_sum_self(scal, self) result(summ) Sum scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR4P_sum_self Source Code elemental function ScalR4P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (real R4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR4P_sum_self","tags":"","loc":"proc/scalr4p_sum_self.html","title":"ScalR4P_sum_self – FLOw"},{"text":"private elemental function self_sum_ScalR4P(self, scal) result(summ) Sum self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) Source Code self_sum_ScalR4P Source Code elemental function self_sum_ScalR4P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (real R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalR4P","tags":"","loc":"proc/self_sum_scalr4p.html","title":"self_sum_ScalR4P – FLOw"},{"text":"private elemental function ScalI8P_sum_self(scal, self) result(summ) Sum scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI8P_sum_self Source Code elemental function ScalI8P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (integer I8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI8P_sum_self","tags":"","loc":"proc/scali8p_sum_self.html","title":"ScalI8P_sum_self – FLOw"},{"text":"private elemental function self_sum_ScalI8P(self, scal) result(summ) Sum self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) Source Code self_sum_ScalI8P Source Code elemental function self_sum_ScalI8P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (integer I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalI8P","tags":"","loc":"proc/self_sum_scali8p.html","title":"self_sum_ScalI8P – FLOw"},{"text":"private elemental function ScalI4P_sum_self(scal, self) result(summ) Sum scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI4P_sum_self Source Code elemental function ScalI4P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (integer I4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI4P_sum_self","tags":"","loc":"proc/scali4p_sum_self.html","title":"ScalI4P_sum_self – FLOw"},{"text":"private elemental function self_sum_ScalI4P(self, scal) result(summ) Sum self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) Source Code self_sum_ScalI4P Source Code elemental function self_sum_ScalI4P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (integer I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalI4P","tags":"","loc":"proc/self_sum_scali4p.html","title":"self_sum_ScalI4P – FLOw"},{"text":"private elemental function ScalI2P_sum_self(scal, self) result(summ) Sum scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI2P_sum_self Source Code elemental function ScalI2P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (integer I2P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI2P_sum_self","tags":"","loc":"proc/scali2p_sum_self.html","title":"ScalI2P_sum_self – FLOw"},{"text":"private elemental function self_sum_ScalI2P(self, scal) result(summ) Sum self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) Source Code self_sum_ScalI2P Source Code elemental function self_sum_ScalI2P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (integer I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalI2P","tags":"","loc":"proc/self_sum_scali2p.html","title":"self_sum_ScalI2P – FLOw"},{"text":"private elemental function ScalI1P_sum_self(scal, self) result(summ) Sum scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI1P_sum_self Source Code elemental function ScalI1P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (integer I1P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI1P_sum_self","tags":"","loc":"proc/scali1p_sum_self.html","title":"ScalI1P_sum_self – FLOw"},{"text":"private elemental function self_sum_ScalI1P(self, scal) result(summ) Sum self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) Source Code self_sum_ScalI1P Source Code elemental function self_sum_ScalI1P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (integer I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalI1P","tags":"","loc":"proc/self_sum_scali1p.html","title":"self_sum_ScalI1P – FLOw"},{"text":"private elemental function negative_self(self) result(neg) Applay unary - to a self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code negative_self Source Code elemental function negative_self ( self ) result ( neg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Applay unary - to a self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self type ( Vector ) :: neg !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- neg % x = - self % x neg % y = - self % y neg % z = - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction negative_self","tags":"","loc":"proc/negative_self.html","title":"negative_self – FLOw"},{"text":"private elemental function self_sub_self(self1, self2) result(sub) Subtract self and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) Source Code self_sub_self Source Code elemental function self_sub_self ( self1 , self2 ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self1 % x - self2 % x sub % y = self1 % y - self2 % y sub % z = self1 % z - self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_self","tags":"","loc":"proc/self_sub_self.html","title":"self_sub_self – FLOw"},{"text":"private elemental function ScalR16P_sub_self(scal, self) result(sub) Subtract scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR16P_sub_self Source Code elemental function ScalR16P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (real R16P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR16P_sub_self","tags":"","loc":"proc/scalr16p_sub_self.html","title":"ScalR16P_sub_self – FLOw"},{"text":"private elemental function self_sub_ScalR16P(self, scal) result(sub) Subtract self and scalar (real R16P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value type( Vector ) Source Code self_sub_ScalR16P Source Code elemental function self_sub_ScalR16P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (real R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalR16P","tags":"","loc":"proc/self_sub_scalr16p.html","title":"self_sub_ScalR16P – FLOw"},{"text":"private elemental function ScalR8P_sub_self(scal, self) result(sub) Subtract scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR8P_sub_self Source Code elemental function ScalR8P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (real R8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR8P_sub_self","tags":"","loc":"proc/scalr8p_sub_self.html","title":"ScalR8P_sub_self – FLOw"},{"text":"private elemental function self_sub_ScalR8P(self, scal) result(sub) Subtract self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) Source Code self_sub_ScalR8P Source Code elemental function self_sub_ScalR8P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (real R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalR8P","tags":"","loc":"proc/self_sub_scalr8p.html","title":"self_sub_ScalR8P – FLOw"},{"text":"private elemental function ScalR4P_sub_self(scal, self) result(sub) Subtract scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR4P_sub_self Source Code elemental function ScalR4P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (real R4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR4P_sub_self","tags":"","loc":"proc/scalr4p_sub_self.html","title":"ScalR4P_sub_self – FLOw"},{"text":"private elemental function self_sub_ScalR4P(self, scal) result(sub) Subtract self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) Source Code self_sub_ScalR4P Source Code elemental function self_sub_ScalR4P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (real R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalR4P","tags":"","loc":"proc/self_sub_scalr4p.html","title":"self_sub_ScalR4P – FLOw"},{"text":"private elemental function ScalI8P_sub_self(scal, self) result(sub) Subtract scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI8P_sub_self Source Code elemental function ScalI8P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (integer I8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI8P_sub_self","tags":"","loc":"proc/scali8p_sub_self.html","title":"ScalI8P_sub_self – FLOw"},{"text":"private elemental function self_sub_ScalI8P(self, scal) result(sub) Subtract self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) Source Code self_sub_ScalI8P Source Code elemental function self_sub_ScalI8P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (integer I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalI8P","tags":"","loc":"proc/self_sub_scali8p.html","title":"self_sub_ScalI8P – FLOw"},{"text":"private elemental function ScalI4P_sub_self(scal, self) result(sub) Subtract scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI4P_sub_self Source Code elemental function ScalI4P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (integer I4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI4P_sub_self","tags":"","loc":"proc/scali4p_sub_self.html","title":"ScalI4P_sub_self – FLOw"},{"text":"private elemental function self_sub_ScalI4P(self, scal) result(sub) Subtract self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) Source Code self_sub_ScalI4P Source Code elemental function self_sub_ScalI4P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (integer I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalI4P","tags":"","loc":"proc/self_sub_scali4p.html","title":"self_sub_ScalI4P – FLOw"},{"text":"private elemental function ScalI2P_sub_self(scal, self) result(sub) Subtract scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI2P_sub_self Source Code elemental function ScalI2P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (integer I2P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI2P_sub_self","tags":"","loc":"proc/scali2p_sub_self.html","title":"ScalI2P_sub_self – FLOw"},{"text":"private elemental function self_sub_ScalI2P(self, scal) result(sub) Subtract self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) Source Code self_sub_ScalI2P Source Code elemental function self_sub_ScalI2P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (integer I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalI2P","tags":"","loc":"proc/self_sub_scali2p.html","title":"self_sub_ScalI2P – FLOw"},{"text":"private elemental function ScalI1P_sub_self(scal, self) result(sub) Subtract scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI1P_sub_self Source Code elemental function ScalI1P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (integer I1P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI1P_sub_self","tags":"","loc":"proc/scali1p_sub_self.html","title":"ScalI1P_sub_self – FLOw"},{"text":"private elemental function self_sub_ScalI1P(self, scal) result(sub) Subtract self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) Source Code self_sub_ScalI1P Source Code elemental function self_sub_ScalI1P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (integer I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalI1P","tags":"","loc":"proc/self_sub_scali1p.html","title":"self_sub_ScalI1P – FLOw"},{"text":"private elemental function self_not_eq_self(self1, self2) result(compare) Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1\n and self2 are different, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 First selftor. type( Vector ), intent(in) :: self2 Second selftor. Return Value logical The result of the comparison. Calls proc~~self_not_eq_self~~CallsGraph proc~self_not_eq_self self_not_eq_self proc~normalize normalize proc~self_not_eq_self->proc~normalize proc~norml2 normL2 proc~self_not_eq_self->proc~norml2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_self Source Code elemental function self_not_eq_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1 !< and self2 are different, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 !< First selftor. type ( Vector ), intent ( IN ) :: self2 !< Second selftor. logical :: compare !< The result of the comparison. type ( Vector ) :: n1 !< Normalizations of self1. type ( Vector ) :: n2 !< Normalizations of self2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) /= normL2 ( self2 )) if (. not . compare ) then ! the normL2 are the same, checking the directions n1 = normalize ( self1 ) n2 = normalize ( self2 ) compare = (( n1 % x /= n2 % x ). OR .( n1 % y /= n2 % y ). OR .( n1 % z /= n2 % z )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_self","tags":"","loc":"proc/self_not_eq_self.html","title":"self_not_eq_self – FLOw"},{"text":"private elemental function R16P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r16p_not_eq_self~~CallsGraph proc~r16p_not_eq_self R16P_not_eq_self proc~norml2 normL2 proc~r16p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_not_eq_self Source Code elemental function R16P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_not_eq_self","tags":"","loc":"proc/r16p_not_eq_self.html","title":"R16P_not_eq_self – FLOw"},{"text":"private elemental function self_not_eq_R16P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical Calls proc~~self_not_eq_r16p~~CallsGraph proc~self_not_eq_r16p self_not_eq_R16P proc~norml2 normL2 proc~self_not_eq_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_R16P Source Code elemental function self_not_eq_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_R16P","tags":"","loc":"proc/self_not_eq_r16p.html","title":"self_not_eq_R16P – FLOw"},{"text":"private elemental function R8P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r8p_not_eq_self~~CallsGraph proc~r8p_not_eq_self R8P_not_eq_self proc~norml2 normL2 proc~r8p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_not_eq_self Source Code elemental function R8P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_not_eq_self","tags":"","loc":"proc/r8p_not_eq_self.html","title":"R8P_not_eq_self – FLOw"},{"text":"private elemental function self_not_eq_R8P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical Calls proc~~self_not_eq_r8p~~CallsGraph proc~self_not_eq_r8p self_not_eq_R8P proc~norml2 normL2 proc~self_not_eq_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_R8P Source Code elemental function self_not_eq_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_R8P","tags":"","loc":"proc/self_not_eq_r8p.html","title":"self_not_eq_R8P – FLOw"},{"text":"private elemental function R4P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r4p_not_eq_self~~CallsGraph proc~r4p_not_eq_self R4P_not_eq_self proc~norml2 normL2 proc~r4p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_not_eq_self Source Code elemental function R4P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_not_eq_self","tags":"","loc":"proc/r4p_not_eq_self.html","title":"R4P_not_eq_self – FLOw"},{"text":"private elemental function self_not_eq_R4P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical Calls proc~~self_not_eq_r4p~~CallsGraph proc~self_not_eq_r4p self_not_eq_R4P proc~norml2 normL2 proc~self_not_eq_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_R4P Source Code elemental function self_not_eq_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_R4P","tags":"","loc":"proc/self_not_eq_r4p.html","title":"self_not_eq_R4P – FLOw"},{"text":"private elemental function I8P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i8p_not_eq_self~~CallsGraph proc~i8p_not_eq_self I8P_not_eq_self proc~norml2 normL2 proc~i8p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_not_eq_self Source Code elemental function I8P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_not_eq_self","tags":"","loc":"proc/i8p_not_eq_self.html","title":"I8P_not_eq_self – FLOw"},{"text":"private elemental function self_not_eq_I8P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical Calls proc~~self_not_eq_i8p~~CallsGraph proc~self_not_eq_i8p self_not_eq_I8P proc~norml2 normL2 proc~self_not_eq_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_I8P Source Code elemental function self_not_eq_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_I8P","tags":"","loc":"proc/self_not_eq_i8p.html","title":"self_not_eq_I8P – FLOw"},{"text":"private elemental function I4P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i4p_not_eq_self~~CallsGraph proc~i4p_not_eq_self I4P_not_eq_self proc~norml2 normL2 proc~i4p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_not_eq_self Source Code elemental function I4P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_not_eq_self","tags":"","loc":"proc/i4p_not_eq_self.html","title":"I4P_not_eq_self – FLOw"},{"text":"private elemental function self_not_eq_I4P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical Calls proc~~self_not_eq_i4p~~CallsGraph proc~self_not_eq_i4p self_not_eq_I4P proc~norml2 normL2 proc~self_not_eq_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_I4P Source Code elemental function self_not_eq_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_I4P","tags":"","loc":"proc/self_not_eq_i4p.html","title":"self_not_eq_I4P – FLOw"},{"text":"private elemental function I2P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i2p_not_eq_self~~CallsGraph proc~i2p_not_eq_self I2P_not_eq_self proc~norml2 normL2 proc~i2p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_not_eq_self Source Code elemental function I2P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_not_eq_self","tags":"","loc":"proc/i2p_not_eq_self.html","title":"I2P_not_eq_self – FLOw"},{"text":"private elemental function self_not_eq_I2P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical Calls proc~~self_not_eq_i2p~~CallsGraph proc~self_not_eq_i2p self_not_eq_I2P proc~norml2 normL2 proc~self_not_eq_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_I2P Source Code elemental function self_not_eq_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_I2P","tags":"","loc":"proc/self_not_eq_i2p.html","title":"self_not_eq_I2P – FLOw"},{"text":"private elemental function I1P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i1p_not_eq_self~~CallsGraph proc~i1p_not_eq_self I1P_not_eq_self proc~norml2 normL2 proc~i1p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_not_eq_self Source Code elemental function I1P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_not_eq_self","tags":"","loc":"proc/i1p_not_eq_self.html","title":"I1P_not_eq_self – FLOw"},{"text":"private elemental function self_not_eq_I1P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical Calls proc~~self_not_eq_i1p~~CallsGraph proc~self_not_eq_i1p self_not_eq_I1P proc~norml2 normL2 proc~self_not_eq_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_I1P Source Code elemental function self_not_eq_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_I1P","tags":"","loc":"proc/self_not_eq_i1p.html","title":"self_not_eq_I1P – FLOw"},{"text":"private elemental function self_low_self(self1, self2) result(compare) Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical Calls proc~~self_low_self~~CallsGraph proc~self_low_self self_low_self proc~norml2 normL2 proc~self_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_self Source Code elemental function self_low_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) < normL2 ( self2 )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_self","tags":"","loc":"proc/self_low_self.html","title":"self_low_self – FLOw"},{"text":"private elemental function R16P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r16p_low_self~~CallsGraph proc~r16p_low_self R16P_low_self proc~norml2 normL2 proc~r16p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_low_self Source Code elemental function R16P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_low_self","tags":"","loc":"proc/r16p_low_self.html","title":"R16P_low_self – FLOw"},{"text":"private elemental function self_low_R16P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical Calls proc~~self_low_r16p~~CallsGraph proc~self_low_r16p self_low_R16P proc~norml2 normL2 proc~self_low_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_R16P Source Code elemental function self_low_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_R16P","tags":"","loc":"proc/self_low_r16p.html","title":"self_low_R16P – FLOw"},{"text":"private elemental function R8P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r8p_low_self~~CallsGraph proc~r8p_low_self R8P_low_self proc~norml2 normL2 proc~r8p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_low_self Source Code elemental function R8P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_low_self","tags":"","loc":"proc/r8p_low_self.html","title":"R8P_low_self – FLOw"},{"text":"private elemental function self_low_R8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical Calls proc~~self_low_r8p~~CallsGraph proc~self_low_r8p self_low_R8P proc~norml2 normL2 proc~self_low_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_R8P Source Code elemental function self_low_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_R8P","tags":"","loc":"proc/self_low_r8p.html","title":"self_low_R8P – FLOw"},{"text":"private elemental function R4P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r4p_low_self~~CallsGraph proc~r4p_low_self R4P_low_self proc~norml2 normL2 proc~r4p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_low_self Source Code elemental function R4P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_low_self","tags":"","loc":"proc/r4p_low_self.html","title":"R4P_low_self – FLOw"},{"text":"private elemental function self_low_R4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical Calls proc~~self_low_r4p~~CallsGraph proc~self_low_r4p self_low_R4P proc~norml2 normL2 proc~self_low_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_R4P Source Code elemental function self_low_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_R4P","tags":"","loc":"proc/self_low_r4p.html","title":"self_low_R4P – FLOw"},{"text":"private elemental function I8P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i8p_low_self~~CallsGraph proc~i8p_low_self I8P_low_self proc~norml2 normL2 proc~i8p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_low_self Source Code elemental function I8P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_low_self","tags":"","loc":"proc/i8p_low_self.html","title":"I8P_low_self – FLOw"},{"text":"private elemental function self_low_I8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical Calls proc~~self_low_i8p~~CallsGraph proc~self_low_i8p self_low_I8P proc~norml2 normL2 proc~self_low_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_I8P Source Code elemental function self_low_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_I8P","tags":"","loc":"proc/self_low_i8p.html","title":"self_low_I8P – FLOw"},{"text":"private elemental function I4P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i4p_low_self~~CallsGraph proc~i4p_low_self I4P_low_self proc~norml2 normL2 proc~i4p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_low_self Source Code elemental function I4P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_low_self","tags":"","loc":"proc/i4p_low_self.html","title":"I4P_low_self – FLOw"},{"text":"private elemental function self_low_I4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical Calls proc~~self_low_i4p~~CallsGraph proc~self_low_i4p self_low_I4P proc~norml2 normL2 proc~self_low_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_I4P Source Code elemental function self_low_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_I4P","tags":"","loc":"proc/self_low_i4p.html","title":"self_low_I4P – FLOw"},{"text":"private elemental function I2P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i2p_low_self~~CallsGraph proc~i2p_low_self I2P_low_self proc~norml2 normL2 proc~i2p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_low_self Source Code elemental function I2P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_low_self","tags":"","loc":"proc/i2p_low_self.html","title":"I2P_low_self – FLOw"},{"text":"private elemental function self_low_I2P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical Calls proc~~self_low_i2p~~CallsGraph proc~self_low_i2p self_low_I2P proc~norml2 normL2 proc~self_low_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_I2P Source Code elemental function self_low_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_I2P","tags":"","loc":"proc/self_low_i2p.html","title":"self_low_I2P – FLOw"},{"text":"private elemental function I1P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i1p_low_self~~CallsGraph proc~i1p_low_self I1P_low_self proc~norml2 normL2 proc~i1p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_low_self Source Code elemental function I1P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_low_self","tags":"","loc":"proc/i1p_low_self.html","title":"I1P_low_self – FLOw"},{"text":"private elemental function self_low_I1P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical Calls proc~~self_low_i1p~~CallsGraph proc~self_low_i1p self_low_I1P proc~norml2 normL2 proc~self_low_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_I1P Source Code elemental function self_low_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_I1P","tags":"","loc":"proc/self_low_i1p.html","title":"self_low_I1P – FLOw"},{"text":"private elemental function self_low_eq_self(self1, self2) result(compare) Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical Calls proc~~self_low_eq_self~~CallsGraph proc~self_low_eq_self self_low_eq_self proc~norml2 normL2 proc~self_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_self Source Code elemental function self_low_eq_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 ! First selftor. type ( Vector ), intent ( IN ) :: self2 ! Second selftor. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) <= normL2 ( self2 )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_self","tags":"","loc":"proc/self_low_eq_self.html","title":"self_low_eq_self – FLOw"},{"text":"private elemental function R16P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r16p_low_eq_self~~CallsGraph proc~r16p_low_eq_self R16P_low_eq_self proc~norml2 normL2 proc~r16p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_low_eq_self Source Code elemental function R16P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_low_eq_self","tags":"","loc":"proc/r16p_low_eq_self.html","title":"R16P_low_eq_self – FLOw"},{"text":"private elemental function self_low_eq_R16P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical Calls proc~~self_low_eq_r16p~~CallsGraph proc~self_low_eq_r16p self_low_eq_R16P proc~norml2 normL2 proc~self_low_eq_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_R16P Source Code elemental function self_low_eq_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R16P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_R16P","tags":"","loc":"proc/self_low_eq_r16p.html","title":"self_low_eq_R16P – FLOw"},{"text":"private elemental function R8P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r8p_low_eq_self~~CallsGraph proc~r8p_low_eq_self R8P_low_eq_self proc~norml2 normL2 proc~r8p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_low_eq_self Source Code elemental function R8P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_low_eq_self","tags":"","loc":"proc/r8p_low_eq_self.html","title":"R8P_low_eq_self – FLOw"},{"text":"private elemental function self_low_eq_R8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical Calls proc~~self_low_eq_r8p~~CallsGraph proc~self_low_eq_r8p self_low_eq_R8P proc~norml2 normL2 proc~self_low_eq_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_R8P Source Code elemental function self_low_eq_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_R8P","tags":"","loc":"proc/self_low_eq_r8p.html","title":"self_low_eq_R8P – FLOw"},{"text":"private elemental function R4P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r4p_low_eq_self~~CallsGraph proc~r4p_low_eq_self R4P_low_eq_self proc~norml2 normL2 proc~r4p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_low_eq_self Source Code elemental function R4P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_low_eq_self","tags":"","loc":"proc/r4p_low_eq_self.html","title":"R4P_low_eq_self – FLOw"},{"text":"private elemental function self_low_eq_R4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical Calls proc~~self_low_eq_r4p~~CallsGraph proc~self_low_eq_r4p self_low_eq_R4P proc~norml2 normL2 proc~self_low_eq_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_R4P Source Code elemental function self_low_eq_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_R4P","tags":"","loc":"proc/self_low_eq_r4p.html","title":"self_low_eq_R4P – FLOw"},{"text":"private elemental function I8P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i8p_low_eq_self~~CallsGraph proc~i8p_low_eq_self I8P_low_eq_self proc~norml2 normL2 proc~i8p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_low_eq_self Source Code elemental function I8P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_low_eq_self","tags":"","loc":"proc/i8p_low_eq_self.html","title":"I8P_low_eq_self – FLOw"},{"text":"private elemental function self_low_eq_I8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical Calls proc~~self_low_eq_i8p~~CallsGraph proc~self_low_eq_i8p self_low_eq_I8P proc~norml2 normL2 proc~self_low_eq_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_I8P Source Code elemental function self_low_eq_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_I8P","tags":"","loc":"proc/self_low_eq_i8p.html","title":"self_low_eq_I8P – FLOw"},{"text":"private elemental function I4P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i4p_low_eq_self~~CallsGraph proc~i4p_low_eq_self I4P_low_eq_self proc~norml2 normL2 proc~i4p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_low_eq_self Source Code elemental function I4P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_low_eq_self","tags":"","loc":"proc/i4p_low_eq_self.html","title":"I4P_low_eq_self – FLOw"},{"text":"private elemental function self_low_eq_I4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical Calls proc~~self_low_eq_i4p~~CallsGraph proc~self_low_eq_i4p self_low_eq_I4P proc~norml2 normL2 proc~self_low_eq_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_I4P Source Code elemental function self_low_eq_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_I4P","tags":"","loc":"proc/self_low_eq_i4p.html","title":"self_low_eq_I4P – FLOw"},{"text":"private elemental function I2P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i2p_low_eq_self~~CallsGraph proc~i2p_low_eq_self I2P_low_eq_self proc~norml2 normL2 proc~i2p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_low_eq_self Source Code elemental function I2P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_low_eq_self","tags":"","loc":"proc/i2p_low_eq_self.html","title":"I2P_low_eq_self – FLOw"},{"text":"private elemental function self_low_eq_I2P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical Calls proc~~self_low_eq_i2p~~CallsGraph proc~self_low_eq_i2p self_low_eq_I2P proc~norml2 normL2 proc~self_low_eq_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_I2P Source Code elemental function self_low_eq_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I2P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_I2P","tags":"","loc":"proc/self_low_eq_i2p.html","title":"self_low_eq_I2P – FLOw"},{"text":"private elemental function I1P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i1p_low_eq_self~~CallsGraph proc~i1p_low_eq_self I1P_low_eq_self proc~norml2 normL2 proc~i1p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_low_eq_self Source Code elemental function I1P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_low_eq_self","tags":"","loc":"proc/i1p_low_eq_self.html","title":"I1P_low_eq_self – FLOw"},{"text":"private elemental function self_low_eq_I1P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical Calls proc~~self_low_eq_i1p~~CallsGraph proc~self_low_eq_i1p self_low_eq_I1P proc~norml2 normL2 proc~self_low_eq_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_I1P Source Code elemental function self_low_eq_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I1P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_I1P","tags":"","loc":"proc/self_low_eq_i1p.html","title":"self_low_eq_I1P – FLOw"},{"text":"private elemental function self_eq_self(self1, self2) result(compare) Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of\n self1 and self2 are the same, .false. otherwise. type( Vector ), intent(in) :: self2 Return Value logical Calls proc~~self_eq_self~~CallsGraph proc~self_eq_self self_eq_self proc~normalize normalize proc~self_eq_self->proc~normalize proc~norml2 normL2 proc~self_eq_self->proc~norml2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_self Source Code elemental function self_eq_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !> Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of !> self1 and self2 are the same, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 ! First selftor. type ( Vector ), intent ( IN ) :: self2 ! Second selftor. logical :: compare ! The result of the comparison. type ( Vector ) :: n1 ! Normalizations of self1. type ( Vector ) :: n2 ! Normalizations of self2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) == normL2 ( self2 )) if ( compare ) then ! the normL2 are the same, checking the directions n1 = normalize ( self1 ) n2 = normalize ( self2 ) compare = (( n1 % x == n2 % x ). AND .( n1 % y == n2 % y ). AND .( n1 % z == n2 % z )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_self","tags":"","loc":"proc/self_eq_self.html","title":"self_eq_self – FLOw"},{"text":"private elemental function R16P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r16p_eq_self~~CallsGraph proc~r16p_eq_self R16P_eq_self proc~norml2 normL2 proc~r16p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_eq_self Source Code elemental function R16P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_eq_self","tags":"","loc":"proc/r16p_eq_self.html","title":"R16P_eq_self – FLOw"},{"text":"private elemental function self_eq_R16P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical Calls proc~~self_eq_r16p~~CallsGraph proc~self_eq_r16p self_eq_R16P proc~norml2 normL2 proc~self_eq_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_R16P Source Code elemental function self_eq_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R16P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_R16P","tags":"","loc":"proc/self_eq_r16p.html","title":"self_eq_R16P – FLOw"},{"text":"private elemental function R8P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r8p_eq_self~~CallsGraph proc~r8p_eq_self R8P_eq_self proc~norml2 normL2 proc~r8p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_eq_self Source Code elemental function R8P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_eq_self","tags":"","loc":"proc/r8p_eq_self.html","title":"R8P_eq_self – FLOw"},{"text":"private elemental function self_eq_R8P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical Calls proc~~self_eq_r8p~~CallsGraph proc~self_eq_r8p self_eq_R8P proc~norml2 normL2 proc~self_eq_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_R8P Source Code elemental function self_eq_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_R8P","tags":"","loc":"proc/self_eq_r8p.html","title":"self_eq_R8P – FLOw"},{"text":"private elemental function R4P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r4p_eq_self~~CallsGraph proc~r4p_eq_self R4P_eq_self proc~norml2 normL2 proc~r4p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_eq_self Source Code elemental function R4P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_eq_self","tags":"","loc":"proc/r4p_eq_self.html","title":"R4P_eq_self – FLOw"},{"text":"private elemental function self_eq_R4P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical Calls proc~~self_eq_r4p~~CallsGraph proc~self_eq_r4p self_eq_R4P proc~norml2 normL2 proc~self_eq_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_R4P Source Code elemental function self_eq_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_R4P","tags":"","loc":"proc/self_eq_r4p.html","title":"self_eq_R4P – FLOw"},{"text":"private elemental function I8P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i8p_eq_self~~CallsGraph proc~i8p_eq_self I8P_eq_self proc~norml2 normL2 proc~i8p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_eq_self Source Code elemental function I8P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_eq_self","tags":"","loc":"proc/i8p_eq_self.html","title":"I8P_eq_self – FLOw"},{"text":"private elemental function self_eq_I8P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical Calls proc~~self_eq_i8p~~CallsGraph proc~self_eq_i8p self_eq_I8P proc~norml2 normL2 proc~self_eq_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_I8P Source Code elemental function self_eq_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_I8P","tags":"","loc":"proc/self_eq_i8p.html","title":"self_eq_I8P – FLOw"},{"text":"private elemental function I4P_eq_self(scal, self) result(compare) @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i4p_eq_self~~CallsGraph proc~i4p_eq_self I4P_eq_self proc~norml2 normL2 proc~i4p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_eq_self Source Code elemental function I4P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_eq_self","tags":"","loc":"proc/i4p_eq_self.html","title":"I4P_eq_self – FLOw"},{"text":"private elemental function self_eq_I4P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical Calls proc~~self_eq_i4p~~CallsGraph proc~self_eq_i4p self_eq_I4P proc~norml2 normL2 proc~self_eq_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_I4P Source Code elemental function self_eq_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_I4P","tags":"","loc":"proc/self_eq_i4p.html","title":"self_eq_I4P – FLOw"},{"text":"private elemental function I2P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i2p_eq_self~~CallsGraph proc~i2p_eq_self I2P_eq_self proc~norml2 normL2 proc~i2p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_eq_self Source Code elemental function I2P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_eq_self","tags":"","loc":"proc/i2p_eq_self.html","title":"I2P_eq_self – FLOw"},{"text":"private elemental function self_eq_I2P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical Calls proc~~self_eq_i2p~~CallsGraph proc~self_eq_i2p self_eq_I2P proc~norml2 normL2 proc~self_eq_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_I2P Source Code elemental function self_eq_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I2P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_I2P","tags":"","loc":"proc/self_eq_i2p.html","title":"self_eq_I2P – FLOw"},{"text":"private elemental function I1P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i1p_eq_self~~CallsGraph proc~i1p_eq_self I1P_eq_self proc~norml2 normL2 proc~i1p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_eq_self Source Code elemental function I1P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_eq_self","tags":"","loc":"proc/i1p_eq_self.html","title":"I1P_eq_self – FLOw"},{"text":"private elemental function self_eq_I1P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical Calls proc~~self_eq_i1p~~CallsGraph proc~self_eq_i1p self_eq_I1P proc~norml2 normL2 proc~self_eq_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_I1P Source Code elemental function self_eq_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I1P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_I1P","tags":"","loc":"proc/self_eq_i1p.html","title":"self_eq_I1P – FLOw"},{"text":"private elemental function self_great_eq_self(self1, self2) result(compare) Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical Calls proc~~self_great_eq_self~~CallsGraph proc~self_great_eq_self self_great_eq_self proc~norml2 normL2 proc~self_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_self Source Code elemental function self_great_eq_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 ! First selftor. type ( Vector ), intent ( IN ) :: self2 ! Second selftor. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) >= normL2 ( self2 )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_self","tags":"","loc":"proc/self_great_eq_self.html","title":"self_great_eq_self – FLOw"},{"text":"private elemental function R16P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r16p_great_eq_self~~CallsGraph proc~r16p_great_eq_self R16P_great_eq_self proc~norml2 normL2 proc~r16p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_great_eq_self Source Code elemental function R16P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_great_eq_self","tags":"","loc":"proc/r16p_great_eq_self.html","title":"R16P_great_eq_self – FLOw"},{"text":"private elemental function self_great_eq_R16P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical Calls proc~~self_great_eq_r16p~~CallsGraph proc~self_great_eq_r16p self_great_eq_R16P proc~norml2 normL2 proc~self_great_eq_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_R16P Source Code elemental function self_great_eq_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R16P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_R16P","tags":"","loc":"proc/self_great_eq_r16p.html","title":"self_great_eq_R16P – FLOw"},{"text":"private elemental function R8P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r8p_great_eq_self~~CallsGraph proc~r8p_great_eq_self R8P_great_eq_self proc~norml2 normL2 proc~r8p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_great_eq_self Source Code elemental function R8P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_great_eq_self","tags":"","loc":"proc/r8p_great_eq_self.html","title":"R8P_great_eq_self – FLOw"},{"text":"private elemental function self_great_eq_R8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical Calls proc~~self_great_eq_r8p~~CallsGraph proc~self_great_eq_r8p self_great_eq_R8P proc~norml2 normL2 proc~self_great_eq_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_R8P Source Code elemental function self_great_eq_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_R8P","tags":"","loc":"proc/self_great_eq_r8p.html","title":"self_great_eq_R8P – FLOw"},{"text":"private elemental function R4P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r4p_great_eq_self~~CallsGraph proc~r4p_great_eq_self R4P_great_eq_self proc~norml2 normL2 proc~r4p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_great_eq_self Source Code elemental function R4P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_great_eq_self","tags":"","loc":"proc/r4p_great_eq_self.html","title":"R4P_great_eq_self – FLOw"},{"text":"private elemental function self_great_eq_R4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical Calls proc~~self_great_eq_r4p~~CallsGraph proc~self_great_eq_r4p self_great_eq_R4P proc~norml2 normL2 proc~self_great_eq_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_R4P Source Code elemental function self_great_eq_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_R4P","tags":"","loc":"proc/self_great_eq_r4p.html","title":"self_great_eq_R4P – FLOw"},{"text":"private elemental function I8P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i8p_great_eq_self~~CallsGraph proc~i8p_great_eq_self I8P_great_eq_self proc~norml2 normL2 proc~i8p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_great_eq_self Source Code elemental function I8P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_great_eq_self","tags":"","loc":"proc/i8p_great_eq_self.html","title":"I8P_great_eq_self – FLOw"},{"text":"private elemental function self_great_eq_I8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical Calls proc~~self_great_eq_i8p~~CallsGraph proc~self_great_eq_i8p self_great_eq_I8P proc~norml2 normL2 proc~self_great_eq_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_I8P Source Code elemental function self_great_eq_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_I8P","tags":"","loc":"proc/self_great_eq_i8p.html","title":"self_great_eq_I8P – FLOw"},{"text":"private elemental function I4P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i4p_great_eq_self~~CallsGraph proc~i4p_great_eq_self I4P_great_eq_self proc~norml2 normL2 proc~i4p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_great_eq_self Source Code elemental function I4P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_great_eq_self","tags":"","loc":"proc/i4p_great_eq_self.html","title":"I4P_great_eq_self – FLOw"},{"text":"private elemental function self_great_eq_I4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical Calls proc~~self_great_eq_i4p~~CallsGraph proc~self_great_eq_i4p self_great_eq_I4P proc~norml2 normL2 proc~self_great_eq_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_I4P Source Code elemental function self_great_eq_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_I4P","tags":"","loc":"proc/self_great_eq_i4p.html","title":"self_great_eq_I4P – FLOw"},{"text":"private elemental function I2P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i2p_great_eq_self~~CallsGraph proc~i2p_great_eq_self I2P_great_eq_self proc~norml2 normL2 proc~i2p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_great_eq_self Source Code elemental function I2P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_great_eq_self","tags":"","loc":"proc/i2p_great_eq_self.html","title":"I2P_great_eq_self – FLOw"},{"text":"private elemental function self_great_eq_I2P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical Calls proc~~self_great_eq_i2p~~CallsGraph proc~self_great_eq_i2p self_great_eq_I2P proc~norml2 normL2 proc~self_great_eq_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_I2P Source Code elemental function self_great_eq_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I2P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_I2P","tags":"","loc":"proc/self_great_eq_i2p.html","title":"self_great_eq_I2P – FLOw"},{"text":"private elemental function I1P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i1p_great_eq_self~~CallsGraph proc~i1p_great_eq_self I1P_great_eq_self proc~norml2 normL2 proc~i1p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_great_eq_self Source Code elemental function I1P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_great_eq_self","tags":"","loc":"proc/i1p_great_eq_self.html","title":"I1P_great_eq_self – FLOw"},{"text":"private elemental function self_great_eq_I1P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical Calls proc~~self_great_eq_i1p~~CallsGraph proc~self_great_eq_i1p self_great_eq_I1P proc~norml2 normL2 proc~self_great_eq_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_I1P Source Code elemental function self_great_eq_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I1P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_I1P","tags":"","loc":"proc/self_great_eq_i1p.html","title":"self_great_eq_I1P – FLOw"},{"text":"private elemental function self_great_self(self1, self2) result(compare) Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical Calls proc~~self_great_self~~CallsGraph proc~self_great_self self_great_self proc~norml2 normL2 proc~self_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_self Source Code elemental function self_great_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 ! First selftor. type ( Vector ), intent ( IN ) :: self2 ! Second selftor. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) > normL2 ( self2 )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_self","tags":"","loc":"proc/self_great_self.html","title":"self_great_self – FLOw"},{"text":"private elemental function R16P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r16p_great_self~~CallsGraph proc~r16p_great_self R16P_great_self proc~norml2 normL2 proc~r16p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_great_self Source Code elemental function R16P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_great_self","tags":"","loc":"proc/r16p_great_self.html","title":"R16P_great_self – FLOw"},{"text":"private elemental function self_great_R16P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical Calls proc~~self_great_r16p~~CallsGraph proc~self_great_r16p self_great_R16P proc~norml2 normL2 proc~self_great_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_R16P Source Code elemental function self_great_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R16P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_R16P","tags":"","loc":"proc/self_great_r16p.html","title":"self_great_R16P – FLOw"},{"text":"private elemental function R8P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r8p_great_self~~CallsGraph proc~r8p_great_self R8P_great_self proc~norml2 normL2 proc~r8p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_great_self Source Code elemental function R8P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_great_self","tags":"","loc":"proc/r8p_great_self.html","title":"R8P_great_self – FLOw"},{"text":"private elemental function self_great_R8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical Calls proc~~self_great_r8p~~CallsGraph proc~self_great_r8p self_great_R8P proc~norml2 normL2 proc~self_great_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_R8P Source Code elemental function self_great_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_R8P","tags":"","loc":"proc/self_great_r8p.html","title":"self_great_R8P – FLOw"},{"text":"private elemental function R4P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r4p_great_self~~CallsGraph proc~r4p_great_self R4P_great_self proc~norml2 normL2 proc~r4p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_great_self Source Code elemental function R4P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_great_self","tags":"","loc":"proc/r4p_great_self.html","title":"R4P_great_self – FLOw"},{"text":"private elemental function self_great_R4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical Calls proc~~self_great_r4p~~CallsGraph proc~self_great_r4p self_great_R4P proc~norml2 normL2 proc~self_great_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_R4P Source Code elemental function self_great_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_R4P","tags":"","loc":"proc/self_great_r4p.html","title":"self_great_R4P – FLOw"},{"text":"private elemental function I8P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i8p_great_self~~CallsGraph proc~i8p_great_self I8P_great_self proc~norml2 normL2 proc~i8p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_great_self Source Code elemental function I8P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_great_self","tags":"","loc":"proc/i8p_great_self.html","title":"I8P_great_self – FLOw"},{"text":"private elemental function self_great_I8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical Calls proc~~self_great_i8p~~CallsGraph proc~self_great_i8p self_great_I8P proc~norml2 normL2 proc~self_great_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_I8P Source Code elemental function self_great_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_I8P","tags":"","loc":"proc/self_great_i8p.html","title":"self_great_I8P – FLOw"},{"text":"private elemental function I4P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i4p_great_self~~CallsGraph proc~i4p_great_self I4P_great_self proc~norml2 normL2 proc~i4p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_great_self Source Code elemental function I4P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_great_self","tags":"","loc":"proc/i4p_great_self.html","title":"I4P_great_self – FLOw"},{"text":"private elemental function self_great_I4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical Calls proc~~self_great_i4p~~CallsGraph proc~self_great_i4p self_great_I4P proc~norml2 normL2 proc~self_great_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_I4P Source Code elemental function self_great_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_I4P","tags":"","loc":"proc/self_great_i4p.html","title":"self_great_I4P – FLOw"},{"text":"private elemental function I2P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i2p_great_self~~CallsGraph proc~i2p_great_self I2P_great_self proc~norml2 normL2 proc~i2p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_great_self Source Code elemental function I2P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_great_self","tags":"","loc":"proc/i2p_great_self.html","title":"I2P_great_self – FLOw"},{"text":"private elemental function self_great_I2P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical Calls proc~~self_great_i2p~~CallsGraph proc~self_great_i2p self_great_I2P proc~norml2 normL2 proc~self_great_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_I2P Source Code elemental function self_great_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I2P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_I2P","tags":"","loc":"proc/self_great_i2p.html","title":"self_great_I2P – FLOw"},{"text":"private elemental function I1P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i1p_great_self~~CallsGraph proc~i1p_great_self I1P_great_self proc~norml2 normL2 proc~i1p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_great_self Source Code elemental function I1P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_great_self","tags":"","loc":"proc/i1p_great_self.html","title":"I1P_great_self – FLOw"},{"text":"private elemental function self_great_I1P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical Calls proc~~self_great_i1p~~CallsGraph proc~self_great_i1p self_great_I1P proc~norml2 normL2 proc~self_great_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_I1P Source Code elemental function self_great_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I1P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_I1P","tags":"","loc":"proc/self_great_i1p.html","title":"self_great_I1P – FLOw"},{"text":"private elemental subroutine init_vector_self(vec) Initialize components of Vector variable. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector. Source Code init_vector_self Source Code elemental subroutine init_vector_self ( vec ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize components of Vector variable. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: vec !< Vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- vec % x = 0._R8P vec % y = 0._R8P vec % z = 0._R8P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init_vector_self","tags":"","loc":"proc/init_vector_self.html","title":"init_vector_self – FLOw"},{"text":"private elemental subroutine set_vector_self(vec, x, y, z) Set components of Vector variable. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector. real(kind=R8P), intent(in), optional :: x Cartesian component in x direction. real(kind=R8P), intent(in), optional :: y Cartesian component in y direction. real(kind=R8P), intent(in), optional :: z Cartesian component in z direction. Source Code set_vector_self Source Code elemental subroutine set_vector_self ( vec , x , y , z ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set components of Vector variable. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: vec !< Vector. real ( R8P ), intent ( IN ), optional :: x !< Cartesian component in x direction. real ( R8P ), intent ( IN ), optional :: y !< Cartesian component in y direction. real ( R8P ), intent ( IN ), optional :: z !< Cartesian component in z direction. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( x )) vec % x = x if ( present ( y )) vec % y = y if ( present ( z )) vec % z = z return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_vector_self","tags":"","loc":"proc/set_vector_self.html","title":"set_vector_self – FLOw"},{"text":"private subroutine load_vector_self(vec, unit, pos, iostat, iomsg) Load Vector data. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Source Code load_vector_self Source Code subroutine load_vector_self ( vec , unit , pos , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Load Vector data. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: vec !< Vector data. integer ( I4P ), intent ( IN ) :: unit !< Logic unit. integer ( I8P ), optional , intent ( IN ) :: pos !< Position specifier. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( pos )) then read ( unit = unit , pos = pos , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z else read ( unit = unit , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine load_vector_self","tags":"","loc":"proc/load_vector_self.html","title":"load_vector_self – FLOw"},{"text":"private subroutine save_vector_self(vec, unit, pos, iostat, iomsg) Save Vector data. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Source Code save_vector_self Source Code subroutine save_vector_self ( vec , unit , pos , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save Vector data. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector data. integer ( I4P ), intent ( IN ) :: unit !< Logic unit. integer ( I8P ), optional , intent ( IN ) :: pos !< Position specifier. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( pos )) then write ( unit = unit , pos = pos , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z else write ( unit = unit , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_vector_self","tags":"","loc":"proc/save_vector_self.html","title":"save_vector_self – FLOw"},{"text":"private subroutine print_vector_self(vec, unit, pref, iostat, iomsg) Print in a pretty ascii format the components of type Vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. integer(kind=I4P), intent(in), optional :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string for outputs. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Source Code print_vector_self Source Code subroutine print_vector_self ( vec , unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print in a pretty ascii format the components of type Vector. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector. integer ( I4P ), optional , intent ( IN ) :: unit !< Logic unit. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string for outputs. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: unitd !< Logic unit. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- unitd = stdout ; if ( present ( unit )) unitd = unit prefd = '' ; if ( present ( pref )) prefd = pref write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component x ' // str ( n = vec % x ) write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component y ' // str ( n = vec % y ) write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component z ' // str ( n = vec % z ) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) return !--------------------------------------------------------------------------------------------------------------------------------- contains elemental function str ( n ) result ( str_ ) !------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( DR8P ) :: str_ !< Returned string containing input number. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- write ( str_ , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str_ ( 1 : 1 ) = '+' ! Prefixing plus if n>0. return !------------------------------------------------------------------------------------------------------------------------------- endfunction str endsubroutine print_vector_self","tags":"","loc":"proc/print_vector_self.html","title":"print_vector_self – FLOw"},{"text":"private elemental subroutine normalize_self(vec) Normalize a vector. The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the\n normalization value is set to normL2(vec)+smallR8P. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector to be normalized. Calls proc~~normalize_self~~CallsGraph proc~normalize_self normalize_self proc~norml2 normL2 proc~normalize_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code normalize_self Source Code elemental subroutine normalize_self ( vec ) !--------------------------------------------------------------------------------------------------------------------------------- !< Normalize a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the !< normalization value is set to normL2(vec)+smallR8P. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: vec !< Vector to be normalized. real ( R8P ) :: nm !< Norm L2 of vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- nm = normL2 ( vec ) if ( nm < smallR8P ) then nm = nm + smallR8P endif vec % x = vec % x / nm vec % y = vec % y / nm vec % z = vec % z / nm return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine normalize_self","tags":"","loc":"proc/normalize_self.html","title":"normalize_self – FLOw"},{"text":"private elemental subroutine face_normal4_self(fnormal, pt1, pt2, pt3, pt4, norm) Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. The convention for the points numeration is the following: 1.----------.2\n  |          |\n  |          |\n  |          |\n  |          |\n 4.----------.3 The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24.\n The normal is normalized if the variable norm is passed (with any value). Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: fnormal Face normal. type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. type( Vector ), intent(in) :: pt4 Fourth face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Calls proc~~face_normal4_self~~CallsGraph proc~face_normal4_self face_normal4_self proc~normalize normalize proc~face_normal4_self->proc~normalize proc~norml2 normL2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code face_normal4_self Source Code elemental subroutine face_normal4_self ( fnormal , pt1 , pt2 , pt3 , pt4 , norm ) !< Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. !< !< The convention for the points numeration is the following: !<``` !< 1.----------.2 !<  |          | !<  |          | !<  |          | !<  |          | !< 4.----------.3 !<``` !< The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24. !< The normal is normalized if the variable *norm* is passed (with any value). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: fnormal !< Face normal. type ( Vector ), intent ( IN ) :: pt1 !< First face point. type ( Vector ), intent ( IN ) :: pt2 !< Second face point. type ( Vector ), intent ( IN ) :: pt3 !< Third face point. type ( Vector ), intent ( IN ) :: pt4 !< Fourth face point. character ( 1 ), optional , intent ( IN ) :: norm !< If 'norm' is passed as argument the normal is normalized. type ( Vector ) :: d13 !< Face 1-3 diagonals. type ( Vector ) :: d24 !< Face 2-4 diagonals. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- d13 = pt3 - pt1 d24 = pt4 - pt2 if ( present ( norm )) then fnormal = normalize ( d13 . cross . d24 ) else fnormal = 0.5_R8P * ( d13 . cross . d24 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine face_normal4_self","tags":"","loc":"proc/face_normal4_self.html","title":"face_normal4_self – FLOw"},{"text":"private elemental subroutine face_normal3_self(fnormal, pt1, pt2, pt3, norm) Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. The convention for the points numeration is the following: 1.----.2\n   \\   |\n    \\  |\n     \\ |\n      \\|\n       .3 The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13.\n The normal is normalized if the variable norm is passed (with any value). Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: fnormal Face normal. type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Calls proc~~face_normal3_self~~CallsGraph proc~face_normal3_self face_normal3_self proc~normalize normalize proc~face_normal3_self->proc~normalize proc~norml2 normL2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code face_normal3_self Source Code elemental subroutine face_normal3_self ( fnormal , pt1 , pt2 , pt3 , norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. !< !< The convention for the points numeration is the following: !<``` !< 1.----.2 !<   \\   | !<    \\  | !<     \\ | !<      \\| !<       .3 !<``` !< The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13. !< The normal is normalized if the variable *norm* is passed (with any value). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: fnormal !< Face normal. type ( Vector ), intent ( IN ) :: pt1 !< First face point. type ( Vector ), intent ( IN ) :: pt2 !< Second face point. type ( Vector ), intent ( IN ) :: pt3 !< Third face point. character ( 1 ), optional , intent ( IN ) :: norm !< If 'norm' is passed as argument the normal is normalized. type ( Vector ) :: s12 !< Face 1-2 diagonals. type ( Vector ) :: s13 !< Face 1-3 diagonals. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- s12 = pt2 - pt1 s13 = pt3 - pt1 if ( present ( norm )) then fnormal = normalize ( s12 . cross . s13 ) else fnormal = 0.5_R8P * ( s12 . cross . s13 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine face_normal3_self","tags":"","loc":"proc/face_normal3_self.html","title":"face_normal3_self – FLOw"},{"text":"private pure subroutine assign_self(self1, self2) Assignment between two selfs. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self1 class( Vector ), intent(in) :: self2 Source Code assign_self Source Code pure subroutine assign_self ( self1 , self2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between two selfs. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self1 class ( Vector ), intent ( IN ) :: self2 !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self1 % x = self2 % x self1 % y = self2 % y self1 % z = self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_self","tags":"","loc":"proc/assign_self.html","title":"assign_self – FLOw"},{"text":"private elemental subroutine assign_ScalR16P(self, scal) Assignment between a scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R16P), intent(in) :: scal Source Code assign_ScalR16P Source Code elemental subroutine assign_ScalR16P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (real R16P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self real ( R16P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalR16P","tags":"","loc":"proc/assign_scalr16p.html","title":"assign_ScalR16P – FLOw"},{"text":"private elemental subroutine assign_ScalR8P(self, scal) Assignment between a scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R8P), intent(in) :: scal Source Code assign_ScalR8P Source Code elemental subroutine assign_ScalR8P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (real R8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( Vector ), intent ( INOUT ) :: self real ( R8P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalR8P","tags":"","loc":"proc/assign_scalr8p.html","title":"assign_ScalR8P – FLOw"},{"text":"private elemental subroutine assign_ScalR4P(self, scal) Assignment between a scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R4P), intent(in) :: scal Source Code assign_ScalR4P Source Code elemental subroutine assign_ScalR4P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (real R4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self real ( R4P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalR4P","tags":"","loc":"proc/assign_scalr4p.html","title":"assign_ScalR4P – FLOw"},{"text":"private elemental subroutine assign_ScalI8P(self, scal) Assignment between a scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I8P), intent(in) :: scal Source Code assign_ScalI8P Source Code elemental subroutine assign_ScalI8P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (integer I8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self integer ( I8P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalI8P","tags":"","loc":"proc/assign_scali8p.html","title":"assign_ScalI8P – FLOw"},{"text":"private elemental subroutine assign_ScalI4P(self, scal) Assignment between a scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I4P), intent(in) :: scal Source Code assign_ScalI4P Source Code elemental subroutine assign_ScalI4P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (integer I4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self integer ( I4P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalI4P","tags":"","loc":"proc/assign_scali4p.html","title":"assign_ScalI4P – FLOw"},{"text":"private elemental subroutine assign_ScalI2P(self, scal) Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self Assignment between a scalar (integer I2P) and self. integer(kind=I2P), intent(in) :: scal Source Code assign_ScalI2P Source Code elemental subroutine assign_ScalI2P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !> Assignment between a scalar (integer I2P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self integer ( I2P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalI2P","tags":"","loc":"proc/assign_scali2p.html","title":"assign_ScalI2P – FLOw"},{"text":"private elemental subroutine assign_ScalI1P(self, scal) Assignment between a scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I1P), intent(in) :: scal Source Code assign_ScalI1P Source Code elemental subroutine assign_ScalI1P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (integer I1P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self integer ( I1P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalI1P","tags":"","loc":"proc/assign_scali1p.html","title":"assign_ScalI1P – FLOw"},{"text":"Uses: flow_field_object flow_field_objects flow_primitive_object penf module~~flow~~UsesGraph module~flow flow module~flow_primitive_object flow_primitive_object module~flow_primitive_object->module~flow module~flow_field_object flow_field_object module~flow_field_object->module~flow module~flow_field_objects flow_field_objects module~flow_field_object->module~flow_field_objects module~penf penf module~penf->module~flow module~penf->module~flow_primitive_object module~penf->module~flow_field_object module~penf->module~flow_field_objects module~flow_field_objects->module~flow module~flow_field_objects->module~flow_primitive_object module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~vecfor VecFor iso_fortran_env->module~vecfor module~vecfor->module~flow_field_objects var panmoduleflowUsesGraph = svgPanZoom('#moduleflowUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Used By module~~flow~~UsedByGraph module~flow flow program~flow_test_primitive_assign flow_test_primitive_assign module~flow->program~flow_test_primitive_assign program~flow_test_primitive_mul flow_test_primitive_mul module~flow->program~flow_test_primitive_mul program~flow_test_primitive_not_eq flow_test_primitive_not_eq module~flow->program~flow_test_primitive_not_eq program~flow_test_primitive_add flow_test_primitive_add module~flow->program~flow_test_primitive_add program~flow_test_primitive_div flow_test_primitive_div module~flow->program~flow_test_primitive_div program~flow_test_primitive_sub flow_test_primitive_sub module~flow->program~flow_test_primitive_sub program~flow_test_primitive_eq flow_test_primitive_eq module~flow->program~flow_test_primitive_eq program~flow_test_primitive_add~2 flow_test_primitive_add module~flow->program~flow_test_primitive_add~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it.","tags":"","loc":"module/flow.html","title":"flow – FLOw"},{"text":"Uses: penf module~~flow_field_object~~UsesGraph module~flow_field_object flow_field_object module~penf penf module~penf->module~flow_field_object module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw field (abstract) object. Used By module~~flow_field_object~~UsedByGraph module~flow_field_object flow_field_object module~flow flow module~flow_field_object->module~flow module~flow_field_objects flow_field_objects module~flow_field_object->module~flow_field_objects program~flow_test_primitive_assign flow_test_primitive_assign module~flow->program~flow_test_primitive_assign program~flow_test_primitive_mul flow_test_primitive_mul module~flow->program~flow_test_primitive_mul program~flow_test_primitive_not_eq flow_test_primitive_not_eq module~flow->program~flow_test_primitive_not_eq program~flow_test_primitive_add flow_test_primitive_add module~flow->program~flow_test_primitive_add program~flow_test_primitive_div flow_test_primitive_div module~flow->program~flow_test_primitive_div program~flow_test_primitive_sub flow_test_primitive_sub module~flow->program~flow_test_primitive_sub program~flow_test_primitive_eq flow_test_primitive_eq module~flow->program~flow_test_primitive_eq program~flow_test_primitive_add~2 flow_test_primitive_add module~flow->program~flow_test_primitive_add~2 module~flow_field_objects->module~flow module~flow_primitive_object flow_primitive_object module~flow_field_objects->module~flow_primitive_object module~flow_primitive_object->module~flow var panmoduleflow_field_objectUsedByGraph = svgPanZoom('#moduleflow_field_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces abstract_assign abstract_assign_real abstract_simmetric_operator abstract_integer_op_field abstract_field_op_integer abstract_field_op_real abstract_real_op_field abstract_compare Derived Types field_object Abstract Interfaces abstract interface Assignment overloading. private pure subroutine abstract_assign (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_object ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. abstract interface Assignment overloading. private pure subroutine abstract_assign_real (lhs, rhs) Assign real to field. Arguments Type Intent Optional Attributes Name class( field_object ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. abstract interface Symmetric operator field.op.field. private pure function abstract_simmetric_operator (lhs, rhs) result(opr) Symmetric operator field.op.field. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. abstract interface Non symmetric operator integer.op.field. private pure function abstract_integer_op_field (lhs, rhs) result(opr) Non symmetric operator integer.op.field. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. abstract interface Non symmetric operator field.op.integer. private pure function abstract_field_op_integer (lhs, rhs) result(opr) Non symmetric operator field.op.integer. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. abstract interface Non symmetric operator field.op.real. private pure function abstract_field_op_real (lhs, rhs) result(opr) Non symmetric operator field.op.real. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. abstract interface Non symmetric operator real.op.field. private pure function abstract_real_op_field (lhs, rhs) result(opr) Non symmetric operator real.op.field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. abstract interface Compare overloading. private pure function abstract_compare (lhs, rhs) result(opr) Compare overloading. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Derived Types type, public, abstract :: field_object field (abstract) object. Type-Bound Procedures procedure(abstract_assign), public, pass(lhs) :: assign_field Assign fields. procedure(abstract_assign_real), public, pass(lhs) :: assign_real Assign real to field. procedure(abstract_simmetric_operator), public, pass(lhs) :: add Add fields. procedure(abstract_simmetric_operator), public, pass(lhs) :: div Divide fields. procedure(abstract_field_op_integer), public, pass(lhs) :: div_integer Divide field by integer. procedure(abstract_field_op_real), public, pass(lhs) :: div_real Divide field by real. procedure(abstract_simmetric_operator), public, pass(lhs) :: mul Multiply fields. procedure(abstract_field_op_integer), public, pass(lhs) :: mul_integer Multiply field for integer. procedure(abstract_integer_op_field), public, pass(rhs) :: integer_mul Multiply integer for field. procedure(abstract_field_op_real), public, pass(lhs) :: mul_real Multiply field for real. procedure(abstract_real_op_field), public, pass(rhs) :: real_mul Multiply real for field. procedure(abstract_simmetric_operator), public, pass(lhs) :: sub Subtract fields. procedure(abstract_field_op_integer), public, pass(lhs) :: pow_integer Power field by integer. procedure(abstract_field_op_real), public, pass(lhs) :: pow_real Power field by real. procedure(abstract_compare), public, pass(lhs) :: eq Compare (`==') fields. procedure(abstract_compare), public, pass(lhs) :: not_eq Compare (`/=') fields. generic, public :: assignment(=) => assign_field, assign_real Assignment overloading. generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(/) => div, div_integer, div_real Operator / overloading. generic, public :: operator(*) => mul, mul_integer, integer_mul, real_mul, mul_real Operator * overloading. generic, public :: operator(-) => sub Operator - overloading. generic, public :: operator(**) => pow_integer, pow_real Operator ** overloading. generic, public :: operator(==) => eq Operator /= overloading. generic, public :: operator(/=) => not_eq Operator /= overloading.","tags":"","loc":"module/flow_field_object.html","title":"flow_field_object – FLOw"},{"text":"Uses: flow_field_object penf VecFor module~~flow_field_objects~~UsesGraph module~flow_field_objects flow_field_objects module~flow_field_object flow_field_object module~flow_field_object->module~flow_field_objects module~penf penf module~penf->module~flow_field_objects module~penf->module~flow_field_object module~vecfor VecFor module~vecfor->module~flow_field_objects module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~penf_stringify var panmoduleflow_field_objectsUsesGraph = svgPanZoom('#moduleflow_field_objectsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw scalar field object. Used By module~~flow_field_objects~~UsedByGraph module~flow_field_objects flow_field_objects module~flow flow module~flow_field_objects->module~flow module~flow_primitive_object flow_primitive_object module~flow_field_objects->module~flow_primitive_object program~flow_test_primitive_assign flow_test_primitive_assign module~flow->program~flow_test_primitive_assign program~flow_test_primitive_mul flow_test_primitive_mul module~flow->program~flow_test_primitive_mul program~flow_test_primitive_not_eq flow_test_primitive_not_eq module~flow->program~flow_test_primitive_not_eq program~flow_test_primitive_add flow_test_primitive_add module~flow->program~flow_test_primitive_add program~flow_test_primitive_div flow_test_primitive_div module~flow->program~flow_test_primitive_div program~flow_test_primitive_sub flow_test_primitive_sub module~flow->program~flow_test_primitive_sub program~flow_test_primitive_eq flow_test_primitive_eq module~flow->program~flow_test_primitive_eq program~flow_test_primitive_add~2 flow_test_primitive_add module~flow->program~flow_test_primitive_add~2 module~flow_primitive_object->module~flow Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types field_object_scalar field_object_vectorial Functions scalar_add_scalar scalar_div_scalar scalar_div_integer scalar_div_real scalar_mul_object scalar_mul_integer integer_mul_scalar scalar_mul_real real_mul_scalar scalar_sub_scalar scalar_pow_integer scalar_pow_real eq_scalar not_eq_scalar vectorial_add_vectorial vectorial_div_object vectorial_div_integer vectorial_div_real vectorial_mul_object vectorial_mul_integer integer_mul_vectorial vectorial_mul_real real_mul_vectorial vectorial_sub_vectorial vectorial_pow_integer vectorial_pow_real eq_vectorial not_eq_vectorial Subroutines assign_field_scalar assign_real_scalar assign_field_vectorial assign_real_vectorial Derived Types type, public, extends( field_object ) :: field_object_scalar scalar field object. Components Type Visibility Attributes Name Initial real(kind=R_P), public :: field Scalar field. Type-Bound Procedures generic, public :: assignment(=) => assign_field, assign_real Assignment overloading. generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(/) => div, div_integer, div_real Operator / overloading. generic, public :: operator(*) => mul, mul_integer, integer_mul, real_mul, mul_real Operator * overloading. generic, public :: operator(-) => sub Operator - overloading. generic, public :: operator(**) => pow_integer, pow_real Operator ** overloading. generic, public :: operator(==) => eq Operator /= overloading. generic, public :: operator(/=) => not_eq Operator /= overloading. procedure, public, pass(lhs) :: assign_field => assign_field_scalar Assign fields. procedure, public, pass(lhs) :: assign_real => assign_real_scalar Assign real to field. procedure, public, pass(lhs) :: add => scalar_add_scalar Add fields. procedure, public, pass(lhs) :: div => scalar_div_scalar Divide fields. procedure, public, pass(lhs) :: div_integer => scalar_div_integer Divide field by integer. procedure, public, pass(lhs) :: div_real => scalar_div_real Divide field by real. procedure, public, pass(lhs) :: mul => scalar_mul_object Multiply fields. procedure, public, pass(lhs) :: mul_integer => scalar_mul_integer Multiply field for integer. procedure, public, pass(rhs) :: integer_mul => integer_mul_scalar Multiply scalar or field. procedure, public, pass(lhs) :: mul_real => scalar_mul_real Multiply field for real. procedure, public, pass(rhs) :: real_mul => real_mul_scalar Multiply real for field. procedure, public, pass(lhs) :: sub => scalar_sub_scalar Subtract fields. procedure, public, pass(lhs) :: pow_integer => scalar_pow_integer Power field by integer. procedure, public, pass(lhs) :: pow_real => scalar_pow_real Power field by real. procedure, public, pass(lhs) :: eq => eq_scalar Compare (`==') fields. procedure, public, pass(lhs) :: not_eq => not_eq_scalar Compare (`/=') fields. type, public, extends( field_object ) :: field_object_vectorial vectorial field object. Components Type Visibility Attributes Name Initial type(vector), public :: field Vectorial field. Type-Bound Procedures generic, public :: assignment(=) => assign_field, assign_real Assignment overloading. generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(/) => div, div_integer, div_real Operator / overloading. generic, public :: operator(*) => mul, mul_integer, integer_mul, real_mul, mul_real Operator * overloading. generic, public :: operator(-) => sub Operator - overloading. generic, public :: operator(**) => pow_integer, pow_real Operator ** overloading. generic, public :: operator(==) => eq Operator /= overloading. generic, public :: operator(/=) => not_eq Operator /= overloading. procedure, public, pass(lhs) :: assign_field => assign_field_vectorial Assign fields. procedure, public, pass(lhs) :: assign_real => assign_real_vectorial Assign real to field. procedure, public, pass(lhs) :: add => vectorial_add_vectorial Add fields. procedure, public, pass(lhs) :: div => vectorial_div_object Divide fields. procedure, public, pass(lhs) :: div_integer => vectorial_div_integer Divide field by integer. procedure, public, pass(lhs) :: div_real => vectorial_div_real Divide field by real. procedure, public, pass(lhs) :: mul => vectorial_mul_object Multiply fields. procedure, public, pass(lhs) :: mul_integer => vectorial_mul_integer Multiply field for integer. procedure, public, pass(rhs) :: integer_mul => integer_mul_vectorial Multiply integer for field. procedure, public, pass(lhs) :: mul_real => vectorial_mul_real Multiply field for real. procedure, public, pass(rhs) :: real_mul => real_mul_vectorial Multiply real for field. procedure, public, pass(lhs) :: sub => vectorial_sub_vectorial Subtract fields. procedure, public, pass(lhs) :: pow_integer => vectorial_pow_integer Power field by integer. procedure, public, pass(lhs) :: pow_real => vectorial_pow_real Power field by real. procedure, public, pass(lhs) :: eq => eq_vectorial Compare (`==') fields. procedure, public, pass(lhs) :: not_eq => not_eq_vectorial Compare (`/=') fields. Functions private pure function scalar_add_scalar (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function scalar_div_scalar (lhs, rhs) result(opr) Divide fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function scalar_div_integer (lhs, rhs) result(opr) Divide field by integer. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function scalar_div_real (lhs, rhs) result(opr) Divide field by real. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function scalar_mul_object (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function scalar_mul_integer (lhs, rhs) result(opr) Multiply field for integer. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function integer_mul_scalar (lhs, rhs) result(opr) Multiply integer for field. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: lhs Left hand side. class( field_object_scalar ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function scalar_mul_real (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function real_mul_scalar (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_object_scalar ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function scalar_sub_scalar (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function scalar_pow_integer (lhs, rhs) result(opr) Power field by integer. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function scalar_pow_real (lhs, rhs) result(opr) Power field by real. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function eq_scalar (lhs, rhs) result(opr) Compare ( == ) fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. private pure function not_eq_scalar (lhs, rhs) result(opr) Compare ( /= ) fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. private pure function vectorial_add_vectorial (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_div_object (lhs, rhs) result(opr) Divide fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_div_integer (lhs, rhs) result(opr) Divide field by integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_div_real (lhs, rhs) result(opr) Divide field by real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_mul_object (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_mul_integer (lhs, rhs) result(opr) Multiply field for integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function integer_mul_vectorial (lhs, rhs) result(opr) Multiply integer for field. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: lhs Left hand side. class( field_object_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_mul_real (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function real_mul_vectorial (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_object_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_sub_vectorial (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_pow_integer (lhs, rhs) result(opr) Power field by integer. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function vectorial_pow_real (lhs, rhs) result(opr) Power field by real. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function eq_vectorial (lhs, rhs) result(opr) Compare ( == ) fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. private pure function not_eq_vectorial (lhs, rhs) result(opr) Compare ( /= ) fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Subroutines private pure subroutine assign_field_scalar (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private pure subroutine assign_real_scalar (lhs, rhs) Assign real to field. Arguments Type Intent Optional Attributes Name class( field_object_scalar ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. private pure subroutine assign_field_vectorial (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private pure subroutine assign_real_vectorial (lhs, rhs) Assign real to field. Arguments Type Intent Optional Attributes Name class( field_object_vectorial ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side.","tags":"","loc":"module/flow_field_objects.html","title":"flow_field_objects – FLOw"},{"text":"Uses: flow_field_objects penf module~~flow_primitive_object~~UsesGraph module~flow_primitive_object flow_primitive_object module~flow_field_objects flow_field_objects module~flow_field_objects->module~flow_primitive_object module~penf penf module~penf->module~flow_primitive_object module~penf->module~flow_field_objects module~flow_field_object flow_field_object module~penf->module~flow_field_object module~flow_field_object->module~flow_field_objects module~vecfor VecFor module~vecfor->module~flow_field_objects iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf var panmoduleflow_primitive_objectUsesGraph = svgPanZoom('#moduleflow_primitive_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw primitive class definition. primitive is a class that handles primitive fluid dynamic variables. Note The operators of assignment (=), multiplication (*), division (/), sum (+) and subtraction (-) have been overloaded.\n Therefore this module provides a far-complete algebra. Used By module~~flow_primitive_object~~UsedByGraph module~flow_primitive_object flow_primitive_object module~flow flow module~flow_primitive_object->module~flow program~flow_test_primitive_assign flow_test_primitive_assign module~flow->program~flow_test_primitive_assign program~flow_test_primitive_mul flow_test_primitive_mul module~flow->program~flow_test_primitive_mul program~flow_test_primitive_not_eq flow_test_primitive_not_eq module~flow->program~flow_test_primitive_not_eq program~flow_test_primitive_add flow_test_primitive_add module~flow->program~flow_test_primitive_add program~flow_test_primitive_div flow_test_primitive_div module~flow->program~flow_test_primitive_div program~flow_test_primitive_sub flow_test_primitive_sub module~flow->program~flow_test_primitive_sub program~flow_test_primitive_eq flow_test_primitive_eq module~flow->program~flow_test_primitive_eq program~flow_test_primitive_add~2 flow_test_primitive_add module~flow->program~flow_test_primitive_add~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types primitive_object Functions add div div_integer div_real mul mul_integer integer_mul mul_real real_mul sub eq not_eq compatible Subroutines assign_primitive assign_real Derived Types type, public :: primitive_object FLOw primitive class definition. Components Type Visibility Attributes Name Initial type( field_object_scalar ), public :: density Density field. type( field_object_vectorial ), public :: velocity Velocity field. type( field_object_scalar ), public :: pressure Pressure field. type( field_object_scalar ), public, allocatable :: partial_densities (:) Partial densities fields. Type-Bound Procedures generic, public :: assignment(=) => assign_primitive, assign_real Assignment overloading. generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(/) => div, div_integer, div_real Operator / overloading. generic, public :: operator(*) => mul, mul_integer, integer_mul, mul_real, real_mul Operator * overloading. generic, public :: operator(-) => sub Operator - overloading. generic, public :: operator(==) => eq Operator == overloading. generic, public :: operator(/=) => not_eq Operator /= overloading. generic, public :: operator(.compatible.) => compatible Operator .compatible. overloading. procedure, private, pass(lhs) :: assign_primitive Assign primitives. procedure, private, pass(lhs) :: assign_real Assign real to primitive. procedure, private, pass(lhs) :: add Add primitives. procedure, private, pass(lhs) :: div Divide primitives. procedure, private, pass(lhs) :: div_integer Divide primitive by integer. procedure, private, pass(lhs) :: div_real Divide primitive by real. procedure, private, pass(lhs) :: mul Multiply primitives. procedure, private, pass(lhs) :: mul_integer Multiply primitive for integer. procedure, private, pass(rhs) :: integer_mul Multiply integer for primitive. procedure, private, pass(lhs) :: mul_real Multiply primitive for real. procedure, private, pass(rhs) :: real_mul Multiply real for primitive. procedure, private, pass(lhs) :: sub Subtract primitives. procedure, private, pass(lhs) :: eq Compare (`==') primitives. procedure, private, pass(lhs) :: not_eq Compare (`/=') primitives. procedure, private, pass(lhs) :: compatible Compare ( .compatible. ) primitives. Functions private elemental function add (lhs, rhs) result(opr) Add primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. private elemental function div (lhs, rhs) result(opr) Divide primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. private elemental function div_integer (lhs, rhs) result(opr) Divide primitive by integer. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. private elemental function div_real (lhs, rhs) result(opr) Divide primitive by real. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. private elemental function mul (lhs, rhs) result(opr) Multiply primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. private elemental function mul_integer (lhs, rhs) result(opr) Multiply primitive for integer. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. integer(kind=I_P), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. private elemental function integer_mul (lhs, rhs) result(opr) Multiply integer for primitive. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. private elemental function mul_real (lhs, rhs) result(opr) Multiply primitive for real. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. private elemental function real_mul (lhs, rhs) result(opr) Multiply real for primitive. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. private elemental function sub (lhs, rhs) result(opr) Subtract primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value type( primitive_object ) Operator result. private pure function eq (lhs, rhs) result(opr) Compare ( == ) primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. private pure function not_eq (lhs, rhs) result(opr) Compare ( /= ) primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. private pure function compatible (lhs, rhs) result(opr) Check primitives compatibility (size of partial densities). Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Subroutines private pure subroutine assign_primitive (lhs, rhs) Assign primitives. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: lhs Left hand side. type( primitive_object ), intent(in) :: rhs Right hand side. private pure subroutine assign_real (lhs, rhs) Assign real to primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side.","tags":"","loc":"module/flow_primitive_object.html","title":"flow_primitive_object – FLOw"},{"text":"Uses: penf_global_parameters_variables penf_b_size penf_stringify module~~penf~~UsesGraph module~penf penf module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Portability Environment for Fortran poor people. Used By module~~penf~~UsedByGraph module~penf penf program~compact_real compact_real module~penf->program~compact_real module~flow flow module~penf->module~flow program~test_all test_all module~penf->program~test_all module~flow_field_object flow_field_object module~penf->module~flow_field_object module~flow_field_objects flow_field_objects module~penf->module~flow_field_objects module~flow_primitive_object flow_primitive_object module~penf->module~flow_primitive_object program~flow_test_primitive_assign flow_test_primitive_assign module~flow->program~flow_test_primitive_assign program~flow_test_primitive_mul flow_test_primitive_mul module~flow->program~flow_test_primitive_mul program~flow_test_primitive_not_eq flow_test_primitive_not_eq module~flow->program~flow_test_primitive_not_eq program~flow_test_primitive_add flow_test_primitive_add module~flow->program~flow_test_primitive_add program~flow_test_primitive_div flow_test_primitive_div module~flow->program~flow_test_primitive_div program~flow_test_primitive_sub flow_test_primitive_sub module~flow->program~flow_test_primitive_sub program~flow_test_primitive_eq flow_test_primitive_eq module~flow->program~flow_test_primitive_eq program~flow_test_primitive_add~2 flow_test_primitive_add module~flow->program~flow_test_primitive_add~2 module~flow_field_object->module~flow module~flow_field_object->module~flow_field_objects module~flow_field_objects->module~flow module~flow_field_objects->module~flow_primitive_object module~flow_primitive_object->module~flow var panmodulepenfUsedByGraph = svgPanZoom('#modulepenfUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces bit_size digit Functions digit_I8 digit_I4 digit_I2 digit_I1 Subroutines check_endian penf_init penf_print Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. public interface digit Compute the number of digits in decimal base of the input integer. private elemental function digit_I8 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I4 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I2 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I1 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Functions private elemental function digit_I8 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I4 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I2 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I1 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Subroutines public subroutine check_endian () Check the type of bit ordering (big or little endian) of the running architecture. Arguments None public subroutine penf_init () Initialize PENF's variables that are not initialized into the definition specification. Arguments None public subroutine penf_print (unit, pref, iostat, iomsg) Print to the specified unit the PENF's environment data. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message.","tags":"","loc":"module/penf.html","title":"penf – FLOw"},{"text":"Uses: penf_global_parameters_variables module~~penf_b_size~~UsesGraph module~penf_b_size penf_b_size module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_b_size Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. PENF bit/byte size functions. Used By module~~penf_b_size~~UsedByGraph module~penf_b_size penf_b_size module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf penf module~penf_b_size->module~penf module~penf_stringify->module~penf program~compact_real compact_real module~penf->program~compact_real module~flow flow module~penf->module~flow program~test_all test_all module~penf->program~test_all module~flow_field_object flow_field_object module~penf->module~flow_field_object module~flow_field_objects flow_field_objects module~penf->module~flow_field_objects module~flow_primitive_object flow_primitive_object module~penf->module~flow_primitive_object program~flow_test_primitive_assign flow_test_primitive_assign module~flow->program~flow_test_primitive_assign program~flow_test_primitive_mul flow_test_primitive_mul module~flow->program~flow_test_primitive_mul program~flow_test_primitive_not_eq flow_test_primitive_not_eq module~flow->program~flow_test_primitive_not_eq program~flow_test_primitive_add flow_test_primitive_add module~flow->program~flow_test_primitive_add program~flow_test_primitive_div flow_test_primitive_div module~flow->program~flow_test_primitive_div program~flow_test_primitive_sub flow_test_primitive_sub module~flow->program~flow_test_primitive_sub program~flow_test_primitive_eq flow_test_primitive_eq module~flow->program~flow_test_primitive_eq program~flow_test_primitive_add~2 flow_test_primitive_add module~flow->program~flow_test_primitive_add~2 module~flow_field_object->module~flow module~flow_field_object->module~flow_field_objects module~flow_field_objects->module~flow module~flow_field_objects->module~flow_primitive_object module~flow_primitive_object->module~flow var panmodulepenf_b_sizeUsedByGraph = svgPanZoom('#modulepenf_b_sizeUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces bit_size byte_size Functions bit_size_R16P bit_size_R8P bit_size_R4P bit_size_chr byte_size_I8P byte_size_I4P byte_size_I2P byte_size_I1P byte_size_R16P byte_size_R8P byte_size_R4P byte_size_chr Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. private elemental function bit_size_R8P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_R4P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_chr (i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. public interface byte_size Compute the number of bytes of a variable. private elemental function byte_size_I8P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I4P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I2P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I1P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_R8P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R4P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_chr (i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Functions private elemental function bit_size_R16P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. private elemental function bit_size_R8P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_R4P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_chr (i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. private elemental function byte_size_I8P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I4P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I2P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I1P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_R16P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R8P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R4P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_chr (i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c.","tags":"","loc":"module/penf_b_size.html","title":"penf_b_size – FLOw"},{"text":"PENF global (exposed) parameters and variables. Note All module defined entities are public. Used By module~~penf_global_parameters_variables~~UsedByGraph module~penf_global_parameters_variables penf_global_parameters_variables module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf penf module~penf_global_parameters_variables->module~penf module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify program~compact_real compact_real module~penf->program~compact_real module~flow flow module~penf->module~flow program~test_all test_all module~penf->program~test_all module~flow_field_object flow_field_object module~penf->module~flow_field_object module~flow_field_objects flow_field_objects module~penf->module~flow_field_objects module~flow_primitive_object flow_primitive_object module~penf->module~flow_primitive_object module~penf_stringify->module~penf program~flow_test_primitive_assign flow_test_primitive_assign module~flow->program~flow_test_primitive_assign program~flow_test_primitive_mul flow_test_primitive_mul module~flow->program~flow_test_primitive_mul program~flow_test_primitive_not_eq flow_test_primitive_not_eq module~flow->program~flow_test_primitive_not_eq program~flow_test_primitive_add flow_test_primitive_add module~flow->program~flow_test_primitive_add program~flow_test_primitive_div flow_test_primitive_div module~flow->program~flow_test_primitive_div program~flow_test_primitive_sub flow_test_primitive_sub module~flow->program~flow_test_primitive_sub program~flow_test_primitive_eq flow_test_primitive_eq module~flow->program~flow_test_primitive_eq program~flow_test_primitive_add~2 flow_test_primitive_add module~flow->program~flow_test_primitive_add~2 module~flow_field_object->module~flow module~flow_field_object->module~flow_field_objects module~flow_field_objects->module~flow module~flow_field_objects->module~flow_primitive_object module~flow_primitive_object->module~flow var panmodulepenf_global_parameters_variablesUsedByGraph = svgPanZoom('#modulepenf_global_parameters_variablesUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables is_initialized endianL endianB endian R16P R8P R4P R_P I8P I4P I2P I1P I_P FR16P FR8P FR4P FR_P FI8P FI8PZP FI4P FI4PZP FI2P FI2PZP FI1P FI1PZP FI_P FI_PZP DR16P DR8P DR4P DR_P DI8P DI4P DI2P DI1P DI_P REAL_KINDS_LIST REAL_FORMATS_LIST INTEGER_KINDS_LIST INTEGER_FORMATS_LIST MinR16P MaxR16P MinR8P MaxR8P MinR4P MaxR4P MinR_P MaxR_P MinI8P MinI4P MinI2P MinI1P MinI_P MaxI8P MaxI4P MaxI2P MaxI1P MaxI_P smallR16P smallR8P smallR4P smallR_P ZeroR16 ZeroR8 ZeroR4 Zero BIR16P BIR8P BIR4P BIR_P BYR16P BYR8P BYR4P BYR_P BII8P BII4P BII2P BII1P BII_P BYI8P BYI4P BYI2P BYI1P BYI_P Variables Type Visibility Attributes Name Initial logical, public :: is_initialized = .false. Check the initialization of some variables that must be initialized. integer, public, parameter :: endianL = 1 Little endian parameter. integer, public, parameter :: endianB = 0 Big endian parameter. integer, public :: endian = endianL Bit ordering: Little endian (endianL), or Big endian (endianB). integer, public, parameter :: R16P = selected_real_kind(15, 307) Defined as R8P; 64 bits. integer, public, parameter :: R8P = selected_real_kind(15, 307) 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision. character(len=*), public, parameter :: FR16P = '(E23.15E3)' Output format for kind=R16P real. character(len=*), public, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P real. character(len=*), public, parameter :: FR4P = '(E13.6E2)' Output format for kind=R4P real. character(len=*), public, parameter :: FR_P = FR8P Output format for kind=R_P real. character(len=*), public, parameter :: FI8P = '(I20)' Output format for kind=I8P integer. character(len=*), public, parameter :: FI8PZP = '(I20.19)' Output format for kind=I8P integer with zero prefixing. character(len=*), public, parameter :: FI4P = '(I11)' Output format for kind=I4P integer. character(len=*), public, parameter :: FI4PZP = '(I11.10)' Output format for kind=I4P integer with zero prefixing. character(len=*), public, parameter :: FI2P = '(I6)' Output format for kind=I2P integer. character(len=*), public, parameter :: FI2PZP = '(I6.5)' Output format for kind=I2P integer with zero prefixing. character(len=*), public, parameter :: FI1P = '(I4)' Output format for kind=I1P integer. character(len=*), public, parameter :: FI1PZP = '(I4.3)' Output format for kind=I1P integer with zero prefixing. character(len=*), public, parameter :: FI_P = FI4P Output format for kind=I_P integer. character(len=*), public, parameter :: FI_PZP = FI4PZP Output format for kind=I_P integer with zero prefixing. integer, public, parameter :: DR16P = 23 Number of digits of output format FR16P. integer, public, parameter :: DR8P = 23 Number of digits of output format FR8P. integer, public, parameter :: DR4P = 13 Number of digits of output format FR4P. integer, public, parameter :: DR_P = DR8P Number of digits of output format FR_P. integer, public, parameter :: DI8P = 20 Number of digits of output format I8P. integer, public, parameter :: DI4P = 11 Number of digits of output format I4P. integer, public, parameter :: DI2P = 6 Number of digits of output format I2P. integer, public, parameter :: DI1P = 4 Number of digits of output format I1P. integer, public, parameter :: DI_P = DI4P Number of digits of output format I_P. integer, public, parameter :: REAL_KINDS_LIST (1:4) = [R16P, R8P, R4P, R_P] List of real kinds. character(len=*), public, parameter :: REAL_FORMATS_LIST (1:4) = [FR16P, FR8P, FR4P//' ', FR_P] List of real formats. integer, public, parameter :: INTEGER_KINDS_LIST (1:5) = [I8P, I4P, I2P, I1P, I_P] List of integer kinds. character(len=*), public, parameter :: INTEGER_FORMATS_LIST (1:5) = [FI8P, FI4P, FI2P//' ', FI1P//' ', FI_P] List of integer formats. real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) Minimum value of kind=R16P real. real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) Maximum value of kind=R16P real. real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) Minimum value of kind=R8P real. real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) Maximum value of kind=R8P real. real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) Minimum value of kind=R4P real. real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) Maximum value of kind=R4P real. real(kind=R_P), public, parameter :: MinR_P = MinR8P Minimum value of kind=R_P real. real(kind=R_P), public, parameter :: MaxR_P = MaxR8P Maximum value of kind=R_P real. integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P) Minimum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P) Minimum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P) Minimum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MinI1P = -huge(1_I1P) Minimum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MinI_P = MinI4P Minimum value of kind=I_P integer. integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) Maximum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) Maximum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) Maximum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MaxI1P = huge(1_I1P) Maximum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MaxI_P = MaxI4P Maximum value of kind=I_P integer. real(kind=R16P), public, parameter :: smallR16P = tiny(1._R16P) Smallest representable value of kind=R16P real. real(kind=R8P), public, parameter :: smallR8P = tiny(1._R8P) Smallest representable value of kind=R8P real. real(kind=R4P), public, parameter :: smallR4P = tiny(1._R4P) Smallest representable value of kind=R4P real. real(kind=R_P), public, parameter :: smallR_P = smallR8P Smallest representable value of kind=R_P real. real(kind=R16P), public, parameter :: ZeroR16 = nearest(1._R16P, 1._R16P)-nearest(1._R16P, -1._R16P) Smallest representable difference of kind=R16P real. real(kind=R8P), public, parameter :: ZeroR8 = nearest(1._R8P, 1._R8P)-nearest(1._R8P, -1._R8P) Smallest representable difference of kind=R8P real. real(kind=R4P), public, parameter :: ZeroR4 = nearest(1._R4P, 1._R4P)-nearest(1._R4P, -1._R4P) Smallest representable difference of kind=R4P real. real(kind=R_P), public, parameter :: Zero = ZeroR8 Smallest representable difference of kind=R_P real. integer(kind=I2P), public :: BIR16P Number of bits of kind=R16P real. integer(kind=I1P), public :: BIR8P Number of bits of kind=R8P real. integer(kind=I1P), public :: BIR4P Number of bits of kind=R4P real. integer(kind=I1P), public :: BIR_P Number of bits of kind=R_P real. integer(kind=I2P), public :: BYR16P Number of bytes of kind=R16P real. integer(kind=I1P), public :: BYR8P Number of bytes of kind=R8P real. integer(kind=I1P), public :: BYR4P Number of bytes of kind=R4P real. integer(kind=I1P), public :: BYR_P Number of bytes of kind=R_P real. integer(kind=I8P), public, parameter :: BII8P = bit_size(MaxI8P) Number of bits of kind=I8P integer. integer(kind=I4P), public, parameter :: BII4P = bit_size(MaxI4P) Number of bits of kind=I4P integer. integer(kind=I2P), public, parameter :: BII2P = bit_size(MaxI2P) Number of bits of kind=I2P integer. integer(kind=I1P), public, parameter :: BII1P = bit_size(MaxI1P) Number of bits of kind=I1P integer. integer(kind=I_P), public, parameter :: BII_P = bit_size(MaxI_P) Number of bits of kind=I_P integer. integer(kind=I8P), public, parameter :: BYI8P = bit_size(MaxI8P)/8_I8P Number of bytes of kind=I8P integer. integer(kind=I4P), public, parameter :: BYI4P = bit_size(MaxI4P)/8_I4P Number of bytes of kind=I4P integer. integer(kind=I2P), public, parameter :: BYI2P = bit_size(MaxI2P)/8_I2P Number of bytes of kind=I2P integer. integer(kind=I1P), public, parameter :: BYI1P = bit_size(MaxI1P)/8_I1P Number of bytes of kind=I1P integer. integer(kind=I_P), public, parameter :: BYI_P = bit_size(MaxI_P)/8_I_P Number of bytes of kind=I_P integer.","tags":"","loc":"module/penf_global_parameters_variables.html","title":"penf_global_parameters_variables – FLOw"},{"text":"Uses: iso_fortran_env penf_b_size penf_global_parameters_variables module~~penf_stringify~~UsesGraph module~penf_stringify penf_stringify module~penf_b_size penf_b_size module~penf_b_size->module~penf_stringify iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_stringify module~penf_global_parameters_variables->module~penf_b_size Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. PENF string-to-number (and viceversa) facility. Used By module~~penf_stringify~~UsedByGraph module~penf_stringify penf_stringify module~penf penf module~penf_stringify->module~penf program~compact_real compact_real module~penf->program~compact_real module~flow flow module~penf->module~flow program~test_all test_all module~penf->program~test_all module~flow_field_object flow_field_object module~penf->module~flow_field_object module~flow_field_objects flow_field_objects module~penf->module~flow_field_objects module~flow_primitive_object flow_primitive_object module~penf->module~flow_primitive_object program~flow_test_primitive_assign flow_test_primitive_assign module~flow->program~flow_test_primitive_assign program~flow_test_primitive_mul flow_test_primitive_mul module~flow->program~flow_test_primitive_mul program~flow_test_primitive_not_eq flow_test_primitive_not_eq module~flow->program~flow_test_primitive_not_eq program~flow_test_primitive_add flow_test_primitive_add module~flow->program~flow_test_primitive_add program~flow_test_primitive_div flow_test_primitive_div module~flow->program~flow_test_primitive_div program~flow_test_primitive_sub flow_test_primitive_sub module~flow->program~flow_test_primitive_sub program~flow_test_primitive_eq flow_test_primitive_eq module~flow->program~flow_test_primitive_eq program~flow_test_primitive_add~2 flow_test_primitive_add module~flow->program~flow_test_primitive_add~2 module~flow_field_object->module~flow module~flow_field_object->module~flow_field_objects module~flow_field_objects->module~flow module~flow_field_objects->module~flow_primitive_object module~flow_primitive_object->module~flow var panmodulepenf_stringifyUsedByGraph = svgPanZoom('#modulepenf_stringifyUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces str strz cton bstr bcton Functions strf_R16P strf_R8P strf_R4P strf_I8P strf_I4P strf_I2P strf_I1P str_R16P str_R8P str_R4P str_I8P str_I4P str_I2P str_I1P str_bol str_a_R16P str_a_R8P str_a_R4P str_a_I8P str_a_I4P str_a_I2P str_a_I1P strz_I8P strz_I4P strz_I2P strz_I1P ctor_R16P ctor_R8P ctor_R4P ctoi_I8P ctoi_I4P ctoi_I2P ctoi_I1P bstr_R16P bstr_R8P bstr_R4P bstr_I8P bstr_I4P bstr_I2P bstr_I1P bctor_R16P bctor_R8P bctor_R4P bctoi_I8P bctoi_I4P bctoi_I2P bctoi_I1P Subroutines compact_real_string Interfaces public interface str Convert number (real and integer) to string (number to string type casting). private elemental function strf_R8P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. private elemental function str_R8P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. private elemental function strf_R4P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. private elemental function str_R4P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. private elemental function strf_I8P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. private elemental function str_I8P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strf_I4P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. private elemental function str_I4P (n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strf_I2P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. private elemental function str_I2P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strf_I1P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. private elemental function str_I1P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function str_bol (n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. private pure function str_a_R8P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R4P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I8P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I4P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I2P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I1P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). private elemental function strz_I8P (n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strz_I4P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strz_I2P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strz_I1P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. public interface cton Convert string to number (real and integer, string to number type casting). private function ctor_R8P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. private function ctor_R4P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. private function ctoi_I8P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. private function ctoi_I4P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. private function ctoi_I2P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. private function ctoi_I1P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). private elemental function bstr_R8P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_R4P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I8P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_I4P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I2P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. private elemental function bstr_I1P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). private elemental function bctor_R8P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. private elemental function bctor_R4P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. private elemental function bctoi_I8P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. private elemental function bctoi_I4P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. private elemental function bctoi_I2P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. private elemental function bctoi_I1P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Functions private elemental function strf_R16P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. private elemental function strf_R8P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. private elemental function strf_R4P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. private elemental function strf_I8P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. private elemental function strf_I4P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. private elemental function strf_I2P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. private elemental function strf_I1P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. private elemental function str_R16P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR16P) Returned string containing input number. private elemental function str_R8P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. private elemental function str_R4P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. private elemental function str_I8P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function str_I4P (n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function str_I2P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function str_I1P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function str_bol (n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. private pure function str_a_R16P (n, no_sign, separator, delimiters, compact) result(str) Converting real array to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator (1) Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R8P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R4P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I8P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I4P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I2P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I1P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private elemental function strz_I8P (n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strz_I4P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strz_I2P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strz_I1P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private function ctor_R16P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. private function ctor_R8P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. private function ctor_R4P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. private function ctoi_I8P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. private function ctoi_I4P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. private function ctoi_I2P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. private function ctoi_I1P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. private elemental function bstr_R16P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. private elemental function bstr_R8P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_R4P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I8P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_I4P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I2P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. private elemental function bstr_I1P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. private elemental function bctor_R16P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. private elemental function bctor_R8P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. private elemental function bctor_R4P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. private elemental function bctoi_I8P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. private elemental function bctoi_I4P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. private elemental function bctoi_I2P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. private elemental function bctoi_I1P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Subroutines private pure subroutine compact_real_string (string) Author Izaak Beekman Date 02/24/2015 Compact a string representing a real number, so that the same value is displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string string representation of a real number.","tags":"","loc":"module/penf_stringify.html","title":"penf_stringify – FLOw"},{"text":"Uses: iso_fortran_env module~~vecfor~~UsesGraph module~vecfor VecFor iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Module definition of class Vector. This derived type is useful for manipulating vectors in 3D space. The components of the vectors are reals with\n parametrized kind as defined by the library module. The components are defined in a three-dimensional cartesian frame of\n reference.\n All the vectorial math procedures (cross, dot products, parallel…) assume a three-dimensional cartesian frame of reference.\n The operators of assignment ( = ), multiplication ( * ), division ( / ), sum ( + ) and subtraction ( - ) have been overloaded.\n Furthermore the dot and cross products have been defined.\n Therefore this module provides a far-complete algebra based on Vector derived type. Used By module~~vecfor~~UsedByGraph module~vecfor VecFor module~flow_field_objects flow_field_objects module~vecfor->module~flow_field_objects program~kinds kinds module~vecfor->program~kinds program~simple simple module~vecfor->program~simple module~flow flow module~flow_field_objects->module~flow module~flow_primitive_object flow_primitive_object module~flow_field_objects->module~flow_primitive_object program~flow_test_primitive_assign flow_test_primitive_assign module~flow->program~flow_test_primitive_assign program~flow_test_primitive_mul flow_test_primitive_mul module~flow->program~flow_test_primitive_mul program~flow_test_primitive_not_eq flow_test_primitive_not_eq module~flow->program~flow_test_primitive_not_eq program~flow_test_primitive_add flow_test_primitive_add module~flow->program~flow_test_primitive_add program~flow_test_primitive_div flow_test_primitive_div module~flow->program~flow_test_primitive_div program~flow_test_primitive_sub flow_test_primitive_sub module~flow->program~flow_test_primitive_sub program~flow_test_primitive_eq flow_test_primitive_eq module~flow->program~flow_test_primitive_eq program~flow_test_primitive_add~2 flow_test_primitive_add module~flow->program~flow_test_primitive_add~2 module~flow_primitive_object->module~flow Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables R16P R8P R4P I8P I4P I2P I1P smallR8P DR8P FR8P ex ey ez Derived Types Vector Vector_Ptr Functions sq_norm normL2 normalize face_normal4 face_normal3 iolen_vector_self normalized_self sq_norm_self normL2_self crossproduct dotproduct parallel orthogonal self_mul_self ScalR16P_mul_self self_mul_ScalR16P ScalR8P_mul_self self_mul_ScalR8P ScalR4P_mul_self self_mul_ScalR4P ScalI8P_mul_self self_mul_ScalI8P ScalI4P_mul_self self_mul_ScalI4P ScalI2P_mul_self self_mul_ScalI2P ScalI1P_mul_self self_mul_ScalI1P self_div_self self_div_ScalR16P self_div_ScalR8P self_div_ScalR4P self_div_ScalI8P self_div_ScalI4P self_div_ScalI2P self_div_ScalI1P positive_self self_sum_self ScalR16P_sum_self self_sum_ScalR16P ScalR8P_sum_self self_sum_ScalR8P ScalR4P_sum_self self_sum_ScalR4P ScalI8P_sum_self self_sum_ScalI8P ScalI4P_sum_self self_sum_ScalI4P ScalI2P_sum_self self_sum_ScalI2P ScalI1P_sum_self self_sum_ScalI1P negative_self self_sub_self ScalR16P_sub_self self_sub_ScalR16P ScalR8P_sub_self self_sub_ScalR8P ScalR4P_sub_self self_sub_ScalR4P ScalI8P_sub_self self_sub_ScalI8P ScalI4P_sub_self self_sub_ScalI4P ScalI2P_sub_self self_sub_ScalI2P ScalI1P_sub_self self_sub_ScalI1P self_not_eq_self R16P_not_eq_self self_not_eq_R16P R8P_not_eq_self self_not_eq_R8P R4P_not_eq_self self_not_eq_R4P I8P_not_eq_self self_not_eq_I8P I4P_not_eq_self self_not_eq_I4P I2P_not_eq_self self_not_eq_I2P I1P_not_eq_self self_not_eq_I1P self_low_self R16P_low_self self_low_R16P R8P_low_self self_low_R8P R4P_low_self self_low_R4P I8P_low_self self_low_I8P I4P_low_self self_low_I4P I2P_low_self self_low_I2P I1P_low_self self_low_I1P self_low_eq_self R16P_low_eq_self self_low_eq_R16P R8P_low_eq_self self_low_eq_R8P R4P_low_eq_self self_low_eq_R4P I8P_low_eq_self self_low_eq_I8P I4P_low_eq_self self_low_eq_I4P I2P_low_eq_self self_low_eq_I2P I1P_low_eq_self self_low_eq_I1P self_eq_self R16P_eq_self self_eq_R16P R8P_eq_self self_eq_R8P R4P_eq_self self_eq_R4P I8P_eq_self self_eq_I8P I4P_eq_self self_eq_I4P I2P_eq_self self_eq_I2P I1P_eq_self self_eq_I1P self_great_eq_self R16P_great_eq_self self_great_eq_R16P R8P_great_eq_self self_great_eq_R8P R4P_great_eq_self self_great_eq_R4P I8P_great_eq_self self_great_eq_I8P I4P_great_eq_self self_great_eq_I4P I2P_great_eq_self self_great_eq_I2P I1P_great_eq_self self_great_eq_I1P self_great_self R16P_great_self self_great_R16P R8P_great_self self_great_R8P R4P_great_self self_great_R4P I8P_great_self self_great_I8P I4P_great_self self_great_I4P I2P_great_self self_great_I2P I1P_great_self self_great_I1P Subroutines init_vector_self set_vector_self load_vector_self save_vector_self print_vector_self normalize_self face_normal4_self face_normal3_self assign_self assign_ScalR16P assign_ScalR8P assign_ScalR4P assign_ScalI8P assign_ScalI4P assign_ScalI2P assign_ScalI1P Variables Type Visibility Attributes Name Initial integer, private, parameter :: R16P = selected_real_kind(15, 307) Defined as R8P; 64 bits. integer, private, parameter :: R8P = selected_real_kind(15, 307) 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, private, parameter :: R4P = selected_real_kind(6, 37) 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, private, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, private, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, private, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, private, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. real(kind=R8P), private, parameter :: smallR8P = tiny(1._R8P) Smallest (module) representable value of kind=R8P variable. integer, private, parameter :: DR8P = 23 Number of digits of output format FR8P. character(len=10), private, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P variable. type( Vector ), public, parameter :: ex = Vector(1._R8P, 0._R8P, 0._R8P) X direction versor. type( Vector ), public, parameter :: ey = Vector(0._R8P, 1._R8P, 0._R8P) Y direction versor. type( Vector ), public, parameter :: ez = Vector(0._R8P, 0._R8P, 1._R8P) Z direction versor. Derived Types type, public :: Vector Vector class. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: x = 0._R8P Cartesian component in x direction. real(kind=R8P), public :: y = 0._R8P Cartesian component in y direction. real(kind=R8P), public :: z = 0._R8P Cartesian component in z direction. Type-Bound Procedures procedure, public :: init => init_vector_self procedure, public :: set => set_vector_self procedure, public :: iolen => iolen_vector_self procedure, public :: load => load_vector_self procedure, public :: save => save_vector_self procedure, public :: print => print_vector_self procedure, public :: sq_norm => sq_norm_self procedure, public :: normL2 => normL2_self procedure, public :: normalize => normalize_self procedure, public :: normalized => normalized_self procedure, public :: face_normal4 => face_normal4_self procedure, public :: face_normal3 => face_normal3_self generic, public :: operator(.cross.) => crossproduct generic, public :: operator(.dot.) => dotproduct generic, public :: operator(.paral.) => parallel generic, public :: operator(.ortho.) => orthogonal procedure, private, pass(vec1) :: crossproduct procedure, private, pass(vec1) :: dotproduct procedure, private, pass(vec1) :: parallel procedure, private, pass(vec1) :: orthogonal generic, public :: assignment(=) => assign_self, assign_ScalR8P, assign_ScalR4P, assign_ScalI8P, assign_ScalI4P, assign_ScalI2P, assign_ScalI1P procedure, private, pass(self1) :: assign_self procedure, private, pass(self ) :: assign_ScalR8P procedure, private, pass(self ) :: assign_ScalR4P procedure, private, pass(self ) :: assign_ScalI8P procedure, private, pass(self ) :: assign_ScalI4P procedure, private, pass(self ) :: assign_ScalI2P procedure, private, pass(self ) :: assign_ScalI1P generic, public :: operator(*) => self_mul_self, ScalR8P_mul_self, self_mul_ScalR8P, ScalR4P_mul_self, self_mul_ScalR4P, ScalI8P_mul_self, self_mul_ScalI8P, ScalI4P_mul_self, self_mul_ScalI4P, ScalI2P_mul_self, self_mul_ScalI2P, ScalI1P_mul_self, self_mul_ScalI1P procedure, private, pass(self1) :: self_mul_self procedure, private, pass(self ) :: ScalR8P_mul_self procedure, private, pass(self ) :: ScalR4P_mul_self procedure, private, pass(self ) :: ScalI8P_mul_self procedure, private, pass(self ) :: ScalI4P_mul_self procedure, private, pass(self ) :: ScalI2P_mul_self procedure, private, pass(self ) :: ScalI1P_mul_self procedure, private, pass(self ) :: self_mul_ScalR8P procedure, private, pass(self ) :: self_mul_ScalR4P procedure, private, pass(self ) :: self_mul_ScalI8P procedure, private, pass(self ) :: self_mul_ScalI4P procedure, private, pass(self ) :: self_mul_ScalI2P procedure, private, pass(self ) :: self_mul_ScalI1P generic, public :: operator(/) => self_div_self, self_div_ScalR8P, self_div_ScalR4P, self_div_ScalI8P, self_div_ScalI4P, self_div_ScalI2P, self_div_ScalI1P procedure, private, pass(self1) :: self_div_self procedure, private, pass(self ) :: self_div_ScalR8P procedure, private, pass(self ) :: self_div_ScalR4P procedure, private, pass(self ) :: self_div_ScalI8P procedure, private, pass(self ) :: self_div_ScalI4P procedure, private, pass(self ) :: self_div_ScalI2P procedure, private, pass(self ) :: self_div_ScalI1P generic, public :: operator(+) => positive_self, self_sum_self, ScalR8P_sum_self, self_sum_ScalR8P, ScalR4P_sum_self, self_sum_ScalR4P, ScalI8P_sum_self, self_sum_ScalI8P, ScalI4P_sum_self, self_sum_ScalI4P, ScalI2P_sum_self, self_sum_ScalI2P, ScalI1P_sum_self, self_sum_ScalI1P procedure, private, pass(self ) :: positive_self procedure, private, pass(self1) :: self_sum_self procedure, private, pass(self ) :: ScalR8P_sum_self procedure, private, pass(self ) :: ScalR4P_sum_self procedure, private, pass(self ) :: ScalI8P_sum_self procedure, private, pass(self ) :: ScalI4P_sum_self procedure, private, pass(self ) :: ScalI2P_sum_self procedure, private, pass(self ) :: ScalI1P_sum_self procedure, private, pass(self ) :: self_sum_ScalR8P procedure, private, pass(self ) :: self_sum_ScalR4P procedure, private, pass(self ) :: self_sum_ScalI8P procedure, private, pass(self ) :: self_sum_ScalI4P procedure, private, pass(self ) :: self_sum_ScalI2P procedure, private, pass(self ) :: self_sum_ScalI1P generic, public :: operator(-) => negative_self, self_sub_self, ScalR8P_sub_self, self_sub_ScalR8P, ScalR4P_sub_self, self_sub_ScalR4P, ScalI8P_sub_self, self_sub_ScalI8P, ScalI4P_sub_self, self_sub_ScalI4P, ScalI2P_sub_self, self_sub_ScalI2P, ScalI1P_sub_self, self_sub_ScalI1P procedure, private, pass(self ) :: negative_self procedure, private, pass(self1) :: self_sub_self procedure, private, pass(self ) :: ScalR8P_sub_self procedure, private, pass(self ) :: ScalR4P_sub_self procedure, private, pass(self ) :: ScalI8P_sub_self procedure, private, pass(self ) :: ScalI4P_sub_self procedure, private, pass(self ) :: ScalI2P_sub_self procedure, private, pass(self ) :: ScalI1P_sub_self procedure, private, pass(self ) :: self_sub_ScalR8P procedure, private, pass(self ) :: self_sub_ScalR4P procedure, private, pass(self ) :: self_sub_ScalI8P procedure, private, pass(self ) :: self_sub_ScalI4P procedure, private, pass(self ) :: self_sub_ScalI2P procedure, private, pass(self ) :: self_sub_ScalI1P generic, public :: operator(/=) => self_not_eq_self, R8P_not_eq_self, self_not_eq_R8P, R4P_not_eq_self, self_not_eq_R4P, I8P_not_eq_self, self_not_eq_I8P, I4P_not_eq_self, self_not_eq_I4P, I2P_not_eq_self, self_not_eq_I2P, I1P_not_eq_self, self_not_eq_I1P generic, public :: operator(<) => self_low_self, R8P_low_self, self_low_R8P, R4P_low_self, self_low_R4P, I8P_low_self, self_low_I8P, I4P_low_self, self_low_I4P, I2P_low_self, self_low_I2P, I1P_low_self, self_low_I1P generic, public :: operator(<=) => self_low_eq_self, R8P_low_eq_self, self_low_eq_R8P, R4P_low_eq_self, self_low_eq_R4P, I8P_low_eq_self, self_low_eq_I8P, I4P_low_eq_self, self_low_eq_I4P, I2P_low_eq_self, self_low_eq_I2P, I1P_low_eq_self, self_low_eq_I1P generic, public :: operator(==) => self_eq_self, R8P_eq_self, self_eq_R8P, R4P_eq_self, self_eq_R4P, I8P_eq_self, self_eq_I8P, I4P_eq_self, self_eq_I4P, I2P_eq_self, self_eq_I2P, I1P_eq_self, self_eq_I1P generic, public :: operator(>=) => self_great_eq_self, R8P_great_eq_self, self_great_eq_R8P, R4P_great_eq_self, self_great_eq_R4P, I8P_great_eq_self, self_great_eq_I8P, I4P_great_eq_self, self_great_eq_I4P, I2P_great_eq_self, self_great_eq_I2P, I1P_great_eq_self, self_great_eq_I1P generic, public :: operator(>) => self_great_self, R8P_great_self, self_great_R8P, R4P_great_self, self_great_R4P, I8P_great_self, self_great_I8P, I4P_great_self, self_great_I4P, I2P_great_self, self_great_I2P, I1P_great_self, self_great_I1P procedure, private, pass(self1) :: self_not_eq_self procedure, private, pass(self ) :: R8P_not_eq_self procedure, private, pass(self ) :: R4P_not_eq_self procedure, private, pass(self ) :: I8P_not_eq_self procedure, private, pass(self ) :: I4P_not_eq_self procedure, private, pass(self ) :: I2P_not_eq_self procedure, private, pass(self ) :: I1P_not_eq_self procedure, private, pass(self ) :: self_not_eq_R8P procedure, private, pass(self ) :: self_not_eq_R4P procedure, private, pass(self ) :: self_not_eq_I8P procedure, private, pass(self ) :: self_not_eq_I4P procedure, private, pass(self ) :: self_not_eq_I2P procedure, private, pass(self ) :: self_not_eq_I1P procedure, private, pass(self1) :: self_low_self procedure, private, pass(self ) :: R8P_low_self procedure, private, pass(self ) :: R4P_low_self procedure, private, pass(self ) :: I8P_low_self procedure, private, pass(self ) :: I4P_low_self procedure, private, pass(self ) :: I2P_low_self procedure, private, pass(self ) :: I1P_low_self procedure, private, pass(self ) :: self_low_R8P procedure, private, pass(self ) :: self_low_R4P procedure, private, pass(self ) :: self_low_I8P procedure, private, pass(self ) :: self_low_I4P procedure, private, pass(self ) :: self_low_I2P procedure, private, pass(self ) :: self_low_I1P procedure, private, pass(self1) :: self_low_eq_self procedure, private, pass(self ) :: R8P_low_eq_self procedure, private, pass(self ) :: R4P_low_eq_self procedure, private, pass(self ) :: I8P_low_eq_self procedure, private, pass(self ) :: I4P_low_eq_self procedure, private, pass(self ) :: I2P_low_eq_self procedure, private, pass(self ) :: I1P_low_eq_self procedure, private, pass(self ) :: self_low_eq_R8P procedure, private, pass(self ) :: self_low_eq_R4P procedure, private, pass(self ) :: self_low_eq_I8P procedure, private, pass(self ) :: self_low_eq_I4P procedure, private, pass(self ) :: self_low_eq_I2P procedure, private, pass(self ) :: self_low_eq_I1P procedure, private, pass(self1) :: self_eq_self procedure, private, pass(self ) :: R8P_eq_self procedure, private, pass(self ) :: R4P_eq_self procedure, private, pass(self ) :: I8P_eq_self procedure, private, pass(self ) :: I4P_eq_self procedure, private, pass(self ) :: I2P_eq_self procedure, private, pass(self ) :: I1P_eq_self procedure, private, pass(self ) :: self_eq_R8P procedure, private, pass(self ) :: self_eq_R4P procedure, private, pass(self ) :: self_eq_I8P procedure, private, pass(self ) :: self_eq_I4P procedure, private, pass(self ) :: self_eq_I2P procedure, private, pass(self ) :: self_eq_I1P procedure, private, pass(self1) :: self_great_eq_self procedure, private, pass(self ) :: R8P_great_eq_self procedure, private, pass(self ) :: R4P_great_eq_self procedure, private, pass(self ) :: I8P_great_eq_self procedure, private, pass(self ) :: I4P_great_eq_self procedure, private, pass(self ) :: I2P_great_eq_self procedure, private, pass(self ) :: I1P_great_eq_self procedure, private, pass(self ) :: self_great_eq_R8P procedure, private, pass(self ) :: self_great_eq_R4P procedure, private, pass(self ) :: self_great_eq_I8P procedure, private, pass(self ) :: self_great_eq_I4P procedure, private, pass(self ) :: self_great_eq_I2P procedure, private, pass(self ) :: self_great_eq_I1P procedure, private, pass(self1) :: self_great_self procedure, private, pass(self ) :: R8P_great_self procedure, private, pass(self ) :: R4P_great_self procedure, private, pass(self ) :: I8P_great_self procedure, private, pass(self ) :: I4P_great_self procedure, private, pass(self ) :: I2P_great_self procedure, private, pass(self ) :: I1P_great_self procedure, private, pass(self ) :: self_great_R8P procedure, private, pass(self ) :: self_great_R4P procedure, private, pass(self ) :: self_great_I8P procedure, private, pass(self ) :: self_great_I4P procedure, private, pass(self ) :: self_great_I2P procedure, private, pass(self ) :: self_great_I1P type, public :: Vector_Ptr Pointer of Vector for creating array of pointers of Vector. Components Type Visibility Attributes Name Initial type( Vector ), public, pointer :: p => null() Functions public elemental function sq_norm (vec) result(sq) Compute the square of the norm of a vector. Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Square of the Norm. public elemental function normL2 (vec) result(norm) Compute the norm L2 of a vector. Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Norm L2. public elemental function normalize (vec) result(norm) Normalize a vector. Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: vec Vector to be normalized. Return Value type( Vector ) Vector normalized. public elemental function face_normal4 (pt1, pt2, pt3, pt4, norm) result(fnormal) Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. type( Vector ), intent(in) :: pt4 Fourth face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Return Value type( Vector ) Face normal. public elemental function face_normal3 (pt1, pt2, pt3, norm) result(fnormal) Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Return Value type( Vector ) Face normal. private function iolen_vector_self (vec) result(iolen) Compute IO length. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value integer(kind=I4P) IO length. private elemental function normalized_self (vec) result(norm) Get a normalized copy of a vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector to be normalized. Return Value type( Vector ) Normalized copy. private elemental function sq_norm_self (vec) result(sq) Compute the square of the norm of a vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Square of the Norm. private elemental function normL2_self (vec) result(norm) Compute the norm L2 of a vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Norm L2. private elemental function crossproduct (vec1, vec2) result(cross) Compute the cross product of 2 vectors. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Cross product vector. private elemental function dotproduct (vec1, vec2) result(dot) Compute the scalar (dot) product of 2 vectors. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value real(kind=R8P) Dot product. private elemental function parallel (vec1, vec2) result(paral) Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 Compute the component of vec1 parallel to vec2.\n First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Component of of vec1 parallel to vec2. private elemental function orthogonal (vec1, vec2) result(ortho) Compute the component of vec1 orthogonal to vec2. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Component of of vec1 orthogonal to vec2. private elemental function self_mul_self (self1, self2) result(mul) Multiply (by components) two selfs. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) private elemental function ScalR16P_mul_self (scal, self) result(mul) Multiply scalar (real R16P) for self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalR16P (self, scal) result(mul) Multiply self for scalar (real R16P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalR8P_mul_self (scal, self) result(mul) Multiply scalar (real R8P) for self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalR8P (self, scal) result(mul) Multiply self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalR4P_mul_self (scal, self) result(mul) Multiply scalar (real R4P) for self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalR4P (self, scal) result(mul) Multiply self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI8P_mul_self (scal, self) result(mul) Multiply scalar (integer I8P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalI8P (self, scal) result(mul) Multiply self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI4P_mul_self (scal, self) result(mul) Multiply scalar (integer I4P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalI4P (self, scal) result(mul) Multiply self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI2P_mul_self (scal, self) result(mul) Multiply scalar (integer I2P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalI2P (self, scal) result(mul) Multiply self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI1P_mul_self (scal, self) result(mul) Multiply scalar (integer I1P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalI1P (self, scal) result(mul) Multiply self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_self (self1, self2) result(div) Divide self for self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) private elemental function self_div_ScalR16P (self, scal) result(div) Divide self for scalar (real R16P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalR8P (self, scal) result(div) Divide self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalR4P (self, scal) result(div) Divide self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalI8P (self, scal) result(div) Divide self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalI4P (self, scal) result(div) Divide self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalI2P (self, scal) result(div) Divide self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalI1P (self, scal) result(div) Divide self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) private elemental function positive_self (self) result(pos) Applay unary + to a self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_self (self1, self2) result(summ) Sum self and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) private elemental function ScalR16P_sum_self (scal, self) result(summ) Sum scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalR16P (self, scal) result(summ) Sum self and scalar (real R16P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalR8P_sum_self (scal, self) result(summ) Sum scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalR8P (self, scal) result(summ) Sum self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalR4P_sum_self (scal, self) result(summ) Sum scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalR4P (self, scal) result(summ) Sum self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI8P_sum_self (scal, self) result(summ) Sum scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalI8P (self, scal) result(summ) Sum self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI4P_sum_self (scal, self) result(summ) Sum scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalI4P (self, scal) result(summ) Sum self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI2P_sum_self (scal, self) result(summ) Sum scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalI2P (self, scal) result(summ) Sum self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI1P_sum_self (scal, self) result(summ) Sum scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalI1P (self, scal) result(summ) Sum self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) private elemental function negative_self (self) result(neg) Applay unary - to a self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_self (self1, self2) result(sub) Subtract self and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) private elemental function ScalR16P_sub_self (scal, self) result(sub) Subtract scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalR16P (self, scal) result(sub) Subtract self and scalar (real R16P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalR8P_sub_self (scal, self) result(sub) Subtract scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalR8P (self, scal) result(sub) Subtract self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalR4P_sub_self (scal, self) result(sub) Subtract scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalR4P (self, scal) result(sub) Subtract self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI8P_sub_self (scal, self) result(sub) Subtract scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalI8P (self, scal) result(sub) Subtract self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI4P_sub_self (scal, self) result(sub) Subtract scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalI4P (self, scal) result(sub) Subtract self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI2P_sub_self (scal, self) result(sub) Subtract scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalI2P (self, scal) result(sub) Subtract self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI1P_sub_self (scal, self) result(sub) Subtract scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalI1P (self, scal) result(sub) Subtract self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) private elemental function self_not_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1\n and self2 are different, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 First selftor. type( Vector ), intent(in) :: self2 Second selftor. Return Value logical The result of the comparison. private elemental function R16P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_R16P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical private elemental function R8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical private elemental function self_low_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical private elemental function R16P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_R16P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical private elemental function R8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical private elemental function self_low_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical private elemental function R16P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_R16P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical private elemental function R8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical private elemental function self_eq_self (self1, self2) result(compare) Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of\n self1 and self2 are the same, .false. otherwise. type( Vector ), intent(in) :: self2 Return Value logical private elemental function R16P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_R16P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical private elemental function R8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_eq_self (scal, self) result(compare) @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical private elemental function self_great_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical private elemental function R16P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_R16P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical private elemental function R8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical private elemental function self_great_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical private elemental function R16P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_R16P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical private elemental function R8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical Subroutines private elemental subroutine init_vector_self (vec) Initialize components of Vector variable. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector. private elemental subroutine set_vector_self (vec, x, y, z) Set components of Vector variable. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector. real(kind=R8P), intent(in), optional :: x Cartesian component in x direction. real(kind=R8P), intent(in), optional :: y Cartesian component in y direction. real(kind=R8P), intent(in), optional :: z Cartesian component in z direction. private subroutine load_vector_self (vec, unit, pos, iostat, iomsg) Load Vector data. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. private subroutine save_vector_self (vec, unit, pos, iostat, iomsg) Save Vector data. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. private subroutine print_vector_self (vec, unit, pref, iostat, iomsg) Print in a pretty ascii format the components of type Vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. integer(kind=I4P), intent(in), optional :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string for outputs. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. private elemental subroutine normalize_self (vec) Normalize a vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector to be normalized. private elemental subroutine face_normal4_self (fnormal, pt1, pt2, pt3, pt4, norm) Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: fnormal Face normal. type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. type( Vector ), intent(in) :: pt4 Fourth face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. private elemental subroutine face_normal3_self (fnormal, pt1, pt2, pt3, norm) Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: fnormal Face normal. type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. private pure subroutine assign_self (self1, self2) Assignment between two selfs. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self1 class( Vector ), intent(in) :: self2 private elemental subroutine assign_ScalR16P (self, scal) Assignment between a scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R16P), intent(in) :: scal private elemental subroutine assign_ScalR8P (self, scal) Assignment between a scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R8P), intent(in) :: scal private elemental subroutine assign_ScalR4P (self, scal) Assignment between a scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R4P), intent(in) :: scal private elemental subroutine assign_ScalI8P (self, scal) Assignment between a scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I8P), intent(in) :: scal private elemental subroutine assign_ScalI4P (self, scal) Assignment between a scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I4P), intent(in) :: scal private elemental subroutine assign_ScalI2P (self, scal) Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self Assignment between a scalar (integer I2P) and self. integer(kind=I2P), intent(in) :: scal private elemental subroutine assign_ScalI1P (self, scal) Assignment between a scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I1P), intent(in) :: scal","tags":"","loc":"module/vecfor.html","title":"VecFor – FLOw"},{"text":"Uses: flow program~~flow_test_primitive_add~~UsesGraph program~flow_test_primitive_add flow_test_primitive_add module~flow flow module~flow->program~flow_test_primitive_add module~flow_primitive_object flow_primitive_object module~flow_primitive_object->module~flow module~flow_field_object flow_field_object module~flow_field_object->module~flow module~flow_field_objects flow_field_objects module~flow_field_object->module~flow_field_objects module~penf penf module~penf->module~flow module~penf->module~flow_primitive_object module~penf->module~flow_field_object module~penf->module~flow_field_objects module~flow_field_objects->module~flow module~flow_field_objects->module~flow_primitive_object module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~vecfor VecFor iso_fortran_env->module~vecfor module~vecfor->module~flow_field_objects var panprogramflow_test_primitive_addUsesGraph = svgPanZoom('#programflow_test_primitive_addUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 primitive3 partial_densities test_passed Source Code flow_test_primitive_add Variables Type Attributes Name Initial type( primitive_object ) :: primitive1 A primitive object. type( primitive_object ) :: primitive2 A primitive object. type( primitive_object ) :: primitive3 A primitive object. type( field_object_scalar ) :: partial_densities (2) A scalar field object. logical :: test_passed (1) List of passed tests. Source Code program flow_test_primitive_add !< FLOw test. use flow implicit none type ( primitive_object ) :: primitive1 !< A primitive object. type ( primitive_object ) :: primitive2 !< A primitive object. type ( primitive_object ) :: primitive3 !< A primitive object. type ( field_object_scalar ) :: partial_densities ( 2 ) !< A scalar field object. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P partial_densities ( 1 ) = 0.125_R_P / 2 partial_densities ( 2 ) = 0.125_R_P / 2 primitive1 % partial_densities = partial_densities primitive2 % density = 1._R_P primitive2 % velocity = 2._R_P primitive2 % pressure = 1._R_P partial_densities ( 1 ) = 1._R_P / 2 partial_densities ( 2 ) = 1._R_P / 2 primitive2 % partial_densities = partial_densities primitive3 = primitive1 + primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 + primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  + 1   = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 1      + 2   = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 1      + 1   = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 + 0.5 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_add","tags":"","loc":"program/flow_test_primitive_add.html","title":"flow_test_primitive_add – FLOw"},{"text":"Uses: flow program~~flow_test_primitive_assign~~UsesGraph program~flow_test_primitive_assign flow_test_primitive_assign module~flow flow module~flow->program~flow_test_primitive_assign module~flow_primitive_object flow_primitive_object module~flow_primitive_object->module~flow module~flow_field_object flow_field_object module~flow_field_object->module~flow module~flow_field_objects flow_field_objects module~flow_field_object->module~flow_field_objects module~penf penf module~penf->module~flow module~penf->module~flow_primitive_object module~penf->module~flow_field_object module~penf->module~flow_field_objects module~flow_field_objects->module~flow module~flow_field_objects->module~flow_primitive_object module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~vecfor VecFor iso_fortran_env->module~vecfor module~vecfor->module~flow_field_objects var panprogramflow_test_primitive_assignUsesGraph = svgPanZoom('#programflow_test_primitive_assignUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 partial_densities test_passed Source Code flow_test_primitive_assign Variables Type Attributes Name Initial type( primitive_object ) :: primitive1 A primitive object. type( primitive_object ) :: primitive2 A primitive object. type( field_object_scalar ) :: partial_densities (2) A scalar field object. logical :: test_passed (2) List of passed tests. Source Code program flow_test_primitive_assign !< FLOw test. use flow implicit none type ( primitive_object ) :: primitive1 !< A primitive object. type ( primitive_object ) :: primitive2 !< A primitive object. type ( field_object_scalar ) :: partial_densities ( 2 ) !< A scalar field object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . primitive1 = 0.125_R_P test_passed ( 1 ) = ( primitive1 % density % field == 0.125_R_P ). and . & ( primitive1 % velocity % field % x == 0.125_R_P ). and . & ( primitive1 % velocity % field % y == 0.125_R_P ). and . & ( primitive1 % velocity % field % z == 0.125_R_P ). and . & ( primitive1 % pressure % field == 0.125_R_P ) print \"(A,F6.3)\" , 'density   = ' , primitive1 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  = ' , primitive1 % velocity % field print \"(A,F6.3)\" , 'pressure  = ' , primitive1 % pressure % field partial_densities ( 1 ) = 0.125_R_P / 2 partial_densities ( 2 ) = 0.125_R_P / 2 primitive1 % partial_densities = partial_densities primitive2 = primitive1 test_passed ( 2 ) = primitive1 == primitive2 print \"(A)\" , '' print \"(A,F6.3)\" , 'density   = ' , primitive2 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  = ' , primitive2 % velocity % field print \"(A,F6.3)\" , 'pressure  = ' , primitive2 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities = ' , primitive2 % partial_densities ( 1 )% field , primitive2 % partial_densities ( 2 )% field print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_assign","tags":"","loc":"program/flow_test_primitive_assign.html","title":"flow_test_primitive_assign – FLOw"},{"text":"Uses: flow program~~flow_test_primitive_div~~UsesGraph program~flow_test_primitive_div flow_test_primitive_div module~flow flow module~flow->program~flow_test_primitive_div module~flow_primitive_object flow_primitive_object module~flow_primitive_object->module~flow module~flow_field_object flow_field_object module~flow_field_object->module~flow module~flow_field_objects flow_field_objects module~flow_field_object->module~flow_field_objects module~penf penf module~penf->module~flow module~penf->module~flow_primitive_object module~penf->module~flow_field_object module~penf->module~flow_field_objects module~flow_field_objects->module~flow module~flow_field_objects->module~flow_primitive_object module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~vecfor VecFor iso_fortran_env->module~vecfor module~vecfor->module~flow_field_objects var panprogramflow_test_primitive_divUsesGraph = svgPanZoom('#programflow_test_primitive_divUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Calls program~~flow_test_primitive_div~~CallsGraph program~flow_test_primitive_div flow_test_primitive_div proc~print_error print_error program~flow_test_primitive_div->proc~print_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables primitive1 primitive2 primitive3 partial_densities test_passed Subroutines print_error Source Code flow_test_primitive_div Variables Type Attributes Name Initial type( primitive_object ) :: primitive1 A primitive object. type( primitive_object ) :: primitive2 A primitive object. type( primitive_object ) :: primitive3 A primitive object. type( field_object_scalar ) :: partial_densities (2) A scalar field object. logical :: test_passed (4) List of passed tests. Subroutines subroutine print_error (test, is_test_passed) Print error message if test is failed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test Test description. logical, intent(in) :: is_test_passed Test result. Source Code program flow_test_primitive_div !< FLOw test. use flow implicit none type ( primitive_object ) :: primitive1 !< A primitive object. type ( primitive_object ) :: primitive2 !< A primitive object. type ( primitive_object ) :: primitive3 !< A primitive object. type ( field_object_scalar ) :: partial_densities ( 2 ) !< A scalar field object. logical :: test_passed ( 4 ) !< List of passed tests. test_passed = . false . primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P partial_densities ( 1 ) = 0.125_R_P / 2 partial_densities ( 2 ) = 0.125_R_P / 2 primitive1 % partial_densities = partial_densities primitive2 % density = 1._R_P primitive2 % velocity = 2._R_P primitive2 % pressure = 1._R_P partial_densities ( 1 ) = 1._R_P / 2 partial_densities ( 2 ) = 1._R_P / 2 primitive2 % partial_densities = partial_densities primitive3 = primitive1 / primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 / primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  / 1   = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2   = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 1      / 1   = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 / 0.5 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field call print_error ( test = 'primitive3 = primitive1 / primitive2' , is_test_passed = test_passed ( 1 )) primitive3 = primitive1 / 2._R_P test_passed ( 2 ) = primitive3 == ( primitive1 / 2._R_P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  / 2.0 = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2.0 = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 1      / 2.0 = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 / 2.0 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field call print_error ( test = 'primitive3 = primitive1 / 2.0' , is_test_passed = test_passed ( 2 )) primitive3 % velocity = primitive2 % velocity / primitive1 % density test_passed ( 3 ) = primitive3 % velocity == ( primitive2 % velocity / 0.125_R_P ) print \"(A)\" , '' print \"(A,3(F6.3,1X))\" , 'velocity / density => 2 / 0.125 = ' , primitive3 % velocity % field call print_error ( test = 'primitive3%velocity = primitive2%velocity / primitive1%density' , is_test_passed = test_passed ( 3 )) primitive3 = primitive1 / 2_I_P test_passed ( 4 ) = primitive3 == ( primitive1 / 2_I_P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  / 2 = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2 = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 1      / 2 = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 / 2 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field call print_error ( test = 'primitive3 = primitive1 / 2' , is_test_passed = test_passed ( 4 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) contains subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive1 % partial_densities ( 1 )% field , primitive1 % partial_densities ( 2 )% field print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive2 % partial_densities ( 1 )% field , primitive2 % partial_densities ( 2 )% field print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field endif endsubroutine print_error endprogram flow_test_primitive_div","tags":"","loc":"program/flow_test_primitive_div.html","title":"flow_test_primitive_div – FLOw"},{"text":"Uses: flow program~~flow_test_primitive_eq~~UsesGraph program~flow_test_primitive_eq flow_test_primitive_eq module~flow flow module~flow->program~flow_test_primitive_eq module~flow_primitive_object flow_primitive_object module~flow_primitive_object->module~flow module~flow_field_object flow_field_object module~flow_field_object->module~flow module~flow_field_objects flow_field_objects module~flow_field_object->module~flow_field_objects module~penf penf module~penf->module~flow module~penf->module~flow_primitive_object module~penf->module~flow_field_object module~penf->module~flow_field_objects module~flow_field_objects->module~flow module~flow_field_objects->module~flow_primitive_object module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~vecfor VecFor iso_fortran_env->module~vecfor module~vecfor->module~flow_field_objects var panprogramflow_test_primitive_eqUsesGraph = svgPanZoom('#programflow_test_primitive_eqUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 partial_densities test_passed Source Code flow_test_primitive_eq Variables Type Attributes Name Initial type( primitive_object ) :: primitive1 A primitive object. type( primitive_object ) :: primitive2 A primitive object. type( field_object_scalar ) :: partial_densities (2) A scalar field object. logical :: test_passed (8) List of passed tests. Source Code program flow_test_primitive_eq !< FLOw test. use flow implicit none type ( primitive_object ) :: primitive1 !< A primitive object. type ( primitive_object ) :: primitive2 !< A primitive object. type ( field_object_scalar ) :: partial_densities ( 2 ) !< A scalar field object. logical :: test_passed ( 8 ) !< List of passed tests. test_passed = . false . primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P test_passed ( 1 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 1 ) primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 0.125_R_P primitive2 % velocity = 2._R_P primitive2 % pressure = 1._R_P test_passed ( 2 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'velocity => 1 /= 2     = ' , test_passed ( 2 ) primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 0.125_R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 2._R_P test_passed ( 3 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'pressure => 1 /= 2     = ' , test_passed ( 3 ) primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 1._R_P primitive2 % velocity = 2._R_P primitive2 % pressure = 2._R_P test_passed ( 4 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'velocity => 1 /= 2     = ' , test_passed ( 4 ) print \"(A,L1)\" , 'pressure => 1 /= 2     = ' , test_passed ( 4 ) primitive1 % density = 1._R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P test_passed ( 5 ) = ( primitive1 == primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true' print \"(A,L1)\" , 'density  => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'velocity => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'pressure => 1 == 1 = ' , test_passed ( 5 ) primitive1 % density = 1._R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P partial_densities ( 1 ) = 0.5_R_P partial_densities ( 2 ) = 0.5_R_P primitive1 % partial_densities = partial_densities primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P test_passed ( 6 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'velocity  => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'pressure  => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'densities => 0.5 /= null = ' , test_passed ( 6 ) primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P partial_densities ( 1 ) = 0.1_R_P partial_densities ( 2 ) = 0.5_R_P primitive2 % partial_densities = partial_densities test_passed ( 7 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'velocity  => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'pressure  => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'densities => 0.5 /= 0.1 = ' , test_passed ( 7 ) primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P partial_densities ( 1 ) = 0.5_R_P partial_densities ( 2 ) = 0.5_R_P primitive2 % partial_densities = partial_densities test_passed ( 8 ) = ( primitive1 == primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'velocity  => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'pressure  => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'densities => 0.5 == 0.5 = ' , test_passed ( 8 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_eq","tags":"","loc":"program/flow_test_primitive_eq.html","title":"flow_test_primitive_eq – FLOw"},{"text":"Uses: flow program~~flow_test_primitive_mul~~UsesGraph program~flow_test_primitive_mul flow_test_primitive_mul module~flow flow module~flow->program~flow_test_primitive_mul module~flow_primitive_object flow_primitive_object module~flow_primitive_object->module~flow module~flow_field_object flow_field_object module~flow_field_object->module~flow module~flow_field_objects flow_field_objects module~flow_field_object->module~flow_field_objects module~penf penf module~penf->module~flow module~penf->module~flow_primitive_object module~penf->module~flow_field_object module~penf->module~flow_field_objects module~flow_field_objects->module~flow module~flow_field_objects->module~flow_primitive_object module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~vecfor VecFor iso_fortran_env->module~vecfor module~vecfor->module~flow_field_objects var panprogramflow_test_primitive_mulUsesGraph = svgPanZoom('#programflow_test_primitive_mulUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Calls program~~flow_test_primitive_mul~~CallsGraph program~flow_test_primitive_mul flow_test_primitive_mul proc~print_error~2 print_error program~flow_test_primitive_mul->proc~print_error~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables primitive1 primitive2 primitive3 partial_densities test_passed Subroutines print_error Source Code flow_test_primitive_mul Variables Type Attributes Name Initial type( primitive_object ) :: primitive1 A primitive object. type( primitive_object ) :: primitive2 A primitive object. type( primitive_object ) :: primitive3 A primitive object. type( field_object_scalar ) :: partial_densities (2) A scalar field object. logical :: test_passed (7) List of passed tests. Subroutines subroutine print_error (test, is_test_passed) Print error message if test is failed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test Test description. logical, intent(in) :: is_test_passed Test result. Source Code program flow_test_primitive_mul !< FLOw test. use flow implicit none type ( primitive_object ) :: primitive1 !< A primitive object. type ( primitive_object ) :: primitive2 !< A primitive object. type ( primitive_object ) :: primitive3 !< A primitive object. type ( field_object_scalar ) :: partial_densities ( 2 ) !< A scalar field object. logical :: test_passed ( 7 ) !< List of passed tests. test_passed = . false . primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P partial_densities ( 1 ) = 0.125_R_P / 2 partial_densities ( 2 ) = 0.125_R_P / 2 primitive1 % partial_densities = partial_densities primitive2 % density = 1._R_P primitive2 % velocity = 2._R_P primitive2 % pressure = 1._R_P partial_densities ( 1 ) = 1._R_P / 2 partial_densities ( 2 ) = 1._R_P / 2 primitive2 % partial_densities = partial_densities primitive3 = primitive1 * primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 * primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  * 1 = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2 = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 1      * 1 = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 * 0.5 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field call print_error ( test = 'primitive3 = primitive1 * primitive2' , is_test_passed = test_passed ( 1 )) primitive3 = 2._R_P * primitive1 test_passed ( 2 ) = primitive3 == ( 2._R_P * primitive1 ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 2.0 * 0.125  = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 2.0 * 1      = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 2.0 * 1      = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 2.0 * 0.0625 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field call print_error ( test = 'primitive3 = 2.0 * primitive1' , is_test_passed = test_passed ( 2 )) primitive3 = primitive1 * 2._R_P test_passed ( 3 ) = primitive3 == ( primitive1 * 2._R_P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  * 2.0 = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2.0 = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 1      * 2.0 = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 * 2.0 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field call print_error ( test = 'primitive3 = primitive1 * 2.0' , is_test_passed = test_passed ( 3 )) primitive3 % velocity = primitive1 % density * primitive2 % velocity test_passed ( 4 ) = primitive3 % velocity == ( primitive2 % velocity * 0.125_R_P ) print \"(A)\" , '' print \"(A,3(F6.3,1X))\" , 'density * velocity => 0.125 * 2 = ' , primitive3 % velocity % field call print_error ( test = 'primitive3%velocity = primitive1%density * primitive2%velocity' , is_test_passed = test_passed ( 4 )) primitive3 % velocity = primitive2 % velocity * primitive1 % density test_passed ( 5 ) = primitive3 % velocity == ( primitive2 % velocity * 0.125_R_P ) print \"(A)\" , '' print \"(A,3(F6.3,1X))\" , 'velocity * density => 2 * 0.125 = ' , primitive3 % velocity % field call print_error ( test = 'primitive3%velocity = primitive2%velocity * primitive1%density' , is_test_passed = test_passed ( 5 )) primitive3 = 2_I_P * primitive1 test_passed ( 6 ) = primitive3 == ( 2_I_P * primitive1 ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 2 * 0.125  = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 2 * 1      = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 2 * 1      = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 2 * 0.0625 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field call print_error ( test = 'primitive3 = 2 * primitive1' , is_test_passed = test_passed ( 6 )) primitive3 = primitive1 * 2_I_P test_passed ( 7 ) = primitive3 == ( primitive1 * 2_I_P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  * 2 = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2 = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 1      * 2 = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 * 2 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field call print_error ( test = 'primitive3 = primitive1 * 2' , is_test_passed = test_passed ( 7 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) contains subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive1 % partial_densities ( 1 )% field , primitive1 % partial_densities ( 2 )% field print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive2 % partial_densities ( 1 )% field , primitive2 % partial_densities ( 2 )% field print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity % field print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field endif endsubroutine print_error endprogram flow_test_primitive_mul","tags":"","loc":"program/flow_test_primitive_mul.html","title":"flow_test_primitive_mul – FLOw"},{"text":"Uses: flow program~~flow_test_primitive_not_eq~~UsesGraph program~flow_test_primitive_not_eq flow_test_primitive_not_eq module~flow flow module~flow->program~flow_test_primitive_not_eq module~flow_primitive_object flow_primitive_object module~flow_primitive_object->module~flow module~flow_field_object flow_field_object module~flow_field_object->module~flow module~flow_field_objects flow_field_objects module~flow_field_object->module~flow_field_objects module~penf penf module~penf->module~flow module~penf->module~flow_primitive_object module~penf->module~flow_field_object module~penf->module~flow_field_objects module~flow_field_objects->module~flow module~flow_field_objects->module~flow_primitive_object module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~vecfor VecFor iso_fortran_env->module~vecfor module~vecfor->module~flow_field_objects var panprogramflow_test_primitive_not_eqUsesGraph = svgPanZoom('#programflow_test_primitive_not_eqUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 partial_densities test_passed Source Code flow_test_primitive_not_eq Variables Type Attributes Name Initial type( primitive_object ) :: primitive1 A primitive object. type( primitive_object ) :: primitive2 A primitive object. type( field_object_scalar ) :: partial_densities (2) A scalar field object. logical :: test_passed (8) List of passed tests. Source Code program flow_test_primitive_not_eq !< FLOw test. use flow implicit none type ( primitive_object ) :: primitive1 !< A primitive object. type ( primitive_object ) :: primitive2 !< A primitive object. type ( field_object_scalar ) :: partial_densities ( 2 ) !< A scalar field object. logical :: test_passed ( 8 ) !< List of passed tests. test_passed = . false . primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P test_passed ( 1 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 1 ) primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 0.125_R_P primitive2 % velocity = 2._R_P primitive2 % pressure = 1._R_P test_passed ( 2 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'velocity => 1 /= 2     = ' , test_passed ( 2 ) primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 0.125_R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 2._R_P test_passed ( 3 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'pressure => 1 /= 2     = ' , test_passed ( 3 ) primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 1._R_P primitive2 % velocity = 2._R_P primitive2 % pressure = 2._R_P test_passed ( 4 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'velocity => 1 /= 2     = ' , test_passed ( 4 ) print \"(A,L1)\" , 'pressure => 1 /= 2     = ' , test_passed ( 4 ) primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P primitive2 % density = 0.125_R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P test_passed ( 5 ) = ( primitive1 /= primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'velocity => 1 /= 2     = ' , test_passed ( 5 ) print \"(A,L1)\" , 'pressure => 1 /= 2     = ' , test_passed ( 5 ) primitive1 % density = 1._R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P partial_densities ( 1 ) = 0.5_R_P partial_densities ( 2 ) = 0.5_R_P primitive1 % partial_densities = partial_densities primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P test_passed ( 6 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'velocity  => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'pressure  => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'densities => 0.5 /= null = ' , test_passed ( 6 ) primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P partial_densities ( 1 ) = 0.1_R_P partial_densities ( 2 ) = 0.5_R_P primitive2 % partial_densities = partial_densities test_passed ( 7 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'velocity  => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'pressure  => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'densities => 0.5 /= 0.1 = ' , test_passed ( 7 ) primitive2 % density = 1._R_P primitive2 % velocity = 1._R_P primitive2 % pressure = 1._R_P partial_densities ( 1 ) = 0.5_R_P partial_densities ( 2 ) = 0.5_R_P primitive2 % partial_densities = partial_densities test_passed ( 8 ) = ( primitive1 /= primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'velocity  => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'pressure  => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'densities => 0.5 == 0.5 = ' , test_passed ( 8 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_not_eq","tags":"","loc":"program/flow_test_primitive_not_eq.html","title":"flow_test_primitive_not_eq – FLOw"},{"text":"Uses: flow program~~flow_test_primitive_add~2~~UsesGraph program~flow_test_primitive_add~2 flow_test_primitive_add module~flow flow module~flow->program~flow_test_primitive_add~2 module~flow_primitive_object flow_primitive_object module~flow_primitive_object->module~flow module~flow_field_object flow_field_object module~flow_field_object->module~flow module~flow_field_objects flow_field_objects module~flow_field_object->module~flow_field_objects module~penf penf module~penf->module~flow module~penf->module~flow_primitive_object module~penf->module~flow_field_object module~penf->module~flow_field_objects module~flow_field_objects->module~flow module~flow_field_objects->module~flow_primitive_object module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~vecfor VecFor iso_fortran_env->module~vecfor module~vecfor->module~flow_field_objects var panprogramflow_test_primitive_add2UsesGraph = svgPanZoom('#programflow_test_primitive_add2UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 test_passed Source Code flow_test_primitive_add Variables Type Attributes Name Initial type( primitive_object ) :: primitive1 A primitive object. type( primitive_object ) :: primitive2 A primitive object. logical :: test_passed (2) List of passed tests. Source Code program flow_test_primitive_add !< FLOw test. use flow implicit none type ( primitive_object ) :: primitive1 !< A primitive object. type ( primitive_object ) :: primitive2 !< A primitive object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . primitive1 % density = 0.125_R_P ; primitive1 % velocity = 1._R_P ; primitive1 % pressure = 1._R_P primitive2 % density = primitive1 % density ** 2_I_P primitive2 % velocity = primitive1 % velocity ** 2_I_P primitive2 % pressure = primitive1 % pressure ** 2_I_P print \"(A,F6.3)\" , 'density  => 0.125 ** 2 = ' , primitive2 % density % field print \"(A,3(F6.3,1X))\" , 'velocity => 1     ** 2 = ' , primitive2 % velocity % field print \"(A,F6.3)\" , 'pressure => 1     ** 2 = ' , primitive2 % pressure % field test_passed ( 1 ) = primitive2 % density % field == ( 0.125_R_P ** 2_I_P ) primitive2 % density = primitive1 % density ** 2._R_P primitive2 % velocity = primitive1 % velocity ** 2._R_P primitive2 % pressure = primitive1 % pressure ** 2._R_P print \"(A)\" , '' print \"(A,F6.3)\" , 'density  => 0.125 ** 2.0 = ' , primitive2 % density % field print \"(A,3(F6.3,1X))\" , 'velocity => 1     ** 2.0 = ' , primitive2 % velocity % field print \"(A,F6.3)\" , 'pressure => 1     ** 2.0 = ' , primitive2 % pressure % field test_passed ( 2 ) = primitive2 % density % field == ( 0.125_R_P ** 2._R_P ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_add","tags":"","loc":"program/flow_test_primitive_add~2.html","title":"flow_test_primitive_add – FLOw"},{"text":"Uses: flow program~~flow_test_primitive_sub~~UsesGraph program~flow_test_primitive_sub flow_test_primitive_sub module~flow flow module~flow->program~flow_test_primitive_sub module~flow_primitive_object flow_primitive_object module~flow_primitive_object->module~flow module~flow_field_object flow_field_object module~flow_field_object->module~flow module~flow_field_objects flow_field_objects module~flow_field_object->module~flow_field_objects module~penf penf module~penf->module~flow module~penf->module~flow_primitive_object module~penf->module~flow_field_object module~penf->module~flow_field_objects module~flow_field_objects->module~flow module~flow_field_objects->module~flow_primitive_object module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~vecfor VecFor iso_fortran_env->module~vecfor module~vecfor->module~flow_field_objects var panprogramflow_test_primitive_subUsesGraph = svgPanZoom('#programflow_test_primitive_subUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 primitive3 partial_densities test_passed Source Code flow_test_primitive_sub Variables Type Attributes Name Initial type( primitive_object ) :: primitive1 A primitive object. type( primitive_object ) :: primitive2 A primitive object. type( primitive_object ) :: primitive3 A primitive object. type( field_object_scalar ) :: partial_densities (2) A scalar field object. logical :: test_passed (1) List of passed tests. Source Code program flow_test_primitive_sub !< FLOw test. use flow implicit none type ( primitive_object ) :: primitive1 !< A primitive object. type ( primitive_object ) :: primitive2 !< A primitive object. type ( primitive_object ) :: primitive3 !< A primitive object. type ( field_object_scalar ) :: partial_densities ( 2 ) !< A scalar field object. logical :: test_passed ( 1 ) !< List of passed tests. test_passed = . false . primitive1 % density = 0.125_R_P primitive1 % velocity = 1._R_P primitive1 % pressure = 1._R_P partial_densities ( 1 ) = 0.125_R_P / 2 partial_densities ( 2 ) = 0.125_R_P / 2 primitive1 % partial_densities = partial_densities primitive2 % density = 1._R_P primitive2 % velocity = 2._R_P primitive2 % pressure = 1._R_P partial_densities ( 1 ) = 1._R_P / 2 partial_densities ( 2 ) = 1._R_P / 2 primitive2 % partial_densities = partial_densities primitive3 = primitive1 - primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 - primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  - 1   = ' , primitive3 % density % field print \"(A,3(F6.3,1X))\" , 'velocity  => 1      - 2   = ' , primitive3 % velocity % field print \"(A,F6.3)\" , 'pressure  => 1      - 1   = ' , primitive3 % pressure % field print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 - 0.5 = ' , primitive3 % partial_densities ( 1 )% field , primitive3 % partial_densities ( 2 )% field print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_sub","tags":"","loc":"program/flow_test_primitive_sub.html","title":"flow_test_primitive_sub – FLOw"},{"text":"Uses: penf iso_fortran_env program~~compact_real~~UsesGraph program~compact_real compact_real module~penf penf module~penf->program~compact_real iso_fortran_env iso_fortran_env iso_fortran_env->program~compact_real module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. PENF's testing program. Calls program~~compact_real~~CallsGraph program~compact_real compact_real proc~penf_init penf_init program~compact_real->proc~penf_init interface~str str program~compact_real->interface~str proc~check_endian check_endian proc~penf_init->proc~check_endian proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables test_passed Source Code compact_real Variables Type Attributes Name Initial logical :: test_passed (3) List of passed tests. Source Code program compact_real !----------------------------------------------------------------------------------------------------------------------------------- !< PENF's testing program. !----------------------------------------------------------------------------------------------------------------------------------- use penf use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call penf_init test_passed = . false . test_passed ( 1 ) = trim ( str ( n = 1._R8P , compact = . true .)) == '+0.1E+1' print \"(A,L1)\" , 'Compact 1.0: ' // trim ( str ( n = 1._R8P , compact = . true .)) // ', is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = trim ( str ( n = 1._R4P / 3._R4P , compact = . true .)) == '+0.333333E+0' print \"(A,L1)\" , 'Compact 1.0/3.0: ' // trim ( str ( n = 1._R4P / 3._R4P , compact = . true .)) // ', is correct? ' , test_passed ( 2 ) test_passed ( 3 ) = trim ( str ( n = 1._R16P / 4._R16P , compact = . true .)) == '+0.25E+0' print \"(A,L1)\" , 'Compact 1.0/4.0: ' // trim ( str ( n = 1._R16P / 4._R16P , compact = . true .)) // ', is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram compact_real","tags":"","loc":"program/compact_real.html","title":"compact_real – FLOw"},{"text":"Uses: penf iso_fortran_env program~~test_all~~UsesGraph program~test_all test_all module~penf penf module~penf->program~test_all iso_fortran_env iso_fortran_env iso_fortran_env->program~test_all module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. PENF's testing program. Usage ./test_all Calls program~~test_all~~CallsGraph program~test_all test_all proc~penf_init penf_init program~test_all->proc~penf_init interface~strz strz program~test_all->interface~strz interface~digit digit program~test_all->interface~digit proc~penf_print penf_print program~test_all->proc~penf_print interface~cton cton program~test_all->interface~cton interface~str str program~test_all->interface~str interface~bstr bstr program~test_all->interface~bstr interface~bcton bcton program~test_all->interface~bcton proc~check_endian check_endian proc~penf_init->proc~check_endian proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p proc~digit_i8 digit_I8 interface~digit->proc~digit_i8 proc~digit_i1 digit_I1 interface~digit->proc~digit_i1 proc~digit_i4 digit_I4 interface~digit->proc~digit_i4 proc~digit_i2 digit_I2 interface~digit->proc~digit_i2 proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~bstr_i8p bstr_I8P interface~bstr->proc~bstr_i8p proc~bstr_i4p bstr_I4P interface~bstr->proc~bstr_i4p proc~bstr_r4p bstr_R4P interface~bstr->proc~bstr_r4p proc~bstr_r8p bstr_R8P interface~bstr->proc~bstr_r8p proc~bstr_i1p bstr_I1P interface~bstr->proc~bstr_i1p proc~bstr_i2p bstr_I2P interface~bstr->proc~bstr_i2p proc~bctor_r4p bctor_R4P interface~bcton->proc~bctor_r4p proc~bctoi_i8p bctoi_I8P interface~bcton->proc~bctoi_i8p proc~bctoi_i4p bctoi_I4P interface~bcton->proc~bctoi_i4p proc~bctor_r8p bctor_R8P interface~bcton->proc~bctor_r8p proc~bctoi_i2p bctoi_I2P interface~bcton->proc~bctoi_i2p proc~bctoi_i1p bctoi_I1P interface~bcton->proc~bctoi_i1p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~bctor_r4p->interface~str proc~bctoi_i8p->interface~str proc~bctoi_i4p->interface~str proc~bctor_r8p->interface~str proc~bctoi_i2p->interface~str proc~bctoi_i1p->interface~str var panprogramtest_allCallsGraph = svgPanZoom('#programtest_allCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_all Source Code program test_all !----------------------------------------------------------------------------------------------------------------------------------- !< PENF's testing program. !< !<### Usage !<```bash !< ./test_all !<``` !----------------------------------------------------------------------------------------------------------------------------------- use penf use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call penf_init call penf_print ( unit = stdout ) print \"(A)\" , '' print \"(A)\" , 'Testing IR_Precision tools' print \"(A)\" , 'Casting real-to-string: ' // str ( n = 1._R8P ) print \"(A)\" , 'Casting integer-to-string: ' // str ( n = 11_I8P ) print \"(A,\" // FR8P // \")\" , 'Casting string-to-real: ' , cton ( str = '2.2d0' , knd = 1._R8P ) print \"(A,\" // FI4P // \")\" , 'Casting integer-to-string: ' , cton ( str = '43' , knd = 1_I4P ) print \"(A)\" , 'Casting integer-to-string with zero padding: ' // trim ( strz ( nz_pad = 3 , n = 34_I8P )) #ifndef __GFORTRAN__ print \"(A)\" , 'Casting real-to-bit_string: ' // bstr ( n = 1._R4P ) #endif print \"(A)\" , 'Casting integer-to-bit_string: ' // bstr ( n = 1_I4P ) #ifndef __GFORTRAN__ print \"(A,\" // FR4P // \")\" , 'Casting bit_string-to-real: ' , bcton ( bstr = '00111111100000000000000000000000' , knd = 1._R4P ) #endif print \"(A,\" // FI4P // \")\" , 'Casting bit_string-to-integer: ' , bcton ( bstr = '00000000000000000000000000000001' , knd = 1_I4P ) print \"(A)\" , 'Number of digit of 1023: ' // str ( n = digit ( 1023_I4P )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_all","tags":"","loc":"program/test_all.html","title":"test_all – FLOw"},{"text":"Uses: VecFor program~~kinds~~UsesGraph program~kinds kinds module~vecfor VecFor module~vecfor->program~kinds iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Kinds regression test for VecFor library. Try to test the algebra of mixed vector/numbers for all supported kinds. Variables R16P R16P R8P R4P I8P I4P I2P I1P vector1 vector2 vector3 Source Code kinds Variables Type Attributes Name Initial integer, parameter :: R16P = selected_real_kind(33, 4931) 33  digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. integer, parameter :: R16P = selected_real_kind(15, 307) Defined as R8P; 64 bits. integer, parameter :: R8P = selected_real_kind(15, 307) 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, parameter :: R4P = selected_real_kind(6, 37) 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. type(vector) :: vector1 Vector dummy variable. type(vector) :: vector2 Vector dummy variable. type(vector) :: vector3 Vector dummy variable. Source Code program kinds !< Kinds regression test for VecFor library. !< !< Try to test the algebra of mixed vector/numbers for all supported kinds. use vecfor implicit none #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33  digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. type ( vector ) :: vector1 !< Vector dummy variable. type ( vector ) :: vector2 !< Vector dummy variable. type ( vector ) :: vector3 !< Vector dummy variable. call vector1 % set ( x =- 1._R8P , y =- 1._R8P , z =- 1._R8P ) call vector1 % init () print \"(A)\" , ' Assign vector1 = [1, 2, 3]' vector1 = 1 * ex + 2 * ey + 3 * ez print \"(A)\" , ' Assign vector2 = [1, 1, 1] testing assignments by scalar' vector2 = 1._R16P vector2 = 1._R8P vector2 = 1._R4P vector2 = 1_I8P vector2 = 1_I4P vector2 = 1_I2P vector2 = 1_I1P print \"(A)\" , ' Verify * operator, multiply by 1 defined in any supported number formats' vector1 = 1._R16P * vector1 vector1 = 1._R8P * vector1 vector1 = 1._R4P * vector1 vector1 = 1_I8P * vector1 vector1 = 1_I4P * vector1 vector1 = 1_I2P * vector1 vector1 = 1_I1P * vector1 vector1 = vector1 * 1._R16P vector1 = vector1 * 1._R8P vector1 = vector1 * 1._R4P vector1 = vector1 * 1_I8P vector1 = vector1 * 1_I4P vector1 = vector1 * 1_I2P vector1 = vector1 * 1_I1P call vector1 % print print \"(A)\" , ' Verify * operator between vectors, vector1 * vector2' vector1 = vector1 * vector2 call vector1 % print print \"(A)\" , ' Verify / operator, diveded by 1 defined in any supported number formats' vector1 = vector1 / 1._R16P vector1 = vector1 / 1._R8P vector1 = vector1 / 1._R4P vector1 = vector1 / 1_I8P vector1 = vector1 / 1_I4P vector1 = vector1 / 1_I2P vector1 = vector1 / 1_I1P call vector1 % print print \"(A)\" , ' Verify / operator between vectors, vector1 / vector2' vector1 = vector1 / vector2 call vector1 % print print \"(A)\" , ' Verify + operator, add 1 (14 times) defined in any supported number formats' vector1 = 1._R16P + vector1 vector1 = 1._R8P + vector1 vector1 = 1._R4P + vector1 vector1 = 1_I8P + vector1 vector1 = 1_I4P + vector1 vector1 = 1_I2P + vector1 vector1 = 1_I1P + vector1 vector1 = + vector1 vector1 = vector1 + 1._R16P vector1 = vector1 + 1._R8P vector1 = vector1 + 1._R4P vector1 = vector1 + 1_I8P vector1 = vector1 + 1_I4P vector1 = vector1 + 1_I2P vector1 = vector1 + 1_I1P call vector1 % print print \"(A)\" , ' Verify + operator between vectors, vector1 + vector2' vector1 = vector1 + vector2 call vector1 % print print \"(A)\" , ' Verify - operator, subtract 1 (14 times) defined in any supported number formats' vector1 = 1._R16P - vector1 vector1 =- 1._R8P - vector1 vector1 = 1._R4P - vector1 vector1 =- 1_I8P - vector1 vector1 = 1_I4P - vector1 vector1 =- 1_I2P - vector1 vector1 = 1_I1P - vector1 vector1 = - vector1 vector1 = vector1 - 1._R16P vector1 = vector1 - 1._R8P vector1 = vector1 - 1._R4P vector1 = vector1 - 1_I8P vector1 = vector1 - 1_I4P vector1 = vector1 - 1_I2P vector1 = vector1 - 1_I1P call vector1 % print print \"(A)\" , ' Verify - operator between vectors, vector1 - vector2' vector1 = vector1 - vector2 call vector1 % print print \"(A)\" , ' Verify save/load methods' open ( unit = 2 , form = 'UNFORMATTED' , status = 'SCRATCH' ) call vector1 % save ( unit = 2 ) rewind ( unit = 2 ) call vector3 % load ( unit = 2 ) close ( unit = 2 ) call vector3 % print vector3 = 0 print \"(A)\" , ' Verify save/load methods with stream-accessed file' open ( unit = 2 , form = 'UNFORMATTED' , status = 'SCRATCH' , access = 'STREAM' ) call vector1 % save ( unit = 2 , pos = 1_I8P ) rewind ( unit = 2 ) call vector3 % load ( unit = 2 , pos = 1_I8P ) close ( unit = 2 ) call vector3 % print print \"(A)\" , ' Verify < operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1<1._R16P => ' , ( vector1 < 1._R16P ) print \"(A,L1)\" , 'vector1<1._R8P  => ' , ( vector1 < 1._R8P ) print \"(A,L1)\" , 'vector1<1._R4P  => ' , ( vector1 < 1._R4P ) print \"(A,L1)\" , 'vector1<1_I8P   => ' , ( vector1 < 1_I8P ) print \"(A,L1)\" , 'vector1<1_I4P   => ' , ( vector1 < 1_I4P ) print \"(A,L1)\" , 'vector1<1_I2P   => ' , ( vector1 < 1_I2P ) print \"(A,L1)\" , 'vector1<1_I1P   => ' , ( vector1 < 1_I1P ) print \"(A,L1)\" , '1._R16P<vector1 => ' , ( 1._R16P < vector1 ) print \"(A,L1)\" , '1._R8P <vector1 => ' , ( 1._R8P < vector1 ) print \"(A,L1)\" , '1._R4P <vector1 => ' , ( 1._R4P < vector1 ) print \"(A,L1)\" , '1_I8P  <vector1 => ' , ( 1_I8P < vector1 ) print \"(A,L1)\" , '1_I4P  <vector1 => ' , ( 1_I4P < vector1 ) print \"(A,L1)\" , '1_I2P  <vector1 => ' , ( 1_I2P < vector1 ) print \"(A,L1)\" , '1_I1P  <vector1 => ' , ( 1_I1P < vector1 ) print \"(A,L1)\" , 'vector1<vector2 => ' , ( vector1 < vector2 ) print \"(A)\" , ' Verify <= operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1<=1._R16P => ' , ( vector1 <= 1._R16P ) print \"(A,L1)\" , 'vector1<=1._R8P  => ' , ( vector1 <= 1._R8P ) print \"(A,L1)\" , 'vector1<=1._R4P  => ' , ( vector1 <= 1._R4P ) print \"(A,L1)\" , 'vector1<=1_I8P   => ' , ( vector1 <= 1_I8P ) print \"(A,L1)\" , 'vector1<=1_I4P   => ' , ( vector1 <= 1_I4P ) print \"(A,L1)\" , 'vector1<=1_I2P   => ' , ( vector1 <= 1_I2P ) print \"(A,L1)\" , 'vector1<=1_I1P   => ' , ( vector1 <= 1_I1P ) print \"(A,L1)\" , '1._R16P<=vector1 => ' , ( 1._R16P <= vector1 ) print \"(A,L1)\" , '1._R8P <=vector1 => ' , ( 1._R8P <= vector1 ) print \"(A,L1)\" , '1._R4P <=vector1 => ' , ( 1._R4P <= vector1 ) print \"(A,L1)\" , '1_I8P  <=vector1 => ' , ( 1_I8P <= vector1 ) print \"(A,L1)\" , '1_I4P  <=vector1 => ' , ( 1_I4P <= vector1 ) print \"(A,L1)\" , '1_I2P  <=vector1 => ' , ( 1_I2P <= vector1 ) print \"(A,L1)\" , '1_I1P  <=vector1 => ' , ( 1_I1P <= vector1 ) print \"(A,L1)\" , 'vector1<=vector2 => ' , ( vector1 <= vector2 ) print \"(A)\" , ' Verify == operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1==1._R16P => ' , ( vector1 == 1._R16P ) print \"(A,L1)\" , 'vector1==1._R8P  => ' , ( vector1 == 1._R8P ) print \"(A,L1)\" , 'vector1==1._R4P  => ' , ( vector1 == 1._R4P ) print \"(A,L1)\" , 'vector1==1_I8P   => ' , ( vector1 == 1_I8P ) print \"(A,L1)\" , 'vector1==1_I4P   => ' , ( vector1 == 1_I4P ) print \"(A,L1)\" , 'vector1==1_I2P   => ' , ( vector1 == 1_I2P ) print \"(A,L1)\" , 'vector1==1_I1P   => ' , ( vector1 == 1_I1P ) print \"(A,L1)\" , '1._R16P==vector1 => ' , ( 1._R16P == vector1 ) print \"(A,L1)\" , '1._R8P ==vector1 => ' , ( 1._R8P == vector1 ) print \"(A,L1)\" , '1._R4P ==vector1 => ' , ( 1._R4P == vector1 ) print \"(A,L1)\" , '1_I8P  ==vector1 => ' , ( 1_I8P == vector1 ) print \"(A,L1)\" , '1_I4P  ==vector1 => ' , ( 1_I4P == vector1 ) print \"(A,L1)\" , '1_I2P  ==vector1 => ' , ( 1_I2P == vector1 ) print \"(A,L1)\" , '1_I1P  ==vector1 => ' , ( 1_I1P == vector1 ) print \"(A,L1)\" , 'vector1==vector2 => ' , ( vector1 == vector2 ) print \"(A,L1)\" , 'vector1==-vector1 => ' , ( vector1 ==- vector1 ) print \"(A)\" , ' Verify /= operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1/=1._R16P => ' , ( vector1 /= 1._R16P ) print \"(A,L1)\" , 'vector1/=1._R8P  => ' , ( vector1 /= 1._R8P ) print \"(A,L1)\" , 'vector1/=1._R4P  => ' , ( vector1 /= 1._R4P ) print \"(A,L1)\" , 'vector1/=1_I8P   => ' , ( vector1 /= 1_I8P ) print \"(A,L1)\" , 'vector1/=1_I4P   => ' , ( vector1 /= 1_I4P ) print \"(A,L1)\" , 'vector1/=1_I2P   => ' , ( vector1 /= 1_I2P ) print \"(A,L1)\" , 'vector1/=1_I1P   => ' , ( vector1 /= 1_I1P ) print \"(A,L1)\" , '1._R16P/=vector1 => ' , ( 1._R16P /= vector1 ) print \"(A,L1)\" , '1._R8P /=vector1 => ' , ( 1._R8P /= vector1 ) print \"(A,L1)\" , '1._R4P /=vector1 => ' , ( 1._R4P /= vector1 ) print \"(A,L1)\" , '1_I8P  /=vector1 => ' , ( 1_I8P /= vector1 ) print \"(A,L1)\" , '1_I4P  /=vector1 => ' , ( 1_I4P /= vector1 ) print \"(A,L1)\" , '1_I2P  /=vector1 => ' , ( 1_I2P /= vector1 ) print \"(A,L1)\" , '1_I1P  /=vector1 => ' , ( 1_I1P /= vector1 ) print \"(A,L1)\" , 'vector1/=vector2 => ' , ( vector1 /= vector2 ) print \"(A,L1)\" , 'vector1/=-vector1 => ' , ( vector1 /=- vector1 ) print \"(A)\" , ' Verify >= operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1>=1._R16P => ' , ( vector1 >= 1._R16P ) print \"(A,L1)\" , 'vector1>=1._R8P  => ' , ( vector1 >= 1._R8P ) print \"(A,L1)\" , 'vector1>=1._R4P  => ' , ( vector1 >= 1._R4P ) print \"(A,L1)\" , 'vector1>=1_I8P   => ' , ( vector1 >= 1_I8P ) print \"(A,L1)\" , 'vector1>=1_I4P   => ' , ( vector1 >= 1_I4P ) print \"(A,L1)\" , 'vector1>=1_I2P   => ' , ( vector1 >= 1_I2P ) print \"(A,L1)\" , 'vector1>=1_I1P   => ' , ( vector1 >= 1_I1P ) print \"(A,L1)\" , '1._R16P>=vector1 => ' , ( 1._R16P >= vector1 ) print \"(A,L1)\" , '1._R8P >=vector1 => ' , ( 1._R8P >= vector1 ) print \"(A,L1)\" , '1._R4P >=vector1 => ' , ( 1._R4P >= vector1 ) print \"(A,L1)\" , '1_I8P  >=vector1 => ' , ( 1_I8P >= vector1 ) print \"(A,L1)\" , '1_I4P  >=vector1 => ' , ( 1_I4P >= vector1 ) print \"(A,L1)\" , '1_I2P  >=vector1 => ' , ( 1_I2P >= vector1 ) print \"(A,L1)\" , '1_I1P  >=vector1 => ' , ( 1_I1P >= vector1 ) print \"(A,L1)\" , 'vector1>=vector2 => ' , ( vector1 >= vector2 ) print \"(A)\" , ' Verify > operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1>1._R16P => ' , ( vector1 > 1._R16P ) print \"(A,L1)\" , 'vector1>1._R8P  => ' , ( vector1 > 1._R8P ) print \"(A,L1)\" , 'vector1>1._R4P  => ' , ( vector1 > 1._R4P ) print \"(A,L1)\" , 'vector1>1_I8P   => ' , ( vector1 > 1_I8P ) print \"(A,L1)\" , 'vector1>1_I4P   => ' , ( vector1 > 1_I4P ) print \"(A,L1)\" , 'vector1>1_I2P   => ' , ( vector1 > 1_I2P ) print \"(A,L1)\" , 'vector1>1_I1P   => ' , ( vector1 > 1_I1P ) print \"(A,L1)\" , '1._R16P>vector1 => ' , ( 1._R16P > vector1 ) print \"(A,L1)\" , '1._R8P >vector1 => ' , ( 1._R8P > vector1 ) print \"(A,L1)\" , '1._R4P >vector1 => ' , ( 1._R4P > vector1 ) print \"(A,L1)\" , '1_I8P  >vector1 => ' , ( 1_I8P > vector1 ) print \"(A,L1)\" , '1_I4P  >vector1 => ' , ( 1_I4P > vector1 ) print \"(A,L1)\" , '1_I2P  >vector1 => ' , ( 1_I2P > vector1 ) print \"(A,L1)\" , '1_I1P  >vector1 => ' , ( 1_I1P > vector1 ) print \"(A,L1)\" , 'vector1>vector2 => ' , ( vector1 > vector2 ) stop endprogram kinds","tags":"","loc":"program/kinds.html","title":"kinds – FLOw"},{"text":"Uses: VecFor program~~simple~~UsesGraph program~simple simple module~vecfor VecFor module~vecfor->program~simple iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Simple regression test for VecFor library. Calls program~~simple~~CallsGraph program~simple simple proc~face_normal4 face_normal4 program~simple->proc~face_normal4 proc~face_normal3 face_normal3 program~simple->proc~face_normal3 proc~sq_norm sq_norm program~simple->proc~sq_norm proc~norml2 normL2 program~simple->proc~norml2 proc~normalize normalize proc~face_normal4->proc~normalize proc~face_normal3->proc~normalize proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables vector1 vector2 vector3 vector4 vector5 Source Code simple Variables Type Attributes Name Initial type(vector) :: vector1 Vector dummy variable. type(vector) :: vector2 Vector dummy variable. type(vector) :: vector3 Vector dummy variable. type(vector) :: vector4 Vector dummy variable. type(vector) :: vector5 Vector dummy variable. Source Code program simple !< Simple regression test for VecFor library. use vecfor implicit none type ( vector ) :: vector1 !< Vector dummy variable. type ( vector ) :: vector2 !< Vector dummy variable. type ( vector ) :: vector3 !< Vector dummy variable. type ( vector ) :: vector4 !< Vector dummy variable. type ( vector ) :: vector5 !< Vector dummy variable. print \"(A)\" , ' Assign vector1 = [1, 2, 3]' vector1 = 1 * ex + 2 * ey + 3 * ez print \"(A)\" , ' Assign vector2 = [-1, -2, -3]' vector2 = - 1 * ex - 2 * ey - 3 * ez print \"(A)\" , ' Verify auxiliary methods' print \"(A,F5.1)\" , ' vector1%sq_norm() = ' , vector1 % sq_norm () print \"(A,F5.1)\" , ' sq_norm(vector1) = ' , sq_norm ( vector1 ) print \"(A,F5.1)\" , ' vector1%normL2() = ' , vector1 % normL2 () print \"(A,F5.1)\" , ' normL2(vector1) = ' , normL2 ( vector1 ) print \"(A)\" , ' normalized(vector1):' vector3 = vector1 % normalized () call vector3 % print print \"(A)\" , 'call vector1%normalize():' vector3 = vector1 call vector3 % normalize () call vector3 % print print \"(A)\" , ' Verify normalization fall-back for null vector' vector3 = 0 call vector3 % normalize () print \"(A)\" , 'call 0%normalize():' call vector3 % print vector3 = 0 vector3 = vector3 % normalized () print \"(A)\" , 'vector1 = 0%normalized():' call vector3 % print print \"(A)\" , ' Verify dot product' print \"(A,F5.1)\" , ' vector1.dot.ex = ' , vector1 . dot . ex print \"(A,F5.1)\" , ' vector1.dot.ey = ' , vector1 . dot . ey print \"(A,F5.1)\" , ' vector1.dot.ez = ' , vector1 . dot . ez print \"(A,F5.1)\" , ' vector1.dot.vector2 = ' , vector1 . dot . vector2 print \"(A)\" , ' Verify cross product' print \"(A)\" , ' vector1.cross.vector2:' vector3 = vector1 . cross . vector2 call vector3 % print print \"(A)\" , ' Verify special operators' print \"(A)\" , ' vector1.ortho.vector2:' vector3 = vector1 . ortho . vector2 call vector3 % print print \"(A)\" , ' vector1.paral.vector2:' vector3 = vector1 . paral . vector2 call vector3 % print print \"(A)\" , ' Verify * / + - operators' print \"(A)\" , ' vector1 * vector2:' vector3 = vector1 * vector2 call vector3 % print print \"(A)\" , ' vector1 / vector2:' vector3 = vector1 / vector2 call vector3 % print print \"(A)\" , ' vector1 + vector2:' vector3 = vector1 + vector2 call vector3 % print print \"(A)\" , ' vector1 - vector2:' vector3 = vector1 - vector2 call vector3 % print print \"(A)\" , ' Assign vector1 = [-1, 1, 0]' vector1 = - ex + ey print \"(A)\" , ' Assign vector2 = [0, 1, 0]' vector2 = ey print \"(A)\" , ' Assign vector3 = [0, -1, 0]' vector3 = - ey print \"(A)\" , ' Assign vector4 = [-1, -1, 0]' vector4 = - ex - ey print \"(A)\" , ' Face 1-2-3 normal (stand alone procedure):' vector5 = face_normal3 ( pt1 = vector1 , pt2 = vector2 , pt3 = vector3 ) call vector5 % print print \"(A)\" , ' Face 1-2-3 normal (stand alone procedure, normalized):' vector5 = face_normal3 ( norm = 'y' , pt1 = vector1 , pt2 = vector2 , pt3 = vector3 ) call vector5 % print print \"(A)\" , ' Face 1-2-3 normal (type bound method):' call vector5 % face_normal3 ( pt1 = vector1 , pt2 = vector2 , pt3 = vector3 ) call vector5 % print print \"(A)\" , ' Face 1-2-3 normal (type bound method, normalized):' call vector5 % face_normal3 ( norm = 'y' , pt1 = vector1 , pt2 = vector2 , pt3 = vector3 ) call vector5 % print print \"(A)\" , ' Face 1-2-3-4 normal (stand alone procedure): ' vector5 = face_normal4 ( pt1 = vector1 , pt2 = vector2 , pt3 = vector3 , pt4 = vector4 ) call vector5 % print print \"(A)\" , ' Face 1-2-3-4 normal (stand alone procedure, normalized): ' vector5 = face_normal4 ( norm = 'y' , pt1 = vector1 , pt2 = vector2 , pt3 = vector3 , pt4 = vector4 ) call vector5 % print print \"(A)\" , ' Face 1-2-3-4 normal (type bound method):' call vector5 % face_normal4 ( pt1 = vector1 , pt2 = vector2 , pt3 = vector3 , pt4 = vector4 ) call vector5 % print print \"(A)\" , ' Face 1-2-3-4 normal (type bound method, normalized):' call vector5 % face_normal4 ( norm = 'y' , pt1 = vector1 , pt2 = vector2 , pt3 = vector3 , pt4 = vector4 ) call vector5 % print print \"(A,I3)\" , ' IO length of vector1 = ' , vector1 % iolen () stop endprogram simple","tags":"","loc":"program/simple.html","title":"simple – FLOw"}]}